# Combined source export
# Root: C:\Users\kvikr\Downloads\claims-backend-full


// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\pom.xml =====

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.acme.claims</groupId>
    <artifactId>claims-backend</artifactId>
    <version>0.1.0</version>
    <name>claims-backend</name>

    <properties>
        <java.version>21</java.version>
        <spring-boot.version>3.3.2</spring-boot.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <lombok.version>1.18.32</lombok.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>1.20.2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Web, Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Security (placeholder for later; can be removed if not yet used) -->
<!--        <dependency>-->
<!--            <groupId>org.springframework.boot</groupId>-->
<!--            <artifactId>spring-boot-starter-security</artifactId>-->
<!--            <scope>provided</scope>-->
<!--        </dependency>-->

        <!-- Data + Postgres -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.3</version>
        </dependency>

        <!-- Flyway -->
        <!--    <dependency>-->
        <!--      <groupId>org.flywaydb</groupId>-->
        <!--      <artifactId>flyway-core</artifactId>-->
        <!--    </dependency>-->
        <!--    <dependency>-->
        <!--      <groupId>org.flywaydb</groupId>-->
        <!--      <artifactId>flyway-database-postgresql</artifactId>-->
        <!--    </dependency>-->

        <!-- SOAP (Spring-WS) -->
        <dependency>
            <groupId>org.springframework.ws</groupId>
            <artifactId>spring-ws-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.ws</groupId>
            <artifactId>spring-ws-support</artifactId>
        </dependency>
        <!-- Jakarta SAAJ API -->
        <dependency>
            <groupId>jakarta.xml.soap</groupId>
            <artifactId>jakarta.xml.soap-api</artifactId>
            <version>3.0.2</version>
        </dependency>

        <!-- Jakarta-compatible SAAJ implementation -->
        <dependency>
            <groupId>com.sun.xml.messaging.saaj</groupId>
            <artifactId>saaj-impl</artifactId>
            <version>3.0.4</version> <!-- 3.x = Jakarta; remove 1.5.3 -->
        </dependency>

        <dependency>
            <groupId>org.apache.httpcomponents.client5</groupId>
            <artifactId>httpclient5</artifactId>
            <version>5.3.1</version>
        </dependency>
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20240303</version>
        </dependency>


        <!-- JAXB + XML binding helpers -->
        <dependency>
            <groupId>org.glassfish.jaxb</groupId>
            <artifactId>jaxb-runtime</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>

        <!-- Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>4.2.0</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-inline</artifactId>
            <version>5.2.0</version>
            <scope>test</scope>
        </dependency>
        <!-- DB IT -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.github.tomakehurst</groupId>
            <artifactId>wiremock-jre8</artifactId>
            <version>2.35.1</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>com.vaadin.external.google</groupId>
                    <artifactId>android-json</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.11.0</version>
        </dependency>

    </dependencies>

    <profiles>
        <profile>
            <id>e2e</id>
            <activation>
                <property>
                    <name>env.E2E</name>
                    <value>true</value>
                </property>
            </activation>
            <build>
                <plugins>
                    <!-- Run E2E with Failsafe (keeps unit tests on Surefire) -->
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-failsafe-plugin</artifactId>
                        <version>3.2.5</version>
                        <configuration>
                            <includes>
                                <include>**/*E2EIT.java</include>
                                <include>**/*IT.java</include>
                            </includes>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>integration-test</goal>
                                    <goal>verify</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>

    <build>
        <finalName>${project.artifactId}</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.5</version>
                <configuration>
                    <useModulePath>false</useModulePath>
                    <!-- Optional: speed up & isolate -->
                    <forkCount>1</forkCount>
                    <reuseForks>true</reuseForks>
                    <includes>
                        <include>**/*Test.java</include>
                        <include>**/*Tests.java</include>
                    </includes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <release>21</release>
                    <parameters>true</parameters>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\admin\FacilityAdminController.java =====

package com.acme.claims.admin;

import com.acme.claims.security.ame.ReencryptJob;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
@RequestMapping("/admin/facilities")
@RequiredArgsConstructor
public class FacilityAdminController {

    private final FacilityAdminService svc;
    private final ReencryptJob reencrypt;

    @PostMapping
    //@PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<?> createOrUpdate(@RequestBody FacilityAdminService.FacilityDto dto) {
        svc.upsert(dto);
        log.info("Created new Facility : {}", dto.facilityCode());
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{code}")
    //@PreAuthorize("hasRole('SUPER_ADMIN') or hasRole('FACILITY_ADMIN')")
    public ResponseEntity<FacilityAdminService.FacilityView> get(@PathVariable String code) {
        return ResponseEntity.ok(svc.get(code));
    }

    @PatchMapping("/{code}/activate")
    //@PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<?> activate(@PathVariable String code, @RequestParam boolean active) {
        svc.activate(code, active);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/ame/rotate")
    //@PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<?> rotate() {
        int updated = reencrypt.reencryptAllIfNeeded();
        return ResponseEntity.ok().body("{\"updated\":"+updated+"}");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\admin\FacilityAdminService.java =====

package com.acme.claims.admin;

import com.acme.claims.security.ame.CredsCipherService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class FacilityAdminService {

    private final JdbcTemplate jdbc;
    private final CredsCipherService cipher;

    @Transactional
    public void upsert(FacilityDto dto) {
        validate(dto);
        var c = cipher.encrypt(dto.facilityCode(), dto.login(), dto.password());
        log.info("Addind new Facility : {}", dto.facilityCode());
        jdbc.update("""
                          insert into claims.facility_dhpo_config
                            (facility_code, facility_name,dhpo_username_enc, dhpo_password_enc, enc_meta_json)
                          values (?,?,?,?,?::jsonb)
                          on conflict (facility_code) do update set
                            facility_name=excluded.facility_name,
                            dhpo_username_enc=excluded.dhpo_username_enc,
                            dhpo_password_enc=excluded.dhpo_password_enc,
                            enc_meta_json=excluded.enc_meta_json
                        """,
                dto.facilityCode(), dto.facilityName(), c.loginCt(), c.pwdCt(), c.encMetaJson()
        );
    }

    public FacilityView get(String facilityCode) {
        var f = jdbc.query("""
                          select facility_code, facility_name from claims.facility_dhpo_config where facility_code=?
                        """, ps -> ps.setString(1, facilityCode),
                rs -> rs.next() ? new FacilityView(
                        rs.getString(1), rs.getString(2), "******" // never return password
                ) : null);
        if (f == null) throw new IllegalArgumentException("Facility not found");
        return f;
    }

    public void activate(String code, boolean active) {
        jdbc.update("update claims.facility_dhpo_config set active=? where facility_code=?", active, code);
    }

    private static void validate(FacilityDto d) {
        if (!StringUtils.hasText(d.facilityCode())) throw new IllegalArgumentException("facilityCode required");
        if (!StringUtils.hasText(d.facilityName())) throw new IllegalArgumentException("facilityName required");
        if (!StringUtils.hasText(d.login())) throw new IllegalArgumentException("login required");
        if (!StringUtils.hasText(d.password())) throw new IllegalArgumentException("password required");
    }

    private static String nz(String s) {
        return s == null ? "" : s;
    }

    public record FacilityDto(String facilityCode, String facilityName, String login, String password) {
    }

    public record FacilityView(String facilityCode, String facilityName, String passwordMasked) {
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\api\Response\ClaimTimelineResponse.java =====

package com.acme.claims.api.Response;

//@Schema(description = "Full view of a claim with a time-ordered event stream.")
public record ClaimTimelineResponse(
//        @Schema(description = "Business key of the claim (<Claim><ID>).")
//        String claimId,
//
//        @Schema(description = "Basic snapshot for the claim (from the latest submission row).")
//        ClaimDto basic
//
//        //@Schema(description = "Chronological list of events for this claim.")
//        //List<TimelineEntryDto> timeline
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ClaimsBackendApplication.java =====

package com.acme.claims;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.core.env.Environment;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@ConfigurationPropertiesScan(basePackages = "com.acme.claims")
@Slf4j
public class ClaimsBackendApplication {
    @Autowired
    Environment environment;
    public static void main(String[] args) {
        SpringApplication.run(ClaimsBackendApplication.class, args);
    }

    @jakarta.annotation.PostConstruct
    void logBootEnv() {
        log
                .info("boot: profiles={}, url={}, user={}",
                        String.join(",", environment.getActiveProfiles()),
                        environment.getProperty("spring.datasource.url"),
                        environment.getProperty("spring.datasource.username"));
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\config\AsyncConfig.java =====

package com.acme.claims.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "soapExecutor")
    public ThreadPoolTaskExecutor soapExecutor() {
        ThreadPoolTaskExecutor ex = new ThreadPoolTaskExecutor();
        ex.setThreadNamePrefix("soap-");
        ex.setCorePoolSize(16);        // start here; tune up/down
        ex.setMaxPoolSize(64);         // upper bound under load
        ex.setQueueCapacity(5000);     // large enough to avoid bursts rejecting
        ex.setKeepAliveSeconds(60);
        // When full, run task on caller thread instead of throwing:
        ex.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        ex.setWaitForTasksToCompleteOnShutdown(true);
        ex.setAwaitTerminationSeconds(30);
        ex.initialize();
        return ex;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\converter\ClaimEventTypeConverter.java =====

// FILE: src/main/java/com/acme/claims/domain/converter/ClaimEventTypeConverter.java
// Version: v2.0.0
package com.acme.claims.domain.converter;

import com.acme.claims.domain.enums.ClaimEventType;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = true)
public class ClaimEventTypeConverter implements AttributeConverter<ClaimEventType, Short> {
    @Override public Short convertToDatabaseColumn(ClaimEventType a){ return a==null?null:(short)a.getCode(); }
    @Override public ClaimEventType convertToEntityAttribute(Short db){ return db==null?null:ClaimEventType.from(db); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\converter\ClaimStatusConverter.java =====

// FILE: src/main/java/com/acme/claims/domain/converter/ClaimStatusConverter.java
// Version: v2.0.0
package com.acme.claims.domain.converter;

import com.acme.claims.domain.enums.ClaimStatus;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = true)
public class ClaimStatusConverter implements AttributeConverter<ClaimStatus, Short> {
    @Override public Short convertToDatabaseColumn(ClaimStatus a){ return a==null?null:(short)a.getCode(); }
    @Override public ClaimStatus convertToEntityAttribute(Short db){ return db==null?null:ClaimStatus.from(db); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\enums\ClaimEventType.java =====

// FILE: src/main/java/com/acme/claims/domain/enums/ClaimEventType.java
// Version: v2.0.0
package com.acme.claims.domain.enums;
public enum ClaimEventType { SUBMISSION(1), RESUBMISSION(2), REMITTANCE(3);
    private final int code; ClaimEventType(int c){this.code=c;} public int getCode(){return code;}
    public static ClaimEventType from(int c){ for(var v:values()) if(v.code==c) return v; throw new IllegalArgumentException("bad code:"+c);}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\enums\ClaimStatus.java =====

// FILE: src/main/java/com/acme/claims/domain/enums/ClaimStatus.java
// Version: v2.0.0
package com.acme.claims.domain.enums;
public enum ClaimStatus {
    SUBMITTED(1), RESUBMITTED(2), PAID(3), PARTIALLY_PAID(4), REJECTED(5), UNKNOWN(6);
    private final int code; ClaimStatus(int c){this.code=c;} public int getCode(){return code;}
    public static ClaimStatus from(int c){ for(var v:values()) if(v.code==c) return v; throw new IllegalArgumentException("bad code:"+c);}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\ActivityDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/ActivityDTO.java
// Version: v1.0.0
// XSD: Activity(ID, Start, Type, Code, Quantity, Net, Clinician, PriorAuthorizationID?, Observation*)  :contentReference[oaicite:7]{index=7}
package com.acme.claims.domain.model.dto;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.Set;

public record ActivityDTO(
        String id,
        OffsetDateTime start,
        String type,
        String code,
        BigDecimal quantity,
        BigDecimal net,
        String clinician,
        String priorAuthorizationId,
        Set<ObservationDTO> observations
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\AttachmentDTO.java =====

package com.acme.claims.domain.model.dto;

public record AttachmentDTO(
        String fileName,
        String mimeType,
        String base64Data // still base64 in DTO; decode before persisting
) {
    public boolean isEmpty() {
        return base64Data == null || base64Data.isBlank();
    }

    public byte[] decode() {
        return base64Data == null ? null : java.util.Base64.getDecoder().decode(base64Data);
    }

    @Override
    public String toString() {
        return "AttachmentDTO[fileName=%s, mimeType=%s, size=%d]"
                .formatted(fileName, mimeType, base64Data==null?0:base64Data.length());
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\ContractDTO.java =====

package com.acme.claims.domain.model.dto;

public record ContractDTO(String packageName) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\DiagnosisDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/DiagnosisDTO.java
// Version: v1.0.0
// XSD: Diagnosis(Type, Code)  :contentReference[oaicite:6]{index=6}
package com.acme.claims.domain.model.dto;

public record DiagnosisDTO(
        String type,
        String code
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\EncounterDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/EncounterDTO.java
// Version: v1.0.0
// XSD: Encounter(FacilityID, Type, PatientID, Start, End?, StartType?, EndType?, TransferSource?, TransferDestination?)  :contentReference[oaicite:5]{index=5}
package com.acme.claims.domain.model.dto;

import java.time.OffsetDateTime;

public record EncounterDTO(
        String facilityId,
        String type,
        String patientId,
        OffsetDateTime start,
        OffsetDateTime end,
        String startType,
        String endType,
        String transferSource,
        String transferDestination
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\IngestionFileDto.java =====

package com.acme.claims.domain.model.dto;

import java.time.LocalDateTime;

public record IngestionFileDto(
        String fileId,               // TEXT
        String fileName,             // TEXT
        String senderId,             // TEXT
        String receiverId,           // TEXT
        LocalDateTime transactionDate, // TIMESTAMPTZ
        Integer recordCountHint,     // INTEGER
        byte[] xmlBytes,             // BYTEA
        byte[] pdfBytes,             // BYTEA
        LocalDateTime downloadedAt, // TIMESTAMPTZ
        Short downloadMarked         // SMALLINT (0=success,1=fail)
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\ObservationDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/ObservationDTO.java
// Version: v1.0.0
// XSD: Observation(Type, Code, Value?, ValueType?)  :contentReference[oaicite:8]{index=8}
package com.acme.claims.domain.model.dto;

public record ObservationDTO(
        String type,  // this will be enum type RONIC, FILE, TEXT & others..
        String code, // will be FILE when type is FILE
        String value, // will be aBase64 string if type is FILE, else string for type: TEXT
        String valueType,// will be FILE when type is FILE
        byte[] fileBytes
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\RemittanceActivityDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/remittance/RemittanceActivityDTO.java
// Version: v1.0.0
// XSD: Activity(ID, Start, Type, Code, Quantity, Net, List?, Clinician, PriorAuthorizationID?, Gross?, PatientShare?, PaymentAmount, DenialCode?)  :contentReference[oaicite:14]{index=14}
package com.acme.claims.domain.model.dto;

import java.math.BigDecimal;
import java.time.OffsetDateTime;

public record RemittanceActivityDTO(
        String id,
        OffsetDateTime start,
        String type,
        String code,
        BigDecimal quantity,
        BigDecimal net,
        BigDecimal listPrice,           // List
        String clinician,
        String priorAuthorizationId,
        BigDecimal gross,
        BigDecimal patientShare,
        BigDecimal paymentAmount,
        String denialCode
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\RemittanceAdviceDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/remittance/RemittanceAdviceDTO.java
// Version: v1.0.0
// Aggregate root for Remittance.Advice  :contentReference[oaicite:12]{index=12}
package com.acme.claims.domain.model.dto;

import java.util.List;

public record RemittanceAdviceDTO(
        RemittanceHeaderDTO header,
        List<RemittanceClaimDTO> claims
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\RemittanceClaimDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/remittance/RemittanceClaimDTO.java
// Version: v1.0.0
// XSD: Claim(ID, IDPayer, ProviderID?, DenialCode?, PaymentReference, DateSettlement?, Encounter/FacilityID?) + Activity+  :contentReference[oaicite:13]{index=13}
package com.acme.claims.domain.model.dto;

import java.time.OffsetDateTime;
import java.util.List;

public record RemittanceClaimDTO(
        String id,
        String idPayer,
        String providerId,
        String denialCode,
        String paymentReference,
        OffsetDateTime dateSettlement,
        String facilityId, // Encounter/FacilityID flattened per SSOT
        List<RemittanceActivityDTO> activities
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\RemittanceHeaderDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/remittance/RemittanceHeaderDTO.java
// Version: v1.0.0 (XSD Header)
// XSD: Header fields same as submission  :contentReference[oaicite:11]{index=11}
package com.acme.claims.domain.model.dto;

import java.time.OffsetDateTime;

public record RemittanceHeaderDTO(
        String senderId,
        String receiverId,
        OffsetDateTime transactionDate,
        int recordCount,
        String dispositionFlag
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\ResubmissionDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/ResubmissionDTO.java
// Version: v1.0.0
// XSD: Resubmission(Type, Comment, Attachment?)  :contentReference[oaicite:9]{index=9}
package com.acme.claims.domain.model.dto;

public record ResubmissionDTO(
        String type,
        String comment,
        byte[] attachment
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\SubmissionClaimDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/SubmissionClaimDTO.java
// Version: v1.0.0
// XSD: Claim(ID, IDPayer?, MemberID?, PayerID, ProviderID, EmiratesIDNumber, Gross, PatientShare, Net, Encounter?, Diagnosis+, Activity+, Resubmission?, Contract?)  :contentReference[oaicite:4]{index=4}
package com.acme.claims.domain.model.dto;

import java.math.BigDecimal;
import java.util.Set;

public record SubmissionClaimDTO(
        String id,
        String idPayer,
        String memberId,
        String payerId,
        String providerId,
        String emiratesIdNumber,
        BigDecimal gross,
        BigDecimal patientShare,
        BigDecimal net,
        String comments,
        EncounterDTO encounter,                     // nullable
        Set<DiagnosisDTO> diagnoses,
        Set<ActivityDTO> activities,
        ResubmissionDTO resubmission,               // nullable
        ContractDTO contract                        // nullable
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\SubmissionDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/SubmissionDTO.java
// Version: v1.0.0
// Aggregate root for Claim.Submission  :contentReference[oaicite:3]{index=3}
package com.acme.claims.domain.model.dto;

import java.util.List;

public record SubmissionDTO(
        SubmissionHeaderDTO header,
        List<SubmissionClaimDTO> claims
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\dto\SubmissionHeaderDTO.java =====

// FILE: src/main/java/com/acme/claims/ingestion/dto/submission/SubmissionHeaderDTO.java
// Version: v1.0.0 (XSD Header)
// XSD: SenderID, ReceiverID, TransactionDate, RecordCount, DispositionFlag  :contentReference[oaicite:2]{index=2}
package com.acme.claims.domain.model.dto;

import java.time.OffsetDateTime;

public record SubmissionHeaderDTO(
        String senderId,
        String receiverId,
        OffsetDateTime transactionDate,
        int recordCount,
        String dispositionFlag
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Activity.java =====

// FILE: src/main/java/com/acme/claims/domain/Activity.java
// Version: v2.0.0
// Maps: claims.activity
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.math.BigDecimal;
import java.time.OffsetDateTime;

@Entity
@Table(name = "activity", schema = "claims",
        uniqueConstraints = @UniqueConstraint(name = "uq_activity_bk", columnNames = {"claim_id", "activity_id"}),
        indexes = @Index(name = "idx_activity_claim", columnList = "claim_id"))
public class Activity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "claim_id", nullable = false)
    private Claim claim;
    @Column(name = "activity_id", nullable = false)
    private String activityId;
    @Column(name = "start_at", nullable = false)
    private OffsetDateTime startAt;
    @Column(name = "type", nullable = false)
    private String type;
    @Column(name = "code", nullable = false)
    private String code;
    @Column(name = "quantity", nullable = false, precision = 14, scale = 2)
    private BigDecimal quantity;
    @Column(name = "net", nullable = false, precision = 14, scale = 2)
    private BigDecimal net;
    @Column(name = "clinician", nullable = false)
    private String clinician;
    @Column(name = "prior_authorization_id")
    private String priorAuthorizationId;
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt = OffsetDateTime.now();
    @Column(name = "activity_code_ref_id")
    private Long activityCodeRefId;
    @Column(name = "clinician_ref_id")
    private Long clinicianRefId;

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Claim getClaim() {
        return claim;
    }

    public void setClaim(Claim v) {
        this.claim = v;
    }

    public String getActivityId() {
        return activityId;
    }

    public void setActivityId(String v) {
        this.activityId = v;
    }

    public OffsetDateTime getStartAt() {
        return startAt;
    }

    public void setStartAt(OffsetDateTime v) {
        this.startAt = v;
    }

    public String getType() {
        return type;
    }

    public void setType(String v) {
        this.type = v;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String v) {
        this.code = v;
    }

    public BigDecimal getQuantity() {
        return quantity;
    }

    public void setQuantity(BigDecimal v) {
        this.quantity = v;
    }

    public BigDecimal getNet() {
        return net;
    }

    public void setNet(BigDecimal v) {
        this.net = v;
    }

    public String getClinician() {
        return clinician;
    }

    public void setClinician(String v) {
        this.clinician = v;
    }

    public String getPriorAuthorizationId() {
        return priorAuthorizationId;
    }

    public void setPriorAuthorizationId(String v) {
        this.priorAuthorizationId = v;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime v) {
        this.createdAt = v;
    }

    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(OffsetDateTime v) {
        this.updatedAt = v;
    }

    public Long getActivityCodeRefId() {
        return activityCodeRefId;
    }

    public void setActivityCodeRefId(Long activityCodeRefId) {
        this.activityCodeRefId = activityCodeRefId;
    }

    public Long getClinicianRefId() {
        return clinicianRefId;
    }

    public void setClinicianRefId(Long clinicianRefId) {
        this.clinicianRefId = clinicianRefId;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Claim.java =====

// FILE: src/main/java/com/acme/claims/domain/Claim.java
// Version: v2.0.0
// Maps: claims.claim
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.math.BigDecimal;
import java.time.OffsetDateTime;

@Entity
@Table(name = "claim", schema = "claims",
        uniqueConstraints = @UniqueConstraint(name = "uq_claim_per_key", columnNames = "claim_key_id"),
        indexes = @Index(name = "idx_claim_claim_key", columnList = "claim_key_id"))
public class Claim {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "claim_key_id", nullable = false)
    private ClaimKey claimKey;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "submission_id", nullable = false)
    private Submission submission;
    @Column(name = "id_payer")
    private String idPayer;
    @Column(name = "member_id")
    private String memberId;
    @Column(name = "payer_id", nullable = false)
    private String payerId;
    @Column(name = "provider_id", nullable = false)
    private String providerId;
    @Column(name = "emirates_id_number", nullable = false)
    private String emiratesIdNumber;
    @Column(name = "gross", nullable = false, precision = 14, scale = 2)
    private BigDecimal gross;
    @Column(name = "patient_share", nullable = false, precision = 14, scale = 2)
    private BigDecimal patientShare;
    @Column(name = "net", nullable = false, precision = 14, scale = 2)
    private BigDecimal net;
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt = OffsetDateTime.now();
    @Column(name = "payer_ref_id")
    private Long payerRefId;
    @Column(name = "provider_ref_id")
    private Long providerRefId;
    @Column(name = "tx_at", nullable = false, insertable = false, updatable = false)
    private OffsetDateTime txAt;
    @Column(name = "comments")
    private String comments;

    // getters/setters...
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public ClaimKey getClaimKey() {
        return claimKey;
    }

    public void setClaimKey(ClaimKey v) {
        this.claimKey = v;
    }

    public Submission getSubmission() {
        return submission;
    }

    public void setSubmission(Submission v) {
        this.submission = v;
    }

    public String getIdPayer() {
        return idPayer;
    }

    public void setIdPayer(String v) {
        this.idPayer = v;
    }

    public String getMemberId() {
        return memberId;
    }

    public void setMemberId(String v) {
        this.memberId = v;
    }

    public String getPayerId() {
        return payerId;
    }

    public void setPayerId(String v) {
        this.payerId = v;
    }

    public String getProviderId() {
        return providerId;
    }

    public void setProviderId(String v) {
        this.providerId = v;
    }

    public String getEmiratesIdNumber() {
        return emiratesIdNumber;
    }

    public void setEmiratesIdNumber(String v) {
        this.emiratesIdNumber = v;
    }

    public BigDecimal getGross() {
        return gross;
    }

    public void setGross(BigDecimal v) {
        this.gross = v;
    }

    public BigDecimal getPatientShare() {
        return patientShare;
    }

    public void setPatientShare(BigDecimal v) {
        this.patientShare = v;
    }

    public BigDecimal getNet() {
        return net;
    }

    public void setNet(BigDecimal v) {
        this.net = v;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime v) {
        this.createdAt = v;
    }

    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(OffsetDateTime v) {
        this.updatedAt = v;
    }

    public Long getPayerRefId() {
        return payerRefId;
    }

    public void setPayerRefId(Long payerRefId) {
        this.payerRefId = payerRefId;
    }

    public Long getProviderRefId() {
        return providerRefId;
    }

    public void setProviderRefId(Long providerRefId) {
        this.providerRefId = providerRefId;
    }

    public OffsetDateTime getTxAt() {
        return txAt;
    }

    public void setTxAt(OffsetDateTime txAt) {
        this.txAt = txAt;
    }

    public String getComments() {
        return comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimAttachment.java =====

package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.OffsetDateTime;

@Entity
@Table(name = "claim_attachment", schema = "claims",
        uniqueConstraints = @UniqueConstraint(
                name = "uq_claim_attachment_key_event_file",
                columnNames = {"claim_key_id","claim_event_id","file_name"}))
@Getter @Setter @NoArgsConstructor @AllArgsConstructor
public class ClaimAttachment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "claim_key_id", nullable = false)
    private Long claimKeyId;

    @Column(name = "claim_event_id", nullable = false)
    private Long claimEventId;

    @Column(name = "file_name")
    private String fileName;

    @Column(name = "mime_type")
    private String mimeType;

    @Lob
    @Column(name = "data_base64", nullable = false, columnDefinition = "bytea")
    private byte[] dataBase64;

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimContract.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimContract.java
// Version: v2.0.0
// Maps: claims.claim_contract
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

@Entity @Table(name="claim_contract", schema="claims")
public class ClaimContract {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_id", nullable=false)
    private Claim claim;
    @Column(name="package_name") private String packageName;
    // getters/setters
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public Claim getClaim(){return claim;} public void setClaim(Claim v){this.claim=v;}
    public String getPackageName(){return packageName;} public void setPackageName(String v){this.packageName=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimEvent.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimEvent.java
// Version: v2.0.0
// Maps: claims.claim_event (event_time set from Header.TransactionDate; provenance -> ingestion_file)
package com.acme.claims.domain.model.entity;

import com.acme.claims.domain.enums.ClaimEventType;
import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="claim_event", schema="claims",
        indexes={@Index(name="idx_event_claim_key", columnList="claim_key_id")})
public class ClaimEvent {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_key_id", nullable=false)
    private ClaimKey claimKey;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_file_id")
    private IngestionFile ingestionFile; // provenance
    @Column(name="event_time", nullable=false) private OffsetDateTime eventTime;
    @Column(name="type", nullable=false) private ClaimEventType type; // converter -> SMALLINT
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="submission_id") private Submission submission;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="remittance_id") private Remittance remittance;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public ClaimKey getClaimKey(){return claimKey;} public void setClaimKey(ClaimKey v){this.claimKey=v;}
    public IngestionFile getIngestionFile(){return ingestionFile;} public void setIngestionFile(IngestionFile v){this.ingestionFile=v;}
    public OffsetDateTime getEventTime(){return eventTime;} public void setEventTime(OffsetDateTime v){this.eventTime=v;}
    public ClaimEventType getType(){return type;} public void setType(ClaimEventType v){this.type=v;}
    public Submission getSubmission(){return submission;} public void setSubmission(Submission v){this.submission=v;}
    public Remittance getRemittance(){return remittance;} public void setRemittance(Remittance v){this.remittance=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimEventActivity.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimEventActivity.java
// Version: v2.0.0
// Maps: claims.claim_event_activity
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.OffsetDateTime;

@Entity
@Table(name="claim_event_activity", schema="claims",
        indexes=@Index(name="idx_cea_event", columnList="claim_event_id"))
public class ClaimEventActivity {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_event_id", nullable=false)
    private ClaimEvent claimEvent;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="activity_id_ref")
    private Activity activityRef;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="remittance_activity_id_ref")
    private RemittanceActivity remittanceActivityRef;

    @Column(name="activity_id_at_event", nullable=false) private String activityIdAtEvent;
    @Column(name="start_at_event", nullable=false) private OffsetDateTime startAtEvent;
    @Column(name="type_at_event", nullable=false) private String typeAtEvent;
    @Column(name="code_at_event", nullable=false) private String codeAtEvent;
    @Column(name="quantity_at_event", nullable=false, precision=14, scale=2) private BigDecimal quantityAtEvent;
    @Column(name="net_at_event", nullable=false, precision=14, scale=2) private BigDecimal netAtEvent;
    @Column(name="clinician_at_event", nullable=false) private String clinicianAtEvent;
    @Column(name="prior_authorization_id_at_event") private String priorAuthorizationIdAtEvent;

    @Column(name="list_price_at_event", precision=14, scale=2) private BigDecimal listPriceAtEvent;
    @Column(name="gross_at_event", precision=14, scale=2) private BigDecimal grossAtEvent;
    @Column(name="patient_share_at_event", precision=14, scale=2) private BigDecimal patientShareAtEvent;
    @Column(name="payment_amount_at_event", precision=14, scale=2) private BigDecimal paymentAmountAtEvent;
    @Column(name="denial_code_at_event") private String denialCodeAtEvent;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public ClaimEvent getClaimEvent(){return claimEvent;} public void setClaimEvent(ClaimEvent v){this.claimEvent=v;}
    public Activity getActivityRef(){return activityRef;} public void setActivityRef(Activity v){this.activityRef=v;}
    public RemittanceActivity getRemittanceActivityRef(){return remittanceActivityRef;}
    public void setRemittanceActivityRef(RemittanceActivity v){this.remittanceActivityRef=v;}
    public String getActivityIdAtEvent(){return activityIdAtEvent;} public void setActivityIdAtEvent(String v){this.activityIdAtEvent=v;}
    public OffsetDateTime getStartAtEvent(){return startAtEvent;} public void setStartAtEvent(OffsetDateTime v){this.startAtEvent=v;}
    public String getTypeAtEvent(){return typeAtEvent;} public void setTypeAtEvent(String v){this.typeAtEvent=v;}
    public String getCodeAtEvent(){return codeAtEvent;} public void setCodeAtEvent(String v){this.codeAtEvent=v;}
    public BigDecimal getQuantityAtEvent(){return quantityAtEvent;} public void setQuantityAtEvent(BigDecimal v){this.quantityAtEvent=v;}
    public BigDecimal getNetAtEvent(){return netAtEvent;} public void setNetAtEvent(BigDecimal v){this.netAtEvent=v;}
    public String getClinicianAtEvent(){return clinicianAtEvent;} public void setClinicianAtEvent(String v){this.clinicianAtEvent=v;}
    public String getPriorAuthorizationIdAtEvent(){return priorAuthorizationIdAtEvent;}
    public void setPriorAuthorizationIdAtEvent(String v){this.priorAuthorizationIdAtEvent=v;}
    public BigDecimal getListPriceAtEvent(){return listPriceAtEvent;} public void setListPriceAtEvent(BigDecimal v){this.listPriceAtEvent=v;}
    public BigDecimal getGrossAtEvent(){return grossAtEvent;} public void setGrossAtEvent(BigDecimal v){this.grossAtEvent=v;}
    public BigDecimal getPatientShareAtEvent(){return patientShareAtEvent;} public void setPatientShareAtEvent(BigDecimal v){this.patientShareAtEvent=v;}
    public BigDecimal getPaymentAmountAtEvent(){return paymentAmountAtEvent;} public void setPaymentAmountAtEvent(BigDecimal v){this.paymentAmountAtEvent=v;}
    public String getDenialCodeAtEvent(){return denialCodeAtEvent;} public void setDenialCodeAtEvent(String v){this.denialCodeAtEvent=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimKey.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimKey.java
// Version: v2.0.0
// Maps: claims.claim_key
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity @Table(name="claim_key", schema="claims")
public class ClaimKey {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @Column(name="claim_id", nullable=false, unique=true) private String claimId;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public String getClaimId(){return claimId;} public void setClaimId(String v){this.claimId=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimResubmission.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimResubmission.java
// Version: v2.0.0
// Maps: claims.claim_resubmission (1:1 with RESUBMISSION event)
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

@Entity
@Table(name="claim_resubmission", schema="claims")
public class ClaimResubmission {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @OneToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_event_id", nullable=false, unique=true)
    private ClaimEvent claimEvent;
    @Column(name="resubmission_type", nullable=false) private String resubmissionType;
    @Column(name="comment", nullable=false) private String comment;
    @Column(name="attachment") private byte[] attachment;
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public ClaimEvent getClaimEvent(){return claimEvent;} public void setClaimEvent(ClaimEvent v){this.claimEvent=v;}
    public String getResubmissionType(){return resubmissionType;} public void setResubmissionType(String v){this.resubmissionType=v;}
    public String getComment(){return comment;} public void setComment(String v){this.comment=v;}
    public byte[] getAttachment(){return attachment;} public void setAttachment(byte[] v){this.attachment=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\ClaimStatusTimeline.java =====

// FILE: src/main/java/com/acme/claims/domain/ClaimStatusTimeline.java
// Version: v2.0.0
// Maps: claims.claim_status_timeline
package com.acme.claims.domain.model.entity;

import com.acme.claims.domain.enums.ClaimStatus;
import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="claim_status_timeline", schema="claims",
        indexes=@Index(name="idx_cst_claim_key_time", columnList="claim_key_id, status_time"))
public class ClaimStatusTimeline {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_key_id", nullable=false)
    private ClaimKey claimKey;
    @Column(name="status", nullable=false) private ClaimStatus status; // converter -> SMALLINT
    @Column(name="status_time", nullable=false) private OffsetDateTime statusTime;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_event_id")
    private ClaimEvent claimEvent;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public ClaimKey getClaimKey(){return claimKey;} public void setClaimKey(ClaimKey v){this.claimKey=v;}
    public ClaimStatus getStatus(){return status;} public void setStatus(ClaimStatus v){this.status=v;}
    public OffsetDateTime getStatusTime(){return statusTime;} public void setStatusTime(OffsetDateTime v){this.statusTime=v;}
    public ClaimEvent getClaimEvent(){return claimEvent;} public void setClaimEvent(ClaimEvent v){this.claimEvent=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Diagnosis.java =====

// FILE: src/main/java/com/acme/claims/domain/Diagnosis.java
// Version: v2.0.0
// Maps: claims.diagnosis
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "diagnosis", schema = "claims",
        indexes = @Index(name = "idx_diagnosis_claim", columnList = "claim_id"))
public class Diagnosis {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "claim_id", nullable = false)
    private Claim claim;
    @Column(name = "diag_type", nullable = false)
    private String diagType;
    @Column(name = "code", nullable = false)
    private String code;
    @Column(name = "diagnosis_code_ref_id")
    private Long diagnosisCodeRefId;

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Claim getClaim() {
        return claim;
    }

    public void setClaim(Claim v) {
        this.claim = v;
    }

    public String getDiagType() {
        return diagType;
    }

    public void setDiagType(String v) {
        this.diagType = v;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String v) {
        this.code = v;
    }

    public Long getDiagnosisCodeRefId() {
        return diagnosisCodeRefId;
    }

    public void setDiagnosisCodeRefId(Long diagnosisCodeRefId) {
        this.diagnosisCodeRefId = diagnosisCodeRefId;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Encounter.java =====

// FILE: src/main/java/com/acme/claims/domain/Encounter.java
// Version: v2.0.0
// Maps: claims.encounter
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.time.OffsetDateTime;

@Entity
@Table(name = "encounter", schema = "claims",
        indexes = @Index(name = "idx_encounter_claim", columnList = "claim_id"))
public class Encounter {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "claim_id", nullable = false)
    private Claim claim;
    @Column(name = "facility_id", nullable = false)
    private String facilityId;
    @Column(name = "type", nullable = false)
    private String type;
    @Column(name = "patient_id", nullable = false)
    private String patientId;
    @Column(name = "start_at", nullable = false)
    private OffsetDateTime startAt;
    @Column(name = "end_at")
    private OffsetDateTime endAt;
    @Column(name = "start_type")
    private String startType;
    @Column(name = "end_type")
    private String endType;
    @Column(name = "transfer_source")
    private String transferSource;
    @Column(name = "transfer_destination")
    private String transferDestination;

    @Column(name = "facility_ref_id")
    private Long facilityRefId;

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Claim getClaim() {
        return claim;
    }

    public void setClaim(Claim v) {
        this.claim = v;
    }

    public String getFacilityId() {
        return facilityId;
    }

    public void setFacilityId(String v) {
        this.facilityId = v;
    }

    public String getType() {
        return type;
    }

    public void setType(String v) {
        this.type = v;
    }

    public String getPatientId() {
        return patientId;
    }

    public void setPatientId(String v) {
        this.patientId = v;
    }

    public OffsetDateTime getStartAt() {
        return startAt;
    }

    public void setStartAt(OffsetDateTime v) {
        this.startAt = v;
    }

    public OffsetDateTime getEndAt() {
        return endAt;
    }

    public void setEndAt(OffsetDateTime v) {
        this.endAt = v;
    }

    public String getStartType() {
        return startType;
    }

    public void setStartType(String v) {
        this.startType = v;
    }

    public String getEndType() {
        return endType;
    }

    public void setEndType(String v) {
        this.endType = v;
    }

    public String getTransferSource() {
        return transferSource;
    }

    public void setTransferSource(String v) {
        this.transferSource = v;
    }

    public String getTransferDestination() {
        return transferDestination;
    }

    public void setTransferDestination(String v) {
        this.transferDestination = v;
    }

    public Long getFacilityRefId() {
        return facilityRefId;
    }

    public void setFacilityRefId(Long facilityRefId) {
        this.facilityRefId = facilityRefId;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\EventObservation.java =====

// FILE: src/main/java/com/acme/claims/domain/EventObservation.java
// Version: v2.0.0
// Maps: claims.event_observation
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="event_observation", schema="claims",
        indexes=@Index(name="idx_event_obs_cea", columnList="claim_event_activity_id"))
public class EventObservation {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="claim_event_activity_id", nullable=false)
    private ClaimEventActivity claimEventActivity;
    @Column(name="obs_type", nullable=false) private String obsType;
    @Column(name="obs_code", nullable=false) private String obsCode;
    @Column(name="value_text") private String valueText;
    @Column(name="value_type") private String valueType;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public ClaimEventActivity getClaimEventActivity(){return claimEventActivity;}
    public void setClaimEventActivity(ClaimEventActivity v){this.claimEventActivity=v;}
    public String getObsType(){return obsType;} public void setObsType(String v){this.obsType=v;}
    public String getObsCode(){return obsCode;} public void setObsCode(String v){this.obsCode=v;}
    public String getValueText(){return valueText;} public void setValueText(String v){this.valueText=v;}
    public String getValueType(){return valueType;} public void setValueType(String v){this.valueType=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\FacilityDhpoConfig.java =====

package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.OffsetDateTime;

/**
 * Entity for claims.facility_dhpo_config (lean version).
 * DDL owner: Flyway/Liquibase or manual migration.
 * Notes:
 * - enc_meta_json is kept as JSONB in DB; mapped here as String to avoid extra deps.
 * - dhpo_username_enc / dhpo_password_enc are ciphertext blobs (BYTEA).
 * - endpoint_url_for_erx is included for future eRx flows.
 */
@Entity
@Table(
        name = "facility_dhpo_config",
        schema = "claims",
        uniqueConstraints = {
                @UniqueConstraint(name = "uq_facility_dhpo_config_facility_code", columnNames = "facility_code")
        }
)
public class FacilityDhpoConfig {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;                                 // BIGSERIAL

    @Column(name = "facility_code", nullable = false, columnDefinition = "citext")
    private String facilityCode;                     // CITEXT NOT NULL

    @Column(name = "facility_name", nullable = false)
    private String facilityName;                     // TEXT NOT NULL

    @Column(name = "endpoint_url", nullable = false)
    private String endpointUrl = "https://dhpo.eclaimlink.ae/ValidateTransactions.asmx"; // TEXT NOT NULL DEFAULT ...

    @Column(name = "endpoint_url_for_erx", nullable = false)
    private String endpointUrlForErx = "https://dhpo.eclaimlink.ae/eRxValidateTransactions.asmx"; // TEXT NOT NULL DEFAULT ...

    @JdbcTypeCode(SqlTypes.BINARY)
    @Column(name = "dhpo_username_enc", nullable = false)
    private byte[] dhpoUsernameEnc;                  // BYTEA NOT NULL

    @JdbcTypeCode(SqlTypes.BINARY)
    @Column(name = "dhpo_password_enc", nullable = false)
    private byte[] dhpoPasswordEnc;                  // BYTEA NOT NULL

    @Column(name = "enc_meta_json", nullable = false, columnDefinition = "jsonb")
    private String encMetaJson;                      // JSONB NOT NULL : {"kek_version":1,"alg":"AES/GCM","iv":"...","tagBits":128}

    @Column(name = "active", nullable = false)
    private boolean active = true;                   // BOOLEAN NOT NULL DEFAULT TRUE

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;                // TIMESTAMPTZ NOT NULL DEFAULT now()

    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;                // TIMESTAMPTZ NOT NULL DEFAULT now()

    // --- lifecycle hooks ---
    @PrePersist
    void onCreate() {
        final var now = OffsetDateTime.now();
        if (createdAt == null) createdAt = now;
        if (updatedAt == null) updatedAt = now;
    }

    @PreUpdate
    void onUpdate() {
        updatedAt = OffsetDateTime.now();
    }

    // --- getters/setters (explicit for clarity & Lombok-free compatibility) ---
    public Long getId() {
        return id;
    }

    public String getFacilityCode() {
        return facilityCode;
    }

    public void setFacilityCode(String facilityCode) {
        this.facilityCode = facilityCode;
    }

    public String getFacilityName() {
        return facilityName;
    }

    public void setFacilityName(String facilityName) {
        this.facilityName = facilityName;
    }

    public String getEndpointUrl() {
        return endpointUrl;
    }

    public void setEndpointUrl(String endpointUrl) {
        this.endpointUrl = endpointUrl;
    }

    public String getEndpointUrlForErx() {
        return endpointUrlForErx;
    }

    public void setEndpointUrlForErx(String endpointUrlForErx) {
        this.endpointUrlForErx = endpointUrlForErx;
    }

    public byte[] getDhpoUsernameEnc() {
        return dhpoUsernameEnc;
    }

    public void setDhpoUsernameEnc(byte[] dhpoUsernameEnc) {
        this.dhpoUsernameEnc = dhpoUsernameEnc;
    }

    public byte[] getDhpoPasswordEnc() {
        return dhpoPasswordEnc;
    }

    public void setDhpoPasswordEnc(byte[] dhpoPasswordEnc) {
        this.dhpoPasswordEnc = dhpoPasswordEnc;
    }

    public String getEncMetaJson() {
        return encMetaJson;
    }

    public void setEncMetaJson(String encMetaJson) {
        this.encMetaJson = encMetaJson;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(OffsetDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\IngestionBatchMetric.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/IngestionBatchMetric.java
// Version: v2.0.0
// Maps: claims.ingestion_batch_metric
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="ingestion_batch_metric", schema="claims",
        indexes=@Index(name="idx_batch_metric_file", columnList="ingestion_file_id, stage, batch_no"))
public class IngestionBatchMetric {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_file_id", nullable=false)
    private IngestionFile ingestionFile;
    @Column(name="stage", nullable=false) private String stage;
    @Column(name="target_table") private String targetTable;
    @Column(name="batch_no", nullable=false) private Integer batchNo;
    @Column(name="started_at", nullable=false) private OffsetDateTime startedAt = OffsetDateTime.now();
    @Column(name="ended_at") private OffsetDateTime endedAt;
    @Column(name="rows_attempted", nullable=false) private Integer rowsAttempted=0;
    @Column(name="rows_inserted", nullable=false) private Integer rowsInserted=0;
    @Column(name="conflicts_ignored", nullable=false) private Integer conflictsIgnored=0;
    @Column(name="retries", nullable=false) private Integer retries=0;
    @Column(name="status", nullable=false) private String status;
    @Column(name="error_class") private String errorClass;
    @Column(name="error_message") private String errorMessage;
    // getters/setters…
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\IngestionError.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/IngestionError.java
// Version: v2.0.0
// Maps: claims.ingestion_error
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="ingestion_error", schema="claims",
        indexes=@Index(name="idx_ing_error_file_stage", columnList="ingestion_file_id, stage, occurred_at desc"))
public class IngestionError {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_file_id", nullable=false)
    private IngestionFile ingestionFile;
    @Column(name="stage", nullable=false) private String stage;
    @Column(name="object_type") private String objectType;
    @Column(name="object_key") private String objectKey;
    @Column(name="error_code") private String errorCode;
    @Column(name="error_message", nullable=false) private String errorMessage;
    @Column(name="stack_excerpt") private String stackExcerpt;
    @Column(name="retryable", nullable=false) private boolean retryable=false;
    @Column(name="occurred_at", nullable=false) private OffsetDateTime occurredAt = OffsetDateTime.now();
    // getters/setters…

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public IngestionFile getIngestionFile() {
        return ingestionFile;
    }

    public void setIngestionFile(IngestionFile ingestionFile) {
        this.ingestionFile = ingestionFile;
    }

    public String getStage() {
        return stage;
    }

    public void setStage(String stage) {
        this.stage = stage;
    }

    public String getObjectType() {
        return objectType;
    }

    public void setObjectType(String objectType) {
        this.objectType = objectType;
    }

    public String getObjectKey() {
        return objectKey;
    }

    public void setObjectKey(String objectKey) {
        this.objectKey = objectKey;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }

    public String getStackExcerpt() {
        return stackExcerpt;
    }

    public void setStackExcerpt(String stackExcerpt) {
        this.stackExcerpt = stackExcerpt;
    }

    public boolean isRetryable() {
        return retryable;
    }

    public void setRetryable(boolean retryable) {
        this.retryable = retryable;
    }

    public OffsetDateTime getOccurredAt() {
        return occurredAt;
    }

    public void setOccurredAt(OffsetDateTime occurredAt) {
        this.occurredAt = occurredAt;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\IngestionFile.java =====

// FILE: src/main/java/com/acme/claims/domain/IngestionFile.java
// Version: v2.0.0 (SSOT: Combined DDL - 2025-09-02)
// Maps: claims.ingestion_file
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

@Entity
@Table(name = "ingestion_file", schema = "claims",
        uniqueConstraints = @UniqueConstraint(name = "uq_ingestion_file", columnNames = "file_id"))
@NoArgsConstructor
@AllArgsConstructor
public class IngestionFile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "file_id", nullable = false)
    private String fileId;
    @Column(name = "root_type", nullable = false)
    private short rootType; // 1=Submission,2=Remittance
    @Column(name = "sender_id", nullable = false)
    private String senderId;
    @Column(name = "receiver_id", nullable = false)
    private String receiverId;
    @Column(name = "transaction_date", nullable = false)
    private OffsetDateTime transactionDate;
    @Column(name = "record_count_declared", nullable = false)
    private Integer recordCountDeclared;
    @Column(name = "disposition_flag", nullable = false)
    private String dispositionFlag;
    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(name = "xml_bytes", nullable = false, columnDefinition = "bytea")
    private byte[] xmlBytes;
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt = OffsetDateTime.now();

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFileId() {
        return fileId;
    }

    public void setFileId(String v) {
        this.fileId = v;
    }

    public short getRootType() {
        return rootType;
    }

    public void setRootType(short v) {
        this.rootType = v;
    }

    public String getSenderId() {
        return senderId;
    }

    public void setSenderId(String v) {
        this.senderId = v;
    }

    public String getReceiverId() {
        return receiverId;
    }

    public void setReceiverId(String v) {
        this.receiverId = v;
    }

    public OffsetDateTime getTransactionDate() {
        return transactionDate;
    }

    public void setTransactionDate(OffsetDateTime v) {
        this.transactionDate = v;
    }

    public Integer getRecordCountDeclared() {
        return recordCountDeclared;
    }

    public void setRecordCountDeclared(Integer v) {
        this.recordCountDeclared = v;
    }

    public String getDispositionFlag() {
        return dispositionFlag;
    }

    public void setDispositionFlag(String v) {
        this.dispositionFlag = v;
    }

    public byte[] getXmlBytes() {
        return xmlBytes;
    }

    public void setXmlBytes(byte[] v) {
        this.xmlBytes = v;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime v) {
        this.createdAt = v;
    }

    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(OffsetDateTime v) {
        this.updatedAt = v;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\IngestionFileAudit.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/IngestionFileAudit.java
// Version: v2.0.0
// Maps: claims.ingestion_file_audit
package com.acme.claims.domain.model.entity;


import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="ingestion_file_audit", schema="claims",
        indexes={@Index(name="idx_file_audit_run", columnList="ingestion_run_id"),
                @Index(name="idx_file_audit_file", columnList="ingestion_file_id")})
public class IngestionFileAudit {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_run_id", nullable=false)
    private IngestionRun ingestionRun;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_file_id", nullable=false)
    private IngestionFile ingestionFile;
    @Column(name="status", nullable=false) private short status; // 0=ALREADY,1=OK,2=FAIL
    @Column(name="reason") private String reason;
    @Column(name="error_class") private String errorClass;
    @Column(name="error_message") private String errorMessage;
    @Column(name="validation_ok", nullable=false) private boolean validationOk=false;

    @Column(name="header_sender_id", nullable=false) private String headerSenderId;
    @Column(name="header_receiver_id", nullable=false) private String headerReceiverId;
    @Column(name="header_transaction_date", nullable=false) private OffsetDateTime headerTransactionDate;
    @Column(name="header_record_count", nullable=false) private Integer headerRecordCount;
    @Column(name="header_disposition_flag", nullable=false) private String headerDispositionFlag;

    @Column(name="parsed_claims") private Integer parsedClaims=0;
    @Column(name="parsed_encounters") private Integer parsedEncounters=0;
    @Column(name="parsed_diagnoses") private Integer parsedDiagnoses=0;
    @Column(name="parsed_activities") private Integer parsedActivities=0;
    @Column(name="parsed_observations") private Integer parsedObservations=0;
    @Column(name="persisted_claims") private Integer persistedClaims=0;
    @Column(name="persisted_encounters") private Integer persistedEncounters=0;
    @Column(name="persisted_diagnoses") private Integer persistedDiagnoses=0;
    @Column(name="persisted_activities") private Integer persistedActivities=0;
    @Column(name="persisted_observations") private Integer persistedObservations=0;
    @Column(name="parsed_remit_claims") private Integer parsedRemitClaims=0;
    @Column(name="parsed_remit_activities") private Integer parsedRemitActivities=0;
    @Column(name="persisted_remit_claims") private Integer persistedRemitClaims=0;
    @Column(name="persisted_remit_activities") private Integer persistedRemitActivities=0;
    @Column(name="projected_events") private Integer projectedEvents=0;
    @Column(name="projected_status_rows") private Integer projectedStatusRows=0;

    @Column(name="verification_passed") private Boolean verificationPassed;
    @Column(name="verification_failed_count") private Integer verificationFailedCount=0;
    @Column(name="ack_attempted", nullable=false) private boolean ackAttempted=false;
    @Column(name="ack_sent", nullable=false) private boolean ackSent=false;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    // (omitted here for brevity—generate standard getters/setters matching fields)
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\IngestionRun.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/IngestionRun.java
// Version: v2.0.0
// Maps: claims.ingestion_run
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity @Table(name="ingestion_run", schema="claims")
public class IngestionRun {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @Column(name="started_at", nullable=false) private OffsetDateTime startedAt = OffsetDateTime.now();
    @Column(name="ended_at") private OffsetDateTime endedAt;
    @Column(name="profile", nullable=false) private String profile;
    @Column(name="fetcher_name", nullable=false) private String fetcherName;
    @Column(name="acker_name") private String ackerName;
    @Column(name="poll_reason") private String pollReason;
    @Column(name="files_discovered", nullable=false) private Integer filesDiscovered = 0;
    @Column(name="files_pulled", nullable=false) private Integer filesPulled = 0;
    @Column(name="files_processed_ok", nullable=false) private Integer filesProcessedOk = 0;
    @Column(name="files_failed", nullable=false) private Integer filesFailed = 0;
    @Column(name="files_already", nullable=false) private Integer filesAlready = 0;
    @Column(name="acks_sent", nullable=false) private Integer acksSent = 0;
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public OffsetDateTime getStartedAt(){return startedAt;} public void setStartedAt(OffsetDateTime v){this.startedAt=v;}
    public OffsetDateTime getEndedAt(){return endedAt;} public void setEndedAt(OffsetDateTime v){this.endedAt=v;}
    public String getProfile(){return profile;} public void setProfile(String v){this.profile=v;}
    public String getFetcherName(){return fetcherName;} public void setFetcherName(String v){this.fetcherName=v;}
    public String getAckerName(){return ackerName;} public void setAckerName(String v){this.ackerName=v;}
    public String getPollReason(){return pollReason;} public void setPollReason(String v){this.pollReason=v;}
    public Integer getFilesDiscovered(){return filesDiscovered;} public void setFilesDiscovered(Integer v){this.filesDiscovered=v;}
    public Integer getFilesPulled(){return filesPulled;} public void setFilesPulled(Integer v){this.filesPulled=v;}
    public Integer getFilesProcessedOk(){return filesProcessedOk;} public void setFilesProcessedOk(Integer v){this.filesProcessedOk=v;}
    public Integer getFilesFailed(){return filesFailed;} public void setFilesFailed(Integer v){this.filesFailed=v;}
    public Integer getFilesAlready(){return filesAlready;} public void setFilesAlready(Integer v){this.filesAlready=v;}
    public Integer getAcksSent(){return acksSent;} public void setAcksSent(Integer v){this.acksSent=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Observation.java =====

// FILE: src/main/java/com/acme/claims/domain/Observation.java
// Version: v2.0.0
// Maps: claims.observation
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.time.OffsetDateTime;

@Entity
@Table(name = "observation", schema = "claims",
        indexes = @Index(name = "idx_obs_activity", columnList = "activity_id"))
public class Observation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "activity_id", nullable = false)
    private Activity activity;
    @Column(name = "obs_type", nullable = false)
    private String obsType;
    @Column(name = "obs_code", nullable = false)
    private String obsCode;
    @Column(name = "value_text")
    private String valueText;
    @Column(name = "value_type")
    private String valueType;
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(name = "file_bytes")
    private byte[] fileBytes;

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Activity getActivity() {
        return activity;
    }

    public void setActivity(Activity v) {
        this.activity = v;
    }

    public String getObsType() {
        return obsType;
    }

    public void setObsType(String v) {
        this.obsType = v;
    }

    public String getObsCode() {
        return obsCode;
    }

    public void setObsCode(String v) {
        this.obsCode = v;
    }

    public String getValueText() {
        return valueText;
    }

    public void setValueText(String v) {
        this.valueText = v;
    }

    public String getValueType() {
        return valueType;
    }

    public void setValueType(String v) {
        this.valueType = v;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime v) {
        this.createdAt = v;
    }

    public byte[] getFileBytes() {
        return fileBytes;
    }

    public void setFileBytes(byte[] fileBytes) {
        this.fileBytes = fileBytes;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Remittance.java =====

// FILE: src/main/java/com/acme/claims/domain/Remittance.java
// Version: v2.0.0
// Maps: claims.remittance
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.time.OffsetDateTime;

@Entity
@Table(name = "remittance", schema = "claims",
        indexes = @Index(name = "idx_remittance_file", columnList = "ingestion_file_id"))
public class Remittance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ingestion_file_id", nullable = false)
    private IngestionFile ingestionFile;

    @Column(name = "tx_at", nullable = false, insertable = false, updatable = false)
    private OffsetDateTime txAt;

    // getters/setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public IngestionFile getIngestionFile() {
        return ingestionFile;
    }

    public void setIngestionFile(IngestionFile v) {
        this.ingestionFile = v;
    }

    public OffsetDateTime getTxAt() {
        return txAt;
    }

    public void setTxAt(OffsetDateTime txAt) {
        this.txAt = txAt;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\RemittanceActivity.java =====

// FILE: src/main/java/com/acme/claims/domain/RemittanceActivity.java
// Version: v2.0.0
// Maps: claims.remittance_activity
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.OffsetDateTime;

@Entity
@Table(name="remittance_activity", schema="claims",
        indexes=@Index(name="idx_remit_act_claim", columnList="remittance_claim_id"),
        uniqueConstraints=@UniqueConstraint(name="uq_remittance_activity", columnNames={"remittance_claim_id","activity_id"}))
public class RemittanceActivity {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="remittance_claim_id", nullable=false)
    private RemittanceClaim remittanceClaim;
    @Column(name="activity_id", nullable=false) private String activityId;
    @Column(name="start_at", nullable=false) private OffsetDateTime startAt;
    @Column(name="type", nullable=false) private String type;
    @Column(name="code", nullable=false) private String code;
    @Column(name="quantity", nullable=false, precision=14, scale=2) private BigDecimal quantity;
    @Column(name="net", nullable=false, precision=14, scale=2) private BigDecimal net;
    @Column(name="list_price", precision=14, scale=2) private BigDecimal listPrice;
    @Column(name="clinician", nullable=false) private String clinician;
    @Column(name="prior_authorization_id") private String priorAuthorizationId;
    @Column(name="gross", precision=14, scale=2) private BigDecimal gross;
    @Column(name="patient_share", precision=14, scale=2) private BigDecimal patientShare;
    @Column(name="payment_amount", nullable=false, precision=14, scale=2) private BigDecimal paymentAmount;
    @Column(name="denial_code") private String denialCode;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…
    public Long getId(){return id;} public void setId(Long id){this.id=id;}
    public RemittanceClaim getRemittanceClaim(){return remittanceClaim;}
    public void setRemittanceClaim(RemittanceClaim v){this.remittanceClaim=v;}
    public String getActivityId(){return activityId;} public void setActivityId(String v){this.activityId=v;}
    public OffsetDateTime getStartAt(){return startAt;} public void setStartAt(OffsetDateTime v){this.startAt=v;}
    public String getType(){return type;} public void setType(String v){this.type=v;}
    public String getCode(){return code;} public void setCode(String v){this.code=v;}
    public BigDecimal getQuantity(){return quantity;} public void setQuantity(BigDecimal v){this.quantity=v;}
    public BigDecimal getNet(){return net;} public void setNet(BigDecimal v){this.net=v;}
    public BigDecimal getListPrice(){return listPrice;} public void setListPrice(BigDecimal v){this.listPrice=v;}
    public String getClinician(){return clinician;} public void setClinician(String v){this.clinician=v;}
    public String getPriorAuthorizationId(){return priorAuthorizationId;} public void setPriorAuthorizationId(String v){this.priorAuthorizationId=v;}
    public BigDecimal getGross(){return gross;} public void setGross(BigDecimal v){this.gross=v;}
    public BigDecimal getPatientShare(){return patientShare;} public void setPatientShare(BigDecimal v){this.patientShare=v;}
    public BigDecimal getPaymentAmount(){return paymentAmount;} public void setPaymentAmount(BigDecimal v){this.paymentAmount=v;}
    public String getDenialCode(){return denialCode;} public void setDenialCode(String v){this.denialCode=v;}
    public OffsetDateTime getCreatedAt(){return createdAt;} public void setCreatedAt(OffsetDateTime v){this.createdAt=v;}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\RemittanceClaim.java =====

// FILE: src/main/java/com/acme/claims/domain/RemittanceClaim.java
// Version: v2.0.0
// Maps: claims.remittance_claim
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;

import java.time.OffsetDateTime;

@Entity
@Table(name = "remittance_claim", schema = "claims",
        uniqueConstraints = @UniqueConstraint(name = "uq_remittance_claim", columnNames = {"remittance_id", "claim_key_id"}),
        indexes = {@Index(name = "idx_remittance_claim_key", columnList = "claim_key_id"),
                @Index(name = "idx_remittance_claim_remit", columnList = "remittance_id")})
public class RemittanceClaim {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "remittance_id", nullable = false)
    private Remittance remittance;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "claim_key_id", nullable = false)
    private ClaimKey claimKey;
    @Column(name = "id_payer", nullable = false)
    private String idPayer;
    @Column(name = "provider_id")
    private String providerId;
    @Column(name = "denial_code")
    private String denialCode;
    @Column(name = "payment_reference", nullable = false)
    private String paymentReference;
    @Column(name = "date_settlement")
    private OffsetDateTime dateSettlement;
    @Column(name = "facility_id")
    private String facilityId; // Remittance Encounter/FacilityID (stored directly)
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt = OffsetDateTime.now();
    @Column(name = "denial_code_ref_id")
    private Long denialCodeRefId;
    @Column(name ="payer_ref_id")
    private Long payerRefId;
    @Column(name ="provider_ref_id")
    private Long providerRefId;

    // getters/setters…
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Remittance getRemittance() {
        return remittance;
    }

    public void setRemittance(Remittance v) {
        this.remittance = v;
    }

    public ClaimKey getClaimKey() {
        return claimKey;
    }

    public void setClaimKey(ClaimKey v) {
        this.claimKey = v;
    }

    public String getIdPayer() {
        return idPayer;
    }

    public void setIdPayer(String v) {
        this.idPayer = v;
    }

    public String getProviderId() {
        return providerId;
    }

    public void setProviderId(String v) {
        this.providerId = v;
    }

    public String getDenialCode() {
        return denialCode;
    }

    public void setDenialCode(String v) {
        this.denialCode = v;
    }

    public String getPaymentReference() {
        return paymentReference;
    }

    public void setPaymentReference(String v) {
        this.paymentReference = v;
    }

    public OffsetDateTime getDateSettlement() {
        return dateSettlement;
    }

    public void setDateSettlement(OffsetDateTime v) {
        this.dateSettlement = v;
    }

    public String getFacilityId() {
        return facilityId;
    }

    public void setFacilityId(String v) {
        this.facilityId = v;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime v) {
        this.createdAt = v;
    }

    public Long getDenialCodeRefId() {
        return denialCodeRefId;
    }

    public void setDenialCodeRefId(Long denialCodeRefId) {
        this.denialCodeRefId = denialCodeRefId;
    }

    public Long getPayerRefId() {
        return payerRefId;
    }

    public void setPayerRefId(Long payerRefId) {
        this.payerRefId = payerRefId;
    }

    public Long getProviderRefId() {
        return providerRefId;
    }

    public void setProviderRefId(Long providerRefId) {
        this.providerRefId = providerRefId;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\Submission.java =====

// FILE: src/main/java/com/acme/claims/domain/Submission.java
// Version: v2.0.0
// Maps: claims.submission
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.DynamicUpdate;

import java.time.OffsetDateTime;

@Entity
@Table(name = "submission", schema = "claims",
        indexes = @Index(name = "idx_submission_file", columnList = "ingestion_file_id"))
@DynamicUpdate
public class Submission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ingestion_file_id", nullable = false)
    private IngestionFile ingestionFile;
    @Column(name = "tx_at", nullable = false, insertable = false, updatable = false)
    private OffsetDateTime txAt;

    // getters/setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public IngestionFile getIngestionFile() {
        return ingestionFile;
    }

    public void setIngestionFile(IngestionFile v) {
        this.ingestionFile = v;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\VerificationResult.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/VerificationResult.java
// Version: v2.0.0
// Maps: claims.verification_result
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="verification_result", schema="claims",
        indexes=@Index(name="idx_ver_result_run", columnList="verification_run_id, rule_id"))
public class VerificationResult {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="verification_run_id", nullable=false)
    private VerificationRun verificationRun;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="rule_id", nullable=false)
    private VerificationRule rule;
    @Column(name="ok", nullable=false) private boolean ok;
    @Column(name="rows_affected") private Long rowsAffected;
    @Column(name="sample_json", columnDefinition="jsonb") private String sampleJson;
    @Column(name="message") private String message;
    @Column(name="executed_at", nullable=false) private OffsetDateTime executedAt = OffsetDateTime.now();
    // getters/setters…

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public VerificationRun getVerificationRun() {
        return verificationRun;
    }

    public void setVerificationRun(VerificationRun verificationRun) {
        this.verificationRun = verificationRun;
    }

    public VerificationRule getRule() {
        return rule;
    }

    public void setRule(VerificationRule rule) {
        this.rule = rule;
    }

    public boolean isOk() {
        return ok;
    }

    public void setOk(boolean ok) {
        this.ok = ok;
    }

    public Long getRowsAffected() {
        return rowsAffected;
    }

    public void setRowsAffected(Long rowsAffected) {
        this.rowsAffected = rowsAffected;
    }

    public String getSampleJson() {
        return sampleJson;
    }

    public void setSampleJson(String sampleJson) {
        this.sampleJson = sampleJson;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public OffsetDateTime getExecutedAt() {
        return executedAt;
    }

    public void setExecutedAt(OffsetDateTime executedAt) {
        this.executedAt = executedAt;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\VerificationRule.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/VerificationRule.java
// Version: v2.0.0
// Maps: claims.verification_rule
package com.acme.claims.domain.model.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="verification_rule", schema="claims",
        uniqueConstraints=@UniqueConstraint(name="verification_rule_code_key", columnNames="code"))
public class VerificationRule {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @Column(name="code", nullable=false) private String code;
    @Column(name="description", nullable=false) private String description;
    @Column(name="severity", nullable=false) private short severity; // 1/2/3
    @Column(name="sql_text", nullable=false, columnDefinition = "text") private String sqlText;
    @Column(name="active", nullable=false) private boolean active = true;
    @Column(name="created_at", nullable=false) private OffsetDateTime createdAt = OffsetDateTime.now();
    // getters/setters…


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public short getSeverity() {
        return severity;
    }

    public void setSeverity(short severity) {
        this.severity = severity;
    }

    public String getSqlText() {
        return sqlText;
    }

    public void setSqlText(String sqlText) {
        this.sqlText = sqlText;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(OffsetDateTime createdAt) {
        this.createdAt = createdAt;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\model\entity\VerificationRun.java =====

// FILE: src/main/java/com/acme/claims/monitoring/domain/VerificationRun.java
// Version: v2.0.0
// Maps: claims.verification_run
package com.acme.claims.domain.model.entity;


import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name="verification_run", schema="claims",
        indexes=@Index(name="idx_ver_run_file", columnList="ingestion_file_id"))
public class VerificationRun {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id;
    @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="ingestion_file_id", nullable=false)
    private IngestionFile ingestionFile;
    @Column(name="started_at", nullable=false) private OffsetDateTime startedAt = OffsetDateTime.now();
    @Column(name="ended_at") private OffsetDateTime endedAt;
    @Column(name="passed") private Boolean passed;
    @Column(name="failed_rules", nullable=false) private Integer failedRules=0;
    // getters/setters…

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public IngestionFile getIngestionFile() {
        return ingestionFile;
    }

    public void setIngestionFile(IngestionFile ingestionFile) {
        this.ingestionFile = ingestionFile;
    }

    public OffsetDateTime getStartedAt() {
        return startedAt;
    }

    public void setStartedAt(OffsetDateTime startedAt) {
        this.startedAt = startedAt;
    }

    public OffsetDateTime getEndedAt() {
        return endedAt;
    }

    public void setEndedAt(OffsetDateTime endedAt) {
        this.endedAt = endedAt;
    }

    public Boolean getPassed() {
        return passed;
    }

    public void setPassed(Boolean passed) {
        this.passed = passed;
    }

    public Integer getFailedRules() {
        return failedRules;
    }

    public void setFailedRules(Integer failedRules) {
        this.failedRules = failedRules;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ActivityRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ActivityRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.Activity;
import com.acme.claims.domain.model.entity.Claim;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ActivityRepository extends JpaRepository<Activity, Long> {
    List<Activity> findByClaim(Claim claim);
    Optional<Activity> findByClaimAndActivityId(Claim claim, String activityId); // uq_activity_bk
    boolean existsByClaimAndActivityId(Claim claim, String activityId);
    long countByClaim(Claim claim);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimAttachmentRepository.java =====

package com.acme.claims.domain.repo;

import com.acme.claims.domain.model.entity.ClaimAttachment;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ClaimAttachmentRepository extends JpaRepository<ClaimAttachment, Long> {
}




// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimContractRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimContractRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.Claim;
import com.acme.claims.domain.model.entity.ClaimContract;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClaimContractRepository extends JpaRepository<ClaimContract, Long> {
    Optional<ClaimContract> findByClaim(Claim claim);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimEventActivityRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimEventActivityRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.ClaimEvent;
import com.acme.claims.domain.model.entity.ClaimEventActivity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ClaimEventActivityRepository extends JpaRepository<ClaimEventActivity, Long> {
    List<ClaimEventActivity> findByClaimEvent(ClaimEvent event);
    Optional<ClaimEventActivity> findByClaimEventAndActivityIdAtEvent(ClaimEvent event, String activityIdAtEvent); // uq_cea_event_activity
    boolean existsByClaimEventAndActivityIdAtEvent(ClaimEvent event, String activityIdAtEvent);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimEventRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimEventRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.enums.ClaimEventType;
import com.acme.claims.domain.model.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface ClaimEventRepository extends JpaRepository<ClaimEvent, Long> {
    List<ClaimEvent> findByClaimKeyOrderByEventTimeAsc(ClaimKey claimKey);
    Optional<ClaimEvent> findByClaimKeyAndType(ClaimKey claimKey, ClaimEventType type); // unique for SUBMISSION
    List<ClaimEvent> findByTypeAndEventTimeBetween(ClaimEventType type, OffsetDateTime from, OffsetDateTime to);
    List<ClaimEvent> findByIngestionFile(IngestionFile ingestionFile);
    long countBySubmission(Submission submission);
    long countByRemittance(Remittance remittance);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimKeyRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimKeyRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;

import com.acme.claims.domain.model.entity.ClaimKey;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClaimKeyRepository extends JpaRepository<ClaimKey, Long> {
    Optional<ClaimKey> findByClaimId(String claimId);
    boolean existsByClaimId(String claimId);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;

import com.acme.claims.domain.model.entity.Claim;
import com.acme.claims.domain.model.entity.ClaimKey;
import com.acme.claims.domain.model.entity.Submission;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClaimRepository extends JpaRepository<Claim, Long> {
    Optional<Claim> findByClaimKey(ClaimKey claimKey);
    boolean existsByClaimKey(ClaimKey claimKey); // one submission per claim_key
    long countBySubmission(Submission submission);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimResubmissionRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimResubmissionRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.ClaimEvent;
import com.acme.claims.domain.model.entity.ClaimResubmission;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClaimResubmissionRepository extends JpaRepository<ClaimResubmission, Long> {
    Optional<ClaimResubmission> findByClaimEvent(ClaimEvent event); // 1:1
    boolean existsByClaimEvent(ClaimEvent event);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ClaimStatusTimelineRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ClaimStatusTimelineRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.enums.ClaimStatus;
import com.acme.claims.domain.model.entity.ClaimKey;
import com.acme.claims.domain.model.entity.ClaimStatusTimeline;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;

@Repository
public interface ClaimStatusTimelineRepository extends JpaRepository<ClaimStatusTimeline, Long> {
    List<ClaimStatusTimeline> findByClaimKeyAndStatusOrderByStatusTimeAsc(ClaimKey key, ClaimStatus status);
    List<ClaimStatusTimeline> findByStatusTimeBetween(OffsetDateTime from, OffsetDateTime to);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\DiagnosisRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/DiagnosisRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.Claim;
import com.acme.claims.domain.model.entity.Diagnosis;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface DiagnosisRepository extends JpaRepository<Diagnosis, Long> {
    List<Diagnosis> findByClaim(Claim claim);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\EncounterRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/EncounterRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.Claim;
import com.acme.claims.domain.model.entity.Encounter;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface EncounterRepository extends JpaRepository<Encounter, Long> {
    Optional<Encounter> findByClaim(Claim claim); // 0..1 per claim (submission XSD)
    long countByClaim(Claim claim);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\EventObservationRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/EventObservationRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.ClaimEventActivity;
import com.acme.claims.domain.model.entity.EventObservation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface EventObservationRepository extends JpaRepository<EventObservation, Long> {
    List<EventObservation> findByClaimEventActivity(ClaimEventActivity cea);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\FacilityDhpoConfigRepo.java =====

package com.acme.claims.domain.repo;

import com.acme.claims.domain.model.entity.FacilityDhpoConfig;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for claims.facility_dhpo_config.
 * Used by the DHPO fetch-orchestrator to enumerate active facilities
 * and by admin flows to manage facility entries.
 */
public interface FacilityDhpoConfigRepo extends JpaRepository<FacilityDhpoConfig, Long> {

    List<FacilityDhpoConfig> findByActiveTrue(); // all active facilities

    Optional<FacilityDhpoConfig> findByFacilityCodeAndActiveTrue(String facilityCode); // one active facility
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\IngestionBatchMetricRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/IngestionBatchMetricRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionBatchMetric;
import com.acme.claims.domain.model.entity.IngestionFile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface IngestionBatchMetricRepository extends JpaRepository<IngestionBatchMetric, Long> {
    List<IngestionBatchMetric> findByIngestionFileOrderByStageAscBatchNoAsc(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\IngestionErrorRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/IngestionErrorRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionError;
import com.acme.claims.domain.model.entity.IngestionFile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface IngestionErrorRepository extends JpaRepository<IngestionError, Long> {
    List<IngestionError> findByIngestionFileOrderByOccurredAtDesc(IngestionFile file);
    long countByIngestionFile(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\IngestionFileAuditRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/IngestionFileAuditRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.domain.model.entity.IngestionFileAudit;
import com.acme.claims.domain.model.entity.IngestionRun;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface IngestionFileAuditRepository extends JpaRepository<IngestionFileAudit, Long> {
    List<IngestionFileAudit> findByIngestionRunOrderByCreatedAtDesc(IngestionRun run);
    List<IngestionFileAudit> findByIngestionFile(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\IngestionFileRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/IngestionFileRepository.java
// Version: v2.0.0 (SSOT-aligned)
// Purpose: SSOT raw XML + XSD header lookups; idempotency by fileId
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionFile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface IngestionFileRepository extends JpaRepository<IngestionFile, Long> {
    Optional<IngestionFile> findByFileId(String fileId);
    boolean existsByFileId(String fileId);
    List<IngestionFile> findAllByRootTypeOrderByTransactionDateDesc(short rootType);
    List<IngestionFile> findAllByTransactionDateBetween(OffsetDateTime from, OffsetDateTime to);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\IngestionRunRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/IngestionRunRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionRun;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;

@Repository
public interface IngestionRunRepository extends JpaRepository<IngestionRun, Long> {
    List<IngestionRun> findByStartedAtBetweenOrderByStartedAtDesc(OffsetDateTime from, OffsetDateTime to);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\ObservationRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/ObservationRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.Activity;
import com.acme.claims.domain.model.entity.Observation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ObservationRepository extends JpaRepository<Observation, Long> {
    List<Observation> findByActivity(Activity activity);
    long countByActivity(Activity activity);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\RemittanceActivityRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/RemittanceActivityRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.RemittanceActivity;
import com.acme.claims.domain.model.entity.RemittanceClaim;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface RemittanceActivityRepository extends JpaRepository<RemittanceActivity, Long> {
    List<RemittanceActivity> findByRemittanceClaim(RemittanceClaim remittanceClaim);
    Optional<RemittanceActivity> findByRemittanceClaimAndActivityId(RemittanceClaim remittanceClaim, String activityId); // uq_remittance_activity
    boolean existsByRemittanceClaimAndActivityId(RemittanceClaim remittanceClaim, String activityId);
    long countByRemittanceClaim(RemittanceClaim remittanceClaim);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\RemittanceClaimRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/RemittanceClaimRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.ClaimKey;
import com.acme.claims.domain.model.entity.Remittance;
import com.acme.claims.domain.model.entity.RemittanceClaim;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RemittanceClaimRepository extends JpaRepository<RemittanceClaim, Long> {
    Optional<RemittanceClaim> findByRemittanceAndClaimKey(Remittance remittance, ClaimKey claimKey); // uq_remittance_claim
    boolean existsByRemittanceAndClaimKey(Remittance remittance, ClaimKey claimKey);
    long countByRemittance(Remittance remittance);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\RemittanceRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/RemittanceRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.domain.model.entity.Remittance;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RemittanceRepository extends JpaRepository<Remittance, Long> {
    List<Remittance> findByIngestionFile(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\SubmissionRepository.java =====

// FILE: src/main/java/com/acme/claims/domain/repo/SubmissionRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.domain.model.entity.Submission;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface SubmissionRepository extends JpaRepository<Submission, Long> {
    List<Submission> findByIngestionFile(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\VerificationResultRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/VerificationResultRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.VerificationResult;
import com.acme.claims.domain.model.entity.VerificationRule;
import com.acme.claims.domain.model.entity.VerificationRun;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface VerificationResultRepository extends JpaRepository<VerificationResult, Long> {
    List<VerificationResult> findByVerificationRun(VerificationRun run);
    Optional<VerificationResult> findByVerificationRunAndRule(VerificationRun run, VerificationRule rule);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\VerificationRuleRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/VerificationRuleRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.VerificationRule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface VerificationRuleRepository extends JpaRepository<VerificationRule, Long> {
    Optional<VerificationRule> findByCode(String code);
    List<VerificationRule> findByActiveTrueOrderBySeverityDesc();
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\domain\repo\VerificationRunRepository.java =====

// FILE: src/main/java/com/acme/claims/monitoring/repo/VerificationRunRepository.java
// Version: v2.0.0
package com.acme.claims.domain.repo;


import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.domain.model.entity.VerificationRun;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface VerificationRunRepository extends JpaRepository<VerificationRun, Long> {
    List<VerificationRun> findByIngestionFileOrderByStartedAtDesc(IngestionFile file);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\error\IngestionErrorRecorder.java =====

// FILE: src/main/java/com/acme/claims/ingestion/error/IngestionErrorRecorder.java
// Version: v1.0.0
package com.acme.claims.error;


import com.acme.claims.domain.model.entity.IngestionFile;

public interface IngestionErrorRecorder {
    void recordParseError(IngestionFile file, String objectType, String objectKey, String errorCode, String message, String stackExcerpt);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\error\IngestionErrorRecorderImpl.java =====

// FILE: src/main/java/com/acme/claims/ingestion/error/IngestionErrorRecorderImpl.java
// Version: v1.0.0
package com.acme.claims.error;


import com.acme.claims.domain.model.entity.IngestionError;
import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.domain.repo.IngestionErrorRepository;
import org.springframework.stereotype.Service;

@Service
public class IngestionErrorRecorderImpl implements IngestionErrorRecorder {
    private final IngestionErrorRepository repo;
    public IngestionErrorRecorderImpl(IngestionErrorRepository repo){ this.repo = repo; }

    @Override
    public void recordParseError(IngestionFile file, String objectType, String objectKey, String errorCode, String message, String stackExcerpt) {
        IngestionError e = new IngestionError();
        e.setIngestionFile(file);
        e.setStage("PARSE");                  // stage taxonomy
        e.setObjectType(objectType);          // e.g., "HEADER" | "CLAIM" | "ACTIVITY"
        e.setObjectKey(objectKey);            // e.g., claimId or activityId
        e.setErrorCode(errorCode);            // e.g., "XSD_MISSING_FIELD"
        e.setErrorMessage(message);
        e.setStackExcerpt(stackExcerpt);
        e.setRetryable(false);                // parse errors are not retryable
        repo.save(e);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\error\ParseException.java =====

// FILE: src/main/java/com/acme/claims/ingestion/error/ParseException.java
// Version: v1.0.0
package com.acme.claims.error;

public class ParseException extends RuntimeException {
    private final String code;
    private final String objectType;
    private final String objectKey;

    public ParseException(String code, String objectType, String objectKey, String message, Throwable cause) {
        super(message, cause);
        this.code = code; this.objectType = objectType; this.objectKey = objectKey;
    }
    public String getCode(){ return code; }
    public String getObjectType(){ return objectType; }
    public String getObjectKey(){ return objectKey; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\ack\Acker.java =====

package com.acme.claims.ingestion.ack;

public interface Acker {
    void maybeAck(String fileId, boolean success);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\ack\NoopAcker.java =====

package com.acme.claims.ingestion.ack;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("localfs")
@Slf4j
public class NoopAcker implements Acker {
    @Override
    public void maybeAck(String fileId, boolean success) {
        log.trace("Noop ACK (localfs) fileId={} success={}", fileId, success);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\ack\soap\SoapAckerAdapter.java =====

// src/main/java/com/acme/claims/ingestion/ack/soap/SoapAckerAdapter.java
package com.acme.claims.ingestion.ack.soap;

import com.acme.claims.ingestion.ack.Acker;
import com.acme.claims.soap.fetch.DhpoFileRegistry;
import com.acme.claims.soap.fetch.SetDownloadedHook;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

/**
 * Best-effort ACK: delegates to your SOAP gateway hook (SetDownloaded/SetTransactionDownloaded).
 * Only fires when success==true AND ack toggle enabled.
 */
@Slf4j
@Component
@Profile({"ingestion", "soap"})
@RequiredArgsConstructor
public class SoapAckerAdapter implements Acker {

    private final SetDownloadedHook setDownloadedHook;
    private final DhpoFileRegistry fileRegistry;

    @Value("${claims.ack.enabled:false}")
    private boolean ackEnabled;

    @Override
    public void maybeAck(String fileId, boolean success) {
        if (!ackEnabled) {
            log.debug("[SOAP] ACK disabled; skip fileId={}", fileId);
            return;
        }
        if (!success) {
            log.debug("[SOAP] Verify not green; skip ACK for fileId={}", fileId);
            return;
        }
        try {
            log.debug("[SOAP] ACK ? SetDownloaded for fileId={}", fileId);
            var facilityOpt = fileRegistry.facilityFor(fileId);
            if (facilityOpt.isEmpty()) {
                log.warn("[SOAP] ACK skipped: facility not found for fileId={}", fileId);
                return;
            }
            var facilityCode = facilityOpt.get();
            log.debug("[SOAP] ACK ? SetDownloaded facility={} fileId={}", facilityCode, fileId);
            // Method name per your class: maybeMarkDownloaded(facilityCode, fileId)
            setDownloadedHook.maybeMarkDownloaded(facilityCode, fileId);
            // best-effort cleanup
            fileRegistry.forget(fileId);
            log.debug("[SOAP] ACK success for fileId={}", fileId);

        } catch (Exception e) {
            log.warn("[SOAP] ACK failed for fileId={} : {}", fileId, e.toString());
        } finally {
            fileRegistry.forget(fileId);
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\ack\SoapAcker.java =====

/*
 * SSOT NOTICE — SOAP Acker (stub)
 * Profile: soap
 * Purpose: Best-effort SOAP ACK to DHPO (or equivalent) after success/failure.
 * Notes:
 *   - Guard actual calls behind claims.ingestion.ack.enabled=true.
 *   - Caller (Orchestrator) already handles try/catch and logs WARN if this fails.
 */
package com.acme.claims.ingestion.ack;

import com.acme.claims.ingestion.config.IngestionProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("soap-stub")
public class SoapAcker implements Acker {
    private static final Logger log = LoggerFactory.getLogger(SoapAcker.class);
    private final IngestionProperties props;

    public SoapAcker(IngestionProperties props) {
        this.props = props;
    }

    @Override
    public void maybeAck(String fileId, boolean success) {
        // TODO: Implement SOAP call to remote ACK endpoint (props.getSoap().getEndpoint(), creds).
        // Keep it best-effort; do not throw. // inline doc
        log.info("SOAP ACK (stub) fileId={} success={} endpoint={}", fileId, success,
                props.getSoap() != null ? props.getSoap().getEndpoint() : "<unset>");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\audit\ErrorLogger.java =====

/*
 * SSOT NOTICE — Error Logger
 * Purpose: Persist structured errors with reliable object scoping and IDs.
 * Policy: Claim-level errors MUST include `claim_id`; file-level errors include `file_id`.
 */
package com.acme.claims.ingestion.audit;


import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;


@Service
public class ErrorLogger {

    private final JdbcTemplate jdbc;

    public ErrorLogger(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    /** Log a claim-scoped error; claimId is required (use "UNKNOWN_CLAIM" only as a last resort). */ // inline doc
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void claimError(Long ingestionFileId, String stage, String claimId, String code, String message, boolean retryable) {
        String objectKey = (claimId == null || claimId.isBlank()) ? "UNKNOWN_CLAIM" : claimId;
        jdbc.update("""
      insert into claims.ingestion_error(ingestion_file_id, stage, object_type, object_key, error_code, error_message, retryable, occurred_at)
      values (?,?,?,?,?,?,?, now())
    """, ingestionFileId, stage, "CLAIM", objectKey, code, message, retryable);
    }

    /** Log a file-scoped error; object_key carries "FILE:<ingestionFileId>" marker. */ // inline doc
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void fileError(Long ingestionFileId, String stage, String code, String message, boolean retryable) {
        jdbc.update("""
      insert into claims.ingestion_error(ingestion_file_id, stage, object_type, object_key, error_code, error_message, retryable, occurred_at)
      values (?,?,?,?,?,?,?, now())
    """, ingestionFileId, stage, "FILE", "FILE:" + ingestionFileId, code, message, retryable);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\audit\IngestionAudit.java =====

package com.acme.claims.ingestion.audit;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

@Service
public class IngestionAudit {
    private final JdbcTemplate jdbc;
    public IngestionAudit(JdbcTemplate jdbc){ this.jdbc=jdbc; }

    public long startRun(String profile, String fetcher, String acker, String reason){
        jdbc.update("""
      insert into claims.ingestion_run(profile, fetcher_name, acker_name, poll_reason, started_at)
      values (?,?,?,?, now())
    """, profile, fetcher, acker, reason);
        return jdbc.queryForObject("select max(id) from claims.ingestion_run", Long.class);
    }
    public void endRun(long runId){ jdbc.update("update claims.ingestion_run set ended_at=now() where id=?", runId); }

    public void fileOk(long runId, long ingestionFileId, boolean verified, int parsedClaims, int persistedClaims, int parsedActs, int persistedActs){
        jdbc.update("""
      insert into claims.ingestion_file_audit(ingestion_run_id, ingestion_file_id, status, reason, validation_ok,
        header_sender_id, header_receiver_id, header_transaction_date, header_record_count, header_disposition_flag,
        parsed_claims, persisted_claims, parsed_activities, persisted_activities, verification_passed, created_at)
      select ?, id, 1, 'OK', true, sender_id, receiver_id, transaction_date, record_count_declared, disposition_flag,
             ?, ?, ?, ?, ?, now()
      from claims.ingestion_file where id=?
    """, runId, parsedClaims, persistedClaims, parsedActs, persistedActs, verified, ingestionFileId);
        jdbc.update("update claims.ingestion_run set files_processed_ok = files_processed_ok + 1 where id=?", runId);
    }

    public void fileAlready(long runId, long ingestionFileId){
        jdbc.update("""
      insert into claims.ingestion_file_audit(ingestion_run_id, ingestion_file_id, status, reason, validation_ok, created_at)
      values (?,?,0,'ALREADY',true,now())
    """, runId, ingestionFileId);
        jdbc.update("update claims.ingestion_run set files_already = files_already + 1 where id=?", runId);
    }

    public void fileFail(long runId, long ingestionFileId, String errorClass, String message){
        jdbc.update("""
      insert into claims.ingestion_file_audit(ingestion_run_id, ingestion_file_id, status, reason, error_class, error_message, created_at)
      values (?,?,2,'FAIL',?,?,now())
    """, runId, ingestionFileId, errorClass, message);
        jdbc.update("update claims.ingestion_run set files_failed = files_failed + 1 where id=?", runId);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\config\IngestionConfig.java =====

/*
 * SSOT NOTICE — Ingestion Config (Beans)
 * Roots handled: Claim.Submission, Remittance.Advice
 * Purpose: Provide shared beans for the pipeline (executor, queue) and enable scheduling.
 * Notes:
 *   - Thread pool is sized via properties.concurrency.parserWorkers.
 *   - Queue capacity is sized for burst scenarios (e.g., ~100 files/30 minutes).
 */
package com.acme.claims.ingestion.config;

import com.acme.claims.ingestion.fetch.WorkItem;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

@Configuration
@EnableScheduling // enables orchestrator @Scheduled poller
public class IngestionConfig {

    @Bean(name = "ingestionQueue")
    public BlockingQueue<WorkItem> ingestionQueue(IngestionProperties props) {
        // Bounded queue to apply backpressure if fetchers push faster than we can ingest. // inline doc
        return new ArrayBlockingQueue<>(props.getQueue().getCapacity());
    }

    @Bean(name = "ingestionExecutor")
    public TaskExecutor ingestionExecutor(IngestionProperties props) {
        // Dedicated thread pool for parsing/persisting without blocking scheduler threads. // inline doc
        ThreadPoolTaskExecutor ex = new ThreadPoolTaskExecutor();
        ex.setCorePoolSize(props.getConcurrency().getParserWorkers());
        ex.setMaxPoolSize(props.getConcurrency().getParserWorkers());
        ex.setQueueCapacity(props.getConcurrency().getParserWorkers());
        ex.setThreadNamePrefix("ingest-");
        ex.initialize();
        return ex;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\config\IngestionProperties.java =====

/*
 * SSOT NOTICE — Ingestion Properties (Config)
 * Roots: Claim.Submission, Remittance.Advice
 * Purpose: Strongly-typed configuration for ingestion. Single I/O switch (stageToDisk).
 * NOTE: Not a @Component (to avoid duplicate beans). It is registered via @EnableConfigurationProperties.
 */
package com.acme.claims.ingestion.config;

import org.springframework.boot.context.properties.ConfigurationProperties;


@ConfigurationProperties(prefix = "claims.ingestion")
public class IngestionProperties {

    // Mode/profile hint (informational) // inline doc
    private String mode = "localfs";

    // Single switch: if true ? stage/archive files on disk; false ? purely in memory // inline doc
    private boolean stageToDisk = false;

    private Poll poll = new Poll();
    private Queue queue = new Queue();
    private Concurrency concurrency = new Concurrency();
    private Batch batch = new Batch();
    private Tx tx = new Tx();
    private Ack ack = new Ack();
    private HashSensitive hashSensitive = new HashSensitive();
    private LocalFs localfs = new LocalFs();
    private Soap soap = new Soap();

    /* ===== nested groups ===== */

    public static class Poll {
        private long fixedDelayMs = 2000L;
        public long getFixedDelayMs() { return fixedDelayMs; }
        public void setFixedDelayMs(long v) { this.fixedDelayMs = v; }
    }
    public static class Queue {
        private int capacity = 256;
        public int getCapacity() { return capacity; }
        public void setCapacity(int v) { this.capacity = v; }
    }
    public static class Concurrency {
        private int parserWorkers = 8;
        public int getParserWorkers() { return parserWorkers; }
        public void setParserWorkers(int v) { this.parserWorkers = v; }
    }
    public static class Batch {
        private int size = 1000;
        private int maxTxnSeconds = 5;
        public int getSize() { return size; }
        public void setSize(int v) { this.size = v; }
        public int getMaxTxnSeconds() { return maxTxnSeconds; }
        public void setMaxTxnSeconds(int v) { this.maxTxnSeconds = v; }
    }
    public static class Tx {
        private boolean perFile = true;
        private boolean perChunk = false;
        public boolean isPerFile() { return perFile; }
        public void setPerFile(boolean v) { this.perFile = v; }
        public boolean isPerChunk() { return perChunk; }
        public void setPerChunk(boolean v) { this.perChunk = v; }
    }
    public static class Ack {
        private boolean enabled = false;
        public boolean isEnabled() { return enabled; }
        public void setEnabled(boolean v) { this.enabled = v; }
    }
    public static class HashSensitive {
        private boolean enabled = true;
        public boolean isEnabled() { return enabled; }
        public void setEnabled(boolean v) { this.enabled = v; }
    }
    public static class LocalFs {
        private String readyDir = "./data/ready";
        private String archiveOkDir = "./data/archive/ok";
        private String archiveFailDir = "./data/archive/fail";
        public String getReadyDir() { return readyDir; }
        public void setReadyDir(String v) { this.readyDir = v; }
        public String getArchiveOkDir() { return archiveOkDir; }
        public void setArchiveOkDir(String v) { this.archiveOkDir = v; }
        public String getArchiveFailDir() { return archiveFailDir; }
        public void setArchiveFailDir(String v) { this.archiveFailDir = v; }
    }
    public static class Soap {
        private String endpoint;
        private String username;
        private String password;
        public String getEndpoint() { return endpoint; }
        public void setEndpoint(String v) { this.endpoint = v; }
        public String getUsername() { return username; }
        public void setUsername(String v) { this.username = v; }
        public String getPassword() { return password; }
        public void setPassword(String v) { this.password = v; }
    }

    /* ===== top-level getters/setters ===== */
    public String getMode() { return mode; }
    public void setMode(String mode) { this.mode = mode; }
    public boolean isStageToDisk() { return stageToDisk; }
    public void setStageToDisk(boolean stageToDisk) { this.stageToDisk = stageToDisk; }
    public Poll getPoll() { return poll; }
    public void setPoll(Poll poll) { this.poll = poll; }
    public Queue getQueue() { return queue; }
    public void setQueue(Queue queue) { this.queue = queue; }
    public Concurrency getConcurrency() { return concurrency; }
    public void setConcurrency(Concurrency concurrency) { this.concurrency = concurrency; }
    public Batch getBatch() { return batch; }
    public void setBatch(Batch batch) { this.batch = batch; }
    public Tx getTx() { return tx; }
    public void setTx(Tx tx) { this.tx = tx; }
    public Ack getAck() { return ack; }
    public void setAck(Ack ack) { this.ack = ack; }
    public HashSensitive getHashSensitive() { return hashSensitive; }
    public void setHashSensitive(HashSensitive hashSensitive) { this.hashSensitive = hashSensitive; }
    public LocalFs getLocalfs() { return localfs; }
    public void setLocalfs(LocalFs localfs) { this.localfs = localfs; }
    public Soap getSoap() { return soap; }
    public void setSoap(Soap soap) { this.soap = soap; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\Fetcher.java =====

/*
 * SSOT NOTICE — Fetcher SPI
 * Roots handled: Claim.Submission, Remittance.Advice
 * Purpose: Abstraction for sources that supply XML files to the ingestion pipeline.
 * Notes:
 *   - Implementations push immutable WorkItem objects to the pipeline callback.
 *   - Exactly one Fetcher is active at a time via Spring profiles (localfs or soap).
 *   - The pipeline parses directly from WorkItem.xmlBytes (in-memory). No temp files required.
 */
package com.acme.claims.ingestion.fetch;

import java.util.function.Consumer;

public interface Fetcher {

    /**
     * Start streaming XML work items to the provided consumer. // inline doc
     * Implementations should be non-blocking (run their own watcher/loop threads). // inline doc
     */
    void start(Consumer<WorkItem> onReady);

    /** Temporarily stop producing new items (used for backpressure). */ // inline doc
    void pause();

    /** Resume producing items after a pause. */ // inline doc
    void resume();
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\LocalFsFetcher.java =====

/*
 * SSOT NOTICE — LocalFS Fetcher
 * Profile: localfs
 * Purpose: Watch a directory for *.xml and emit WorkItems with bytes in-memory.
 * Guarantees:
 *   - Initial sweep picks up existing files at startup.
 *   - WatchService listens for new files.
 *   - Backpressure-aware (pause/resume).
 */
package com.acme.claims.ingestion.fetch;

import com.acme.claims.ingestion.config.IngestionProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.function.Consumer;

@Component
@Profile("localfs")
public class LocalFsFetcher implements Fetcher {
    private static final Logger log = LoggerFactory.getLogger(LocalFsFetcher.class);

    private final IngestionProperties props;
    private volatile boolean paused = false;

    public LocalFsFetcher(IngestionProperties props) {
        this.props = props;
    }

    @Override
    public void start(Consumer<WorkItem> onReady) {
        final Path ready = Paths.get(props.getLocalfs().getReadyDir());
        try { Files.createDirectories(ready); }
        catch (IOException e) { log.error("Ready dir create failed: {}", ready, e); return; }

        Thread t = new Thread(() -> {
            try {
                // Initial sweep
                try (DirectoryStream<Path> ds = Files.newDirectoryStream(ready, "*.xml")) {
                    for (Path p : ds) emit(onReady, p);
                } catch (Exception e) {
                    log.warn("Initial sweep error: {}", e.getMessage());
                }

                // Watch loop
                try (WatchService ws = FileSystems.getDefault().newWatchService()) {
                    ready.register(ws, StandardWatchEventKinds.ENTRY_CREATE);
                    for (;;) {
                        if (paused) { Thread.sleep(150L); continue; }
                        WatchKey key = ws.take();
                        for (WatchEvent<?> ev : key.pollEvents()) {
                            if (ev.kind() == StandardWatchEventKinds.OVERFLOW) continue;
                            Path rel = (Path) ev.context();
                            Path file = ready.resolve(rel);
                            if (file.toString().toLowerCase().endsWith(".xml")) emit(onReady, file);
                        }
                        key.reset();
                    }
                }
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                log.error("LocalFS watch loop terminated: {}", e.getMessage(), e);
            }
        }, "fetch-localfs");

        t.setDaemon(true);
        t.start();
        log.info("LocalFsFetcher started; watching {}", ready);
    }

    private void emit(Consumer<WorkItem> onReady, Path file) {
        try {
            byte[] bytes = Files.readAllBytes(file);      // in-memory parse by pipeline
            String fileId = file.getFileName().toString();// stable id for idempotency/audit
            onReady.accept(new WorkItem(fileId, bytes, file, "localfs"));
        } catch (Exception e) {
            log.warn("Unreadable file {}: {}", file, e.toString());
        }
    }

    @Override public void pause() { this.paused = true; }
    @Override public void resume() { this.paused = false; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\soap\DhpoFetchInbox.java =====

// src/main/java/com/acme/claims/ingestion/fetch/soap/DhpoFetchInbox.java
package com.acme.claims.ingestion.fetch.soap;

import com.acme.claims.ingestion.fetch.WorkItem;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

@Component
@Profile({"ingestion","soap"})
public class DhpoFetchInbox {

    private final BlockingQueue<WorkItem> queue = new LinkedBlockingQueue<>(1024);

    /** Generic submit allowing explicit source/sourcePath. */
    public void submit(String fileId, byte[] xmlBytes, Path sourcePath, String source) {
        queue.offer(new WorkItem(fileId, xmlBytes, sourcePath, source));
    }

    /** Convenience for SOAP (sourcePath=null, source="soap"). */
    public void submitSoap(String fileId, byte[] xmlBytes) {
        submit(fileId, xmlBytes, null, "soap");
    }

    WorkItem takeInterruptibly() throws InterruptedException {
        return queue.take();
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\soap\SoapFetcherAdapter.java =====

// src/main/java/com/acme/claims/ingestion/fetch/soap/SoapFetcherAdapter.java
package com.acme.claims.ingestion.fetch.soap;

import com.acme.claims.ingestion.fetch.Fetcher;
import com.acme.claims.ingestion.fetch.WorkItem;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * Thin adapter that bridges DHPO downloads (via DhpoFetchInbox) to the generic Fetcher SPI.
 * Non-blocking: runs its own loop thread that forwards WorkItems to the pipeline.
 */
@Slf4j
@Component
@Profile({"ingestion","soap"})
@RequiredArgsConstructor
public class SoapFetcherAdapter implements Fetcher {

    private final DhpoFetchInbox inbox; // coordinator pushes into this
    private final AtomicBoolean paused = new AtomicBoolean(false);
    private final ExecutorService loop = Executors.newSingleThreadExecutor(r -> {
        Thread t = new Thread(r, "soap-fetch-loop");
        t.setDaemon(true);
        return t;
    });

    @Override
    public void start(Consumer<WorkItem> onReady) {
        log.debug("[SOAP] Fetcher adapter starting");
        loop.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    if (paused.get()) { Thread.sleep(200); continue; } // cheap pause
                    WorkItem wi = inbox.takeInterruptibly();          // blocks until item arrives
                    onReady.accept(wi);                                // push downstream
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                } catch (Throwable t) {
                    log.warn("[SOAP] Fetcher loop error: {}", t.toString());
                }
            }
        });
    }

    @Override public void pause()  { paused.set(true);  log.debug("[SOAP] Fetcher paused"); }
    @Override public void resume() { paused.set(false); log.debug("[SOAP] Fetcher resumed"); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\SoapFetcher.java =====

/*
 * SSOT NOTICE — SOAP Fetcher (stub)
 * Profile: soap
 * Purpose: Pull XML from DHPO (or similar), emit WorkItems with bytes in-memory.
 * Notes:
 *   - Only one fetcher active via profiles.
 *   - Implement backpressure via pause()/resume() if streaming in loops.
 */
package com.acme.claims.ingestion.fetch;

import com.acme.claims.ingestion.config.IngestionProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.function.Consumer;

@Component
@Profile("soap")
public class SoapFetcher implements Fetcher {
    private static final Logger log = LoggerFactory.getLogger(SoapFetcher.class);

    private final IngestionProperties props;
    private volatile boolean paused = false;

    public SoapFetcher(IngestionProperties props){ this.props = props; }

    @Override
    public void start(Consumer<WorkItem> onReady) {
        // TODO: Call SOAP endpoint (props.getSoap().getEndpoint()/creds), fetch payload bytes per message,
        // then emit: onReady.accept(new WorkItem(remoteMessageId, xmlBytes, null, "soap"));
        log.info("SoapFetcher started (stub) endpoint={}",
                props.getSoap()!=null ? props.getSoap().getEndpoint() : "<unset>");
    }

    @Override public void pause()  { this.paused = true;  }
    @Override public void resume() { this.paused = false; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\fetch\WorkItem.java =====

/*
 * SSOT NOTICE — Work Item (Ingestion Unit)
 * Purpose: Immutable unit of work representing one XML file (either fetched from disk or SOAP),
 *          processed in-memory by the pipeline.
 * Notes:
 *   - fileId: stable identifier (e.g., filename or remote message id) — used for idempotency and audit.
 *   - xmlBytes: the raw XML payload (we parse directly from memory; no temp file needed).
 *   - sourcePath: present only when LocalFS profile is used and stageToDisk=true (for archiving).
 *   - source: simple tag like "localfs" or "soap" for audit/metrics dimensions.
 */
package com.acme.claims.ingestion.fetch;

import java.nio.file.Path;

public record WorkItem(
        String fileId,   // business-stable id for the file; used to upsert ingestion_file and for ACK
        byte[] xmlBytes, // raw XML payload; parser reads from this directly (StAX over InputStream)
        Path sourcePath, // non-null only when coming from LocalFS and we plan to archive/move
        String source    // "localfs" or "soap" for tagging in logs/metrics
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\Orchestrator.java =====

/*
 * SSOT NOTICE — Orchestrator
 * Flow: Fetcher ? Queue ? Executor ? Pipeline ? VerifyService ? (optional ACK)
 * Fix: IngestionProperties is now a single bean (no @Component on the properties class).
 */
package com.acme.claims.ingestion;

import com.acme.claims.ingestion.ack.Acker;
import com.acme.claims.ingestion.config.IngestionProperties;
import com.acme.claims.ingestion.fetch.Fetcher;
import com.acme.claims.ingestion.fetch.WorkItem;
import com.acme.claims.ingestion.verify.VerifyService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.concurrent.BlockingQueue;

@Component
@Profile("ingestion")
public class Orchestrator {

    private static final Logger log = LoggerFactory.getLogger(Orchestrator.class);

    private final Fetcher fetcher;
    private final IngestionProperties props; // single bean now
    private final BlockingQueue<WorkItem> queue;
    private final TaskExecutor executor;
    private final Pipeline pipeline;
    private final VerifyService verifyService;
    private final Acker acker;


    public Orchestrator(@Qualifier("soapFetcherAdapter") Fetcher fetcher,
                        IngestionProperties props,
                        @Qualifier("ingestionQueue") BlockingQueue<WorkItem> queue,
                        @Qualifier("ingestionExecutor") TaskExecutor executor,
                        Pipeline pipeline,
                        VerifyService verifyService, @Qualifier("soapAckerAdapter") Acker acker) {
        this.fetcher = fetcher;
        this.props = props;
        this.queue = queue;
        this.executor = executor;
        this.pipeline = pipeline;
        this.verifyService = verifyService;
        this.acker = acker;
    }

    @EventListener(ApplicationReadyEvent.class)
    public void onReady() {
        log.info("Orchestrator starting — mode={}, stageToDisk={}, workers={}",
                props.getMode(), props.isStageToDisk(), props.getConcurrency().getParserWorkers());
        fetcher.start(this::enqueue);
    }

    private void enqueue(WorkItem wi) {
        if (!queue.offer(wi)) {
            log.debug("Queue full (size={}); pausing fetcher", queue.size());
            fetcher.pause();
        }
    }

    @Scheduled(initialDelayString = "0", fixedDelayString = "${claims.ingestion.poll.fixedDelayMs}")
    public void drain() {
        log.debug("Drain cycle start; queued={}", queue.size());
        int burst = Math.max(1, props.getConcurrency().getParserWorkers());
        int submitted = 0;
        while (submitted < burst) {
            WorkItem wi = queue.poll();
            if (wi == null) break;
            submitted++;
            executor.execute(() -> processOne(wi));
        }
        if (queue.remainingCapacity() > 0) fetcher.resume();
        log.debug("Drain cycle end; dispatched={}", submitted);
    }

    private void processOne(WorkItem wi) {
        boolean success = false;
        try {
            var result = pipeline.process(wi);
            boolean verified = verifyService.verifyFile(result.ingestionFileId());
            success = verified;
            log.info("INGEST OK fileId={} rootType={} parsed[claims={},acts={}] persisted[claims={},acts={}] verified={}",
                    wi.fileId(), result.rootType(), result.parsedClaims(), result.parsedActivities(),
                    result.persistedClaims(), result.persistedActivities(), verified);

        } catch (Exception ex) {
            log.error("INGEST FAIL fileId={} source={} : {}", wi.fileId(), wi.source(), ex.getMessage(), ex);
            success = false;
        } finally {
            if (props.getAck().isEnabled() && acker != null) {
                try {
                    acker.maybeAck(wi.fileId(), success);
                } catch (Exception ackEx) {
                    log.warn("ACK(success) failed fileId={}: {}", wi.fileId(), ackEx.getMessage());
                }
            }
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\ClaimXmlParserStax.java =====

package com.acme.claims.ingestion.parser;

import com.acme.claims.domain.model.dto.*;
import com.acme.claims.domain.model.entity.IngestionFile;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSResourceResolver;

import javax.xml.XMLConstants;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigDecimal;
import java.net.URL;
import java.security.MessageDigest;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * # ClaimXmlParserStax
 * StAX-based, hardened parser for **Claim.Submission** and **Remittance.Advice** roots.
 * <p>
 * Pipeline: Fetcher ? Parser ? DTO ? Validate ? Mapper ? Persist ? Events/Timeline ? Verify ? Audit
 * <ul>
 *   <li>Root sniffing guarantees only two legal roots.</li>
 *   <li>XSD validation is performed before parsing (with controlled tolerance for undeclared &lt;Attachment&gt; beneath &lt;Claim&gt;).</li>
 *   <li>Produces SubmissionDTO/RemittanceAdviceDTO graphs + ParseProblem stream + detached binary Attachments.</li>
 *   <li>Observability: records structured problems (line/column) via {@link ParserErrorWriter} immediately.</li>
 *   <li>Security: disables DTD/external entities; compiles XSDs with secure processing and classpath resolver.</li>
 * </ul>
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ClaimXmlParserStax implements StageParser {

    private final ParserErrorWriter errorWriter;

    // ----------------------------------------------------------------------
    // Config/feature toggles
    // ----------------------------------------------------------------------

    /**
     * @deprecated Toggle removed by policy: undeclared &lt;Attachment&gt; under &lt;Claim&gt; is always tolerated as WARNING and persisted if present.
     * Kept for backward property compatibility; value is ignored. // PATCH: deprecated, no longer used.
     */
    @Deprecated
    @Value("${claims.parser.allowNonSchemaAttachments:false}")
    private boolean allowNonSchemaAttachments; // tolerate <Attachment> under <Claim> in submissions (ignored)

    /** Max decoded bytes per single attachment payload (configurable). */
    @Value("${claims.parser.maxAttachmentBytes:33554432}") // 32MB
    private int maxAttachmentBytes;

    /** If true, stop on XSD errors; else continue with problems recorded. */
    @Value("${claims.parser.failOnXsdError:false}")
    private boolean failOnXsdError;

    /** Two legal roots. */
    private enum Root {SUBMISSION, REMITTANCE}

    // One secured, reusable XMLInputFactory
    private final XMLInputFactory xif = buildSafeXif();

    // XSDs under src/main/resources/xsd/
    private final Schema submissionSchema = compileSchema("/xsd/ClaimSubmission.xsd");
    private final Schema remittanceSchema = compileSchema("/xsd/RemittanceAdvice.xsd");

    // Accept common DHPO/ISO formats; normalize to OffsetDateTime
    private static final DateTimeFormatter F_DDMMYYYY_HHMM = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
    private static final DateTimeFormatter F_YMD_HMS = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final ZoneId DEFAULT_ZONE = ZoneId.systemDefault();

    /**
     * Construct a hardened {@link XMLInputFactory}:
     * <ul>
     *   <li>Disable DTDs and external entities (XXE safe).</li>
     *   <li>Coalesce character data for contiguous CHARACTERS/CDATA.</li>
     * </ul>
     */
    private static XMLInputFactory buildSafeXif() {
        XMLInputFactory f = XMLInputFactory.newFactory();
        f.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        f.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        f.setProperty(XMLInputFactory.IS_COALESCING, true);
        return f;
    }

    // === Public API =======================================================================

    /**
     * Parse a single {@link IngestionFile}:
     * <ol>
     *   <li>Open a resettable stream over the raw XML bytes.</li>
     *   <li>Sniff the root element to determine schema.</li>
     *   <li>Validate against the corresponding XSD (record errors/warnings).</li>
     *   <li>Parse into DTO graph; collect problems and optional attachments.</li>
     * </ol>
     *
     * @param file IngestionFile containing raw XML bytes and DB id
     * @return {@link ParseOutcome} with DTOs, problems, and detached attachments
     */
    @Override
    public ParseOutcome parse(IngestionFile file) throws Exception {
        Objects.requireNonNull(file, "IngestionFile");
        long fileId = Objects.requireNonNull(file.getId(), "ingestion_file.id required");
        log.info("parse : {}", fileId);

        Resettable is = openInput(file);                 // supports stageToDisk=true
        Root root = sniffRoot(is);
        is.reset();

        List<ParseProblem> problems = new ArrayList<>();
        boolean xsdFailed = !validateAgainstXsd(is, root, problems, fileId);
        log.info("xsdFailed  : {}", xsdFailed);
        is.reset();
        if (xsdFailed && failOnXsdError) {
            return new ParseOutcome(
                    root == Root.SUBMISSION ? ParseOutcome.RootType.SUBMISSION : ParseOutcome.RootType.REMITTANCE,
                    null, null, problems, List.of()
            );
        }
        log.info("Going to Parse XML : {}", fileId);
        return (root == Root.SUBMISSION)
                ? parseSubmission(is, fileId, problems)
                : parseRemittance(is, fileId, problems);
    }

    // === I/O & XSD ========================================================================

    /**
     * Open a resettable stream over the XML bytes. Throws for empty/null content.
     */
    private Resettable openInput(IngestionFile f) {
        byte[] bytes = f.getXmlBytes();
        if (bytes == null || bytes.length == 0) {
            throw new IllegalArgumentException("IngestionFile.xmlBytes is required and was empty/null (id=" + f.getId() + ")");
        }
        return new Resettable(new ByteArrayInputStream(bytes)); // single buffer reused for XSD + parse
    }

    /**
     * Compile an XSD from classpath with secure processing and a classpath resource resolver.
     */
    private Schema compileSchema(String classpathXsd) {
        try {
            URL url = Objects.requireNonNull(getClass().getResource(classpathXsd),
                    "Missing XSD on classpath: " + classpathXsd);
            SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            sf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
            sf.setResourceResolver(new ClasspathResourceResolver("/xsd/"));
            return sf.newSchema(url);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to compile XSD " + classpathXsd, e);
        }
    }

    /**
     * Sniff the XML root and ensure one of the two legal roots.
     */
    private Root sniffRoot(Resettable is) throws Exception {
        XMLStreamReader r = xif.createXMLStreamReader(is);
        try {
            while (r.hasNext()) {
                int ev = r.next();
                if (ev == XMLStreamConstants.START_ELEMENT) {
                    String local = r.getLocalName();
                    if ("Claim.Submission".equals(local)) return Root.SUBMISSION;
                    if ("Remittance.Advice".equals(local)) return Root.REMITTANCE;
                    throw new XMLStreamException("Unexpected root element: " + local, r.getLocation());
                }
            }
            throw new XMLStreamException("No root element found");
        } finally {
            try { r.close(); } catch (Exception ignore) {}
        }
    }

    /**
     * Validate against appropriate XSD.
     * <p><b>PATCH:</b> If validator error only mentions undeclared <code>Attachment</code>,
     * we always emit a WARNING and continue (toggle removed by policy).</p>
     *
     * @return true when no XSD ERROR (i.e., either OK or tolerated Attachment case)
     */
    private boolean validateAgainstXsd(Resettable is, Root root, List<ParseProblem> problems, long fileId) {
        try {
            Validator v = (root == Root.SUBMISSION ? submissionSchema : remittanceSchema).newValidator();
            v.validate(new javax.xml.transform.stream.StreamSource(is));
            log.info("Validated xsd");
            return true;
        } catch (Exception e) {
            log.info("Exception while validating XSD : {}", e);
            final String msg = (e.getMessage() == null) ? "XSD validation failed" : e.getMessage();
            // PATCH: Always tolerate undeclared <Attachment> under <Claim> and continue with WARNING.
            final boolean attachmentOnly = msg.contains("Attachment");
            final boolean commentsPresent = msg.contains("Comments");
            if (attachmentOnly || commentsPresent) {
                // do not fail xsd validation if comments or attachment are present
                return true;
            }
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR,
                    "XSD", "ROOT", root.name(), "XSD_INVALID", msg);
            return false;
        }
    }

    // === Submission =======================================================================

    /**
     * Parse a Claim.Submission root:
     * <ul>
     *   <li>Header ? {@link SubmissionHeaderDTO}</li>
     *   <li>Claims ? {@link SubmissionClaimDTO}</li>
     *   <li>Detached claim-level attachments emitted via {@link ParseOutcome.AttachmentRecord}</li>
     * </ul>
     */
    private ParseOutcome parseSubmission(Resettable is, long fileId, List<ParseProblem> problems) throws Exception {
        XMLStreamReader r = xif.createXMLStreamReader(is);
        try {
            SubmissionHeaderDTO header = null;
            List<SubmissionClaimDTO> claims = new ArrayList<>();
            List<ParseOutcome.AttachmentRecord> attachmentsOut = new ArrayList<>();
            int claimCount = 0;

            while (r.hasNext()) {
                int ev = r.next();

                if (ev == XMLStreamConstants.START_ELEMENT) {
                    switch (r.getLocalName()) {
                        case "Header" -> header = readSubmissionHeader(r, problems, fileId);
                        case "Claim" -> {
                            claimCount++;
                            var parsed = readSubmissionClaim(r, problems, fileId); // consumes until </Claim>
                            claims.add(parsed.claim());
                            if (!parsed.attachments().isEmpty()) attachmentsOut.addAll(parsed.attachments());
                        }
                    }
                }
            }

            if (header == null) addProblem(problems, fileId, null, ParseProblem.Severity.ERROR,
                    "VALIDATE", "Header", null, "HDR_MISSING", "Header element missing");
            if (header != null && header.recordCount() != claimCount)
                addProblem(problems, fileId, null, ParseProblem.Severity.WARNING,
                        "VALIDATE", "Header", null, "COUNT_MISMATCH",
                        "Header.RecordCount=" + header.recordCount() + " but body has " + claimCount);

            SubmissionDTO dto = new SubmissionDTO(header, claims);
            log.info("Successfully parsed Submission");
            return new ParseOutcome(ParseOutcome.RootType.SUBMISSION, dto, null, problems, attachmentsOut);
        } finally {
            try { r.close(); } catch (Exception ignore) {}
        }
    }

    /** Aggregates a parsed claim and any claim-level attachments discovered. */
    private record ParsedSubmissionClaim(SubmissionClaimDTO claim, List<ParseOutcome.AttachmentRecord> attachments) {}

    /**
     * Parse a single &lt;Claim&gt; in Submission, including:
     * scalars, optional Encounter (minOccurs=0), 1..* Diagnosis, 1..* Activity, optional Resubmission/Contract and non-schema Attachment.
     */
    private ParsedSubmissionClaim readSubmissionClaim(XMLStreamReader r, List<ParseProblem> problems, long fileId) throws Exception {
        String id = null, idPayer = null, memberId = null, payerId = null, providerId = null, emiratesId = null, comments = null;
        BigDecimal gross = null, patientShare = null, net = null;
        EncounterDTO enc = null;
        Set<DiagnosisDTO> dx = new HashSet<>();
        Set<ActivityDTO> acts = new HashSet<>();
        ResubmissionDTO res = null;
        ContractDTO contract = null;
        List<ParseOutcome.AttachmentRecord> attachments = new ArrayList<>();
        Set<String> activityIds = new HashSet<>();

        while (r.hasNext()) {
            int ev = r.next();

            if (ev == XMLStreamConstants.START_ELEMENT) {
                String el = r.getLocalName();

                switch (el) {
                    // ----- simple claim fields
                    case "ID" -> id = nn(readElementText(r));
                    case "IDPayer" -> idPayer = nn(readElementText(r));
                    case "MemberID" -> memberId = nn(readElementText(r));
                    case "PayerID" -> payerId = nn(readElementText(r));
                    case "ProviderID" -> providerId = nn(readElementText(r));
                    case "EmiratesIDNumber" -> emiratesId = nn(readElementText(r));
                    case "Gross" -> gross = parseDecimal(readElementText(r), "Gross", problems, fileId, r);
                    case "PatientShare" ->
                            patientShare = parseDecimal(readElementText(r), "PatientShare", problems, fileId, r);
                    case "Net" -> net = parseDecimal(readElementText(r), "Net", problems, fileId, r);

                    // ----- complex
                    case "Encounter" -> enc = readEncounter(r, problems, fileId, id);
                    case "Diagnosis" -> {
                        String t = nn(readChild(r, "Type"));
                        String c = nn(readChild(r, "Code"));
                        if (isBlank(t) || isBlank(c)) {
                            if (isBlank(t))
                                addProblem(problems, fileId, r, ParseProblem.Severity.ERROR, "PARSE", "Diagnosis", "Type", "REQ_MISSING", "Diagnosis/Type is required");
                            if (isBlank(c))
                                addProblem(problems, fileId, r, ParseProblem.Severity.ERROR, "PARSE", "Diagnosis", "Code", "REQ_MISSING", "Diagnosis/Code is required");
                        } else {
                            dx.add(new DiagnosisDTO(t, c));
                        }
                        skipToEnd(r, "Diagnosis");
                    }
                    case "Activity" -> {
                        var act = readSubmissionActivity(r, problems, fileId, activityIds, id);
                        if (act != null) acts.add(act);
                    }
                    case "Resubmission" -> {
                        String t = nn(readChild(r, "Type"));
                        String c = nn(readChild(r, "Comment"));
                        byte[] att = decodeBase64OrNull(readOptionalChild(r, "Attachment"), problems, fileId, "ResubmissionAttachment", id);
                        res = new ResubmissionDTO(t, c, att);
                        skipToEnd(r, "Resubmission");
                    }
                    case "Contract" -> {
                        String pkg = nn(readChild(r, "PackageName"));
                        contract = new ContractDTO(pkg);
                        skipToEnd(r, "Contract");
                    }

                    case "Comments" -> {
                        comments = nn(readChild(r, "Comments"));
                        skipToEnd(r, "Comments");
                    }

                    // ----- NON-SCHEMA Attachment (Submission only)
                    case "Attachment" -> {
                        String b64 = nn(readElementText(r));
                        if (isBlank(b64)) {
                            addProblem(problems, fileId, r, ParseProblem.Severity.WARNING,
                                    "PARSE", "Attachment", id, "ATTACH_EMPTY", "Attachment element is empty; skipping");
                        } else {
                            try {
                                byte[] bytes = java.util.Base64.getMimeDecoder().decode(b64);
                                if (bytes.length == 0) {
                                    addProblem(problems, fileId, r, ParseProblem.Severity.WARNING,
                                            "PARSE", "Attachment", id, "ATTACH_EMPTY", "Attachment decoded to 0 bytes; skipping");
                                } else if (bytes.length > maxAttachmentBytes) {
                                    // persistence will skip binary.
                                    addProblem(problems, fileId, r, ParseProblem.Severity.ERROR,
                                            "VALIDATE", "Attachment", id, "ATTACH_TOO_LARGE", "Attachment exceeds max allowed bytes: " + maxAttachmentBytes);
                                } else {
                                    byte[] sha = MessageDigest.getInstance("SHA-256").digest(bytes);
                                    attachments.add(new ParseOutcome.AttachmentRecord(
                                            id, null, null, null, bytes, sha, bytes.length
                                    ));
                                }
                            } catch (IllegalArgumentException ex) {
                                addProblem(problems, fileId, r, ParseProblem.Severity.WARNING,
                                        "PARSE", "Attachment", id, "ATTACH_INVALID_BASE64", "Invalid base64: " + ex.getMessage());
                            }
                        }
                    }
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Claim".equals(r.getLocalName())) {
                break;
            }
        }

        // Requires (beyond XSD) for observability; we still build the DTO
        // PATCH: Encounter is minOccurs=0 — at most WARNING when missing.
        //if (enc == null) addProblem(problems, fileId, null, ParseProblem.Severity.WARNING,
          //      "VALIDATE", "Encounter", id, "ENCOUNTER_MISSING", "Encounter is optional and was not supplied");

        if (dx.isEmpty()) addProblem(problems, fileId, null, ParseProblem.Severity.ERROR,
                "VALIDATE", "Diagnosis", id, "DIAGNOSIS_MISSING", "At least one Diagnosis required");
        if (acts.isEmpty()) addProblem(problems, fileId, null, ParseProblem.Severity.ERROR,
                "VALIDATE", "Activity", id, "ACTIVITY_MISSING", "At least one Activity required");

        // Claim required scalars
        if (isBlank(id))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "Claim", "ID", "REQ_MISSING", "Claim/ID is required");
        if (isBlank(payerId))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "Claim", "PayerID", "REQ_MISSING", "Claim/PayerID is required");
        if (isBlank(providerId))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "Claim", "ProviderID", "REQ_MISSING", "Claim/ProviderID is required");

        SubmissionClaimDTO claim = new SubmissionClaimDTO(
                id, idPayer, memberId, payerId, providerId, emiratesId,
                gross, patientShare, net, comments, enc, dx, acts, res, contract
        );

        return new ParsedSubmissionClaim(claim, attachments);
    }

    /**
     * Parse &lt;Encounter&gt; block in Submission (optional overall; columns within are required when present).
     * Empty encounter (no core fields) is treated as missing with a WARNING.
     */
    private EncounterDTO readEncounter(XMLStreamReader r, List<ParseProblem> problems, long fileId, String claimId) throws Exception {
        String facility = null, type = null, patientId = null, startType = null, endType = null, src = null, dst = null;
        OffsetDateTime start = null, end = null;

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "FacilityID" -> facility = nn(readElementText(r));
                    case "Type" -> type = nn(readElementText(r));
                    case "PatientID" -> patientId = nn(readElementText(r));
                    case "Start" -> start = parseTime(readElementText(r), "Encounter/Start", problems, fileId, r);
                    case "End" -> end = parseTime(readElementText(r), "Encounter/End", problems, fileId, r);
                    case "StartType" -> startType = nn(readElementText(r));
                    case "EndType" -> endType = nn(readElementText(r));
                    case "TransferSource" -> src = nn(readElementText(r));
                    case "TransferDestination" -> dst = nn(readElementText(r));
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Encounter".equals(r.getLocalName())) {
                break;
            }
        }

        boolean allEmpty = isBlank(facility) && isBlank(type) && isBlank(patientId) && start == null;
        if (allEmpty) {
            addProblem(problems, fileId, null, ParseProblem.Severity.WARNING, "VALIDATE", "Encounter", claimId,
                    "EMPTY_ELEMENT", "Encounter present but contains no data; treated as missing");
            return null;
        }
        return new EncounterDTO(facility, type, patientId, start, end, startType, endType, src, dst);
    }

    /**
     * Parse &lt;Activity&gt; in Submission (required fields; duplicates by ID are skipped with WARNING).
     * Required fields: ID, Start, Type, Code, Quantity, Net, Clinician (per DDL, minOccurs=1).
     * See DDL for NOT NULLs on activity, including Clinician. :contentReference[oaicite:0]{index=0}
     */
    private ActivityDTO readSubmissionActivity(XMLStreamReader r, List<ParseProblem> problems, long fileId, Set<String> seenIds, String claimId) throws Exception {
        String id = null, type = null, code = null, clinician = null, priorAuth = null;
        OffsetDateTime start = null;
        BigDecimal qty = null, net = null;
        Set<ObservationDTO> obs = new HashSet<>();

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "ID" -> id = nn(readElementText(r));
                    case "Start" -> start = parseTime(readElementText(r), "Activity/Start", problems, fileId, r);
                    case "Type" -> type = nn(readElementText(r));
                    case "Code" -> code = nn(readElementText(r));
                    case "Quantity" -> qty = parseDecimal(readElementText(r), "Activity/Quantity", problems, fileId, r);
                    case "Net" -> net = parseDecimal(readElementText(r), "Activity/Net", problems, fileId, r);
                    case "Clinician" -> clinician = nn(readElementText(r));
                    case "PriorAuthorizationID" -> priorAuth = nn(readElementText(r));
                    case "Observation" -> {
                        ObservationDTO o = readObservation(r, problems, fileId, claimId);
                        if (o != null) obs.add(o);
                    }
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Activity".equals(r.getLocalName())) {
                break;
            }
        }
        if (id != null && !seenIds.add(id)) {
            addProblem(problems, fileId, null, ParseProblem.Severity.WARNING, "VALIDATE", "Activity", id, "DUP_ACTIVITY",
                    "Duplicate Activity/ID within Claim; skipping duplicate");
            return null;
        }

        boolean coreMissing = isBlank(id) || isBlank(type) || isBlank(code) || start == null || qty == null || net == null || isBlank(clinician);
        if (coreMissing) {
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "VALIDATE", "Activity", id, "ACTIVITY_INVALID_CORE",
                    "Activity missing one or more required fields; it will be skipped");
            return null;
        }

        return new ActivityDTO(id, start, type, code, qty, net, clinician, priorAuth, obs);
    }

    /**
     * Parse &lt;Observation&gt; (0..*), requiring Type and Code. Value/ValueType optional.
     * Empty observation node is skipped with WARNING. DB de-dup is enforced downstream by unique index on (activity_id, obs_type, obs_code, md5(value_text)). :contentReference[oaicite:1]{index=1}
     */
    private ObservationDTO readObservation(XMLStreamReader r, List<ParseProblem> problems, long fileId, String claimId) throws Exception {
        String type = null, code = null, value = null, valueType = null;
        byte[] fileBytes = null;

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "Type" -> type = nn(readElementText(r));
                    case "Code" -> code = nn(readElementText(r));
                    case "Value" -> {
                        if("File".equalsIgnoreCase(type)) {
                            fileBytes = decodeBase64OrNull(readOptionalChild(r, "Value"), problems, fileId, "Observation Attachment", claimId);
                        } else {
                            value = nn(readElementText(r));
                        }
                    }
                    case "ValueType" -> valueType = nn(readElementText(r));
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Observation".equals(r.getLocalName())) {
                break;
            }
        }

        if (isBlank(type) && isBlank(code) && isBlank(value) && isBlank(valueType)) {
            addProblem(problems, fileId, null, ParseProblem.Severity.WARNING,
                    "VALIDATE", "Observation", null, "EMPTY_ELEMENT", "Observation present but contains no data; skipped");
            return null;
        }
        if (isBlank(type) || isBlank(code)) {
            if (isBlank(type))
                addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "Observation", "Type", "REQ_MISSING", "Observation/Type is required");
            if (isBlank(code))
                addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "Observation", "Code", "REQ_MISSING", "Observation/Code is required");
            return null;
        }
        return new ObservationDTO(type, code, value, valueType, fileBytes);
    }

    /**
     * Parse Submission &lt;Header&gt; (all scalars are required).
     */
    private SubmissionHeaderDTO readSubmissionHeader(XMLStreamReader r, List<ParseProblem> problems, long fileId) throws Exception {
        String sender = null, receiver = null, disp = null;
        OffsetDateTime tx = null;
        Integer rc = null;

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "SenderID" -> sender = nn(readElementText(r));
                    case "ReceiverID" -> receiver = nn(readElementText(r));
                    case "TransactionDate" ->
                            tx = parseTime(readElementText(r), "Header/TransactionDate", problems, fileId, r);
                    case "RecordCount" ->
                            rc = parseInteger(readElementText(r), "Header/RecordCount", problems, fileId, r);
                    case "DispositionFlag" -> disp = nn(readElementText(r));
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Header".equals(r.getLocalName())) break;
        }

        return new SubmissionHeaderDTO(sender, receiver, tx, rc == null ? 0 : rc, disp);
    }

    // === Remittance ======================================================================

    /**
     * Parse a Remittance.Advice root:
     * Header + Claim list (with Encounter/FacilityID if present) + Activities.
     */
    private ParseOutcome parseRemittance(Resettable is, long fileId, List<ParseProblem> problems) throws Exception {
        XMLStreamReader r = xif.createXMLStreamReader(is);
        try {
            RemittanceHeaderDTO header = null;
            List<RemittanceClaimDTO> claims = new ArrayList<>();
            int claimCount = 0;

            while (r.hasNext()) {
                int ev = r.next();

                if (ev == XMLStreamConstants.START_ELEMENT) {
                    switch (r.getLocalName()) {
                        case "Header" -> header = readRemittanceHeader(r, problems, fileId);
                        case "Claim" -> {
                            claimCount++;
                            claims.add(readRemittanceClaim(r, problems, fileId));
                        }
                    }
                }
            }

            if (header == null) addProblem(problems, fileId, null, ParseProblem.Severity.ERROR,
                    "VALIDATE", "Header", null, "HDR_MISSING", "Header element missing");

            if (header != null && header.recordCount() != claimCount)
                addProblem(problems, fileId, null, ParseProblem.Severity.WARNING,
                        "VALIDATE", "Header", null, "COUNT_MISMATCH",
                        "Header.RecordCount=" + header.recordCount() + " but body has " + claimCount);

            RemittanceAdviceDTO dto = new RemittanceAdviceDTO(header, claims);
            log.debug("Successfully parsed RemittanceAdvice");
            return new ParseOutcome(ParseOutcome.RootType.REMITTANCE, null, dto, problems, List.of());
        } finally {
            try { r.close(); } catch (Exception ignore) {}
        }
    }

    /**
     * Parse a single &lt;Claim&gt; inside Remittance. Required: ID, IDPayer, PaymentReference.
     * Encounter/FacilityID is read if present (stored on remittance_claim table per DDL). :contentReference[oaicite:2]{index=2}
     */
    private RemittanceClaimDTO readRemittanceClaim(XMLStreamReader r, List<ParseProblem> problems, long fileId) throws Exception {
        String id = null, idPayer = null, providerId = null, denialCode = null, paymentRef = null, facilityId = null;
        OffsetDateTime dateSettlement = null;
        List<RemittanceActivityDTO> acts = new ArrayList<>();
        Set<String> activityIds = new HashSet<>();

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "ID" -> id = nn(readElementText(r));
                    case "IDPayer" -> idPayer = nn(readElementText(r));
                    case "ProviderID" -> providerId = nn(readElementText(r));
                    case "DenialCode" -> denialCode = nn(readElementText(r));
                    case "PaymentReference" -> paymentRef = nn(readElementText(r));
                    case "DateSettlement" ->
                            dateSettlement = parseTime(readElementText(r), "Claim/DateSettlement", problems, fileId, r);
                    case "Encounter" -> {
                        facilityId = nn(readChild(r, "FacilityID"));
                        skipToEnd(r, "Encounter");
                    }
                    case "Activity" -> {
                        RemittanceActivityDTO a = readRemittanceActivity(r, problems, fileId, activityIds);
                        if (a != null) acts.add(a);
                    }
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Claim".equals(r.getLocalName())) {
                break;
            }
        }

        if (isBlank(id))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "RemittanceClaim", "ID", "REQ_MISSING", "Claim/ID is required");
        if (isBlank(idPayer))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "RemittanceClaim", "IDPayer", "REQ_MISSING", "Claim/IDPayer is required");
        if (isBlank(paymentRef))
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "PARSE", "RemittanceClaim", "PaymentReference", "REQ_MISSING", "PaymentReference is required");

        return new RemittanceClaimDTO(id, idPayer, providerId, denialCode, paymentRef, dateSettlement, facilityId, acts);
    }

    /**
     * Parse &lt;Activity&gt; inside Remittance. Required: ID, Start, Type, Code, Quantity, Net, PaymentAmount, Clinician (per DDL). :contentReference[oaicite:3]{index=3}
     * Duplicates by ID are skipped with WARNING.
     */
    private RemittanceActivityDTO readRemittanceActivity(XMLStreamReader r, List<ParseProblem> problems, long fileId, Set<String> seenIds) throws Exception {
        String id = null, type = null, code = null, clinician = null, priorAuth = null, denialCode = null;
        OffsetDateTime start = null;
        BigDecimal qty = null, net = null, list = null, gross = null, patientShare = null, pay = null;

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "ID" -> id = nn(readElementText(r));
                    case "Start" -> start = parseTime(readElementText(r), "Activity/Start", problems, fileId, r);
                    case "Type" -> type = nn(readElementText(r));
                    case "Code" -> code = nn(readElementText(r));
                    case "Quantity" -> qty = parseDecimal(readElementText(r), "Activity/Quantity", problems, fileId, r);
                    case "Net" -> net = parseDecimal(readElementText(r), "Activity/Net", problems, fileId, r);
                    case "List" -> list = parseDecimalNull(readElementText(r));
                    case "Clinician" -> clinician = nn(readElementText(r));
                    case "PriorAuthorizationID" -> priorAuth = nn(readElementText(r));
                    case "Gross" -> gross = parseDecimalNull(readElementText(r));
                    case "PatientShare" -> patientShare = parseDecimalNull(readElementText(r));
                    case "PaymentAmount" ->
                            pay = parseDecimal(readElementText(r), "Activity/PaymentAmount", problems, fileId, r);
                    case "DenialCode" -> denialCode = nn(readElementText(r));
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Activity".equals(r.getLocalName())) {
                break;
            }
        }

        if (id != null && !seenIds.add(id)) {
            addProblem(problems, fileId, null, ParseProblem.Severity.WARNING, "VALIDATE", "Activity", id, "DUP_ACTIVITY",
                    "Duplicate Activity/ID within Remittance Claim; skipping duplicate");
            return null;
        }


        boolean coreMissing = isBlank(id) || isBlank(type) || isBlank(code) || start == null || qty == null || net == null || pay == null || isBlank(clinician);
        if (coreMissing) {
            addProblem(problems, fileId, null, ParseProblem.Severity.ERROR, "VALIDATE", "Activity", id, "ACTIVITY_INVALID_CORE",
                    "Remittance Activity missing required fields; skipped");
            return null;
        }

        return new RemittanceActivityDTO(id, start, type, code, qty, net, list, clinician, priorAuth, gross, patientShare, pay, denialCode);
    }

    /**
     * Parse Remittance &lt;Header&gt; (all scalars required).
     */
    private RemittanceHeaderDTO readRemittanceHeader(XMLStreamReader r, List<ParseProblem> problems, long fileId) throws Exception {
        String sender = null, receiver = null, disp = null;
        OffsetDateTime tx = null;
        Integer rc = null;

        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                switch (r.getLocalName()) {
                    case "SenderID" -> sender = nn(readElementText(r));
                    case "ReceiverID" -> receiver = nn(readElementText(r));
                    case "TransactionDate" ->
                            tx = parseTime(readElementText(r), "Header/TransactionDate", problems, fileId, r);
                    case "RecordCount" ->
                            rc = parseInteger(readElementText(r), "Header/RecordCount", problems, fileId, r);
                    case "DispositionFlag" -> disp = nn(readElementText(r));
                }
            } else if (ev == XMLStreamConstants.END_ELEMENT && "Header".equals(r.getLocalName())) break;
        }

        return new RemittanceHeaderDTO(sender, receiver, tx, rc == null ? 0 : rc, disp);
    }

    // === Helpers =========================================================================

    /** Null/blank check helper. */
    private static boolean isBlank(String s) {
        return s == null || s.trim().isEmpty();
    }

    /** Trim to null helper. */
    private static String nn(String s) {
        return isBlank(s) ? null : s.trim();
    }

    /**
     * Record a structured {@link ParseProblem} and stream it to {@link ParserErrorWriter}.
     */
    private void addProblem(List<ParseProblem> list, long fileId, XMLStreamReader r,
                            ParseProblem.Severity sev,
                            String stage, String objType, String objKey, String code, String msg) {
        Integer line = (r != null && r.getLocation() != null) ? r.getLocation().getLineNumber() : null;
        Integer col = (r != null && r.getLocation() != null) ? r.getLocation().getColumnNumber() : null;
        ParseProblem p = new ParseProblem(sev, stage, objType, objKey, code, msg, line, col);
        list.add(p);
        errorWriter.write(fileId, p); // persist immediately
    }

    /**
     * Read text content for current START_ELEMENT until END_ELEMENT (merging CHARACTERS/CDATA).
     */
    private String readElementText(XMLStreamReader r) throws Exception {
        StringBuilder sb = new StringBuilder();
        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.CHARACTERS || ev == XMLStreamConstants.CDATA) sb.append(r.getText());
            else if (ev == XMLStreamConstants.END_ELEMENT) break;
        }
        return sb.toString().trim();
    }

    /**
     * Read the first occurrence of a named child element's text within the current parent.
     * Caller remains responsible for consuming the parent end-tag.
     */
    private String readChild(XMLStreamReader r, String childLocalName) throws Exception {
        String val = null;
        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT && childLocalName.equals(r.getLocalName())) {
                val = readElementText(r);
            } else if (ev == XMLStreamConstants.END_ELEMENT && childLocalName.equals(r.getLocalName())) {
                // do nothing; common exit handled by caller
            } else if (ev == XMLStreamConstants.END_ELEMENT && !"Observation".equals(childLocalName) && !"Attachment".equals(childLocalName)) {
                // let caller manage outer end
            }
            if (val != null) break;
        }
        return val;
    }

    /**
     * Read a named optional child element (scans depth until parent closes); returns first match or null.
     */
    private String readOptionalChild(XMLStreamReader r, String childLocalName) throws Exception {
        String val = null;
        int depth = 1; // parent is already started
        while (r.hasNext() && depth > 0) {
            int ev = r.next();
            if (ev == XMLStreamConstants.START_ELEMENT) {
                depth++;
                if (childLocalName.equals(r.getLocalName())) val = readElementText(r);
            } else if (ev == XMLStreamConstants.END_ELEMENT) {
                depth--;
            }
            if (val != null) break;
        }
        return val;
    }

    /**
     * Skip tokens until END_ELEMENT for the given local name is seen.
     */
    private void skipToEnd(XMLStreamReader r, String localName) throws Exception {
        while (r.hasNext()) {
            int ev = r.next();
            if (ev == XMLStreamConstants.END_ELEMENT && localName.equals(r.getLocalName())) break;
        }
    }

    /**
     * Parse integer; on failure, record ERROR and return null.
     */
    private Integer parseInteger(String raw, String field, List<ParseProblem> problems, long fileId, XMLStreamReader r) {
        try {
            return raw == null ? null : Integer.valueOf(raw.trim());
        } catch (Exception e) {
            addProblem(problems, fileId, r, ParseProblem.Severity.ERROR, "PARSE", "Int", field, "BAD_INT", "Invalid integer for " + field + ": " + raw);
            return null;
        }
    }

    /**
     * Parse decimal; on failure, record ERROR and return null.
     */
    private BigDecimal parseDecimal(String raw, String field, List<ParseProblem> problems, long fileId, XMLStreamReader r) {
        try {
            return raw == null ? null : new BigDecimal(raw.trim());
        } catch (Exception e) {
            addProblem(problems, fileId, r, ParseProblem.Severity.ERROR, "PARSE", "Dec", field, "BAD_DEC", "Invalid decimal for " + field + ": " + raw);
            return null;
        }
    }

    /**
     * Parse decimal returning null on blank/invalid (used for optional numeric fields).
     */
    private BigDecimal parseDecimalNull(String raw) {
        try {
            return (raw == null || raw.isBlank()) ? null : new BigDecimal(raw.trim());
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Parse datetime from multiple common formats into OffsetDateTime; record ERROR on failure.
     */
    private OffsetDateTime parseTime(String raw, String field, List<ParseProblem> problems, long fileId, XMLStreamReader r) {
        if (raw == null || raw.isBlank()) return null;
        String s = raw.trim();

        try { return LocalDateTime.parse(s, F_DDMMYYYY_HHMM).atZone(DEFAULT_ZONE).toOffsetDateTime(); }
        catch (DateTimeParseException ignore) { }

        try { return LocalDateTime.parse(s, DateTimeFormatter.ISO_LOCAL_DATE_TIME).atZone(DEFAULT_ZONE).toOffsetDateTime(); }
        catch (DateTimeParseException ignore) { }

        try { return OffsetDateTime.parse(s, DateTimeFormatter.ISO_OFFSET_DATE_TIME); }
        catch (DateTimeParseException ignore) { }

        try { return LocalDateTime.parse(s, F_YMD_HMS).atZone(DEFAULT_ZONE).toOffsetDateTime(); }
        catch (DateTimeParseException ignore) { }

        addProblem(problems, fileId, r, ParseProblem.Severity.ERROR, "PARSE", "Time", field, "BAD_TIME", "Invalid datetime for " + field + ": " + raw);
        return null;
    }

    /**
     * Decode base64 or return null on blank/invalid.
     * <p><b>PATCH:</b> invalid base64 is now a WARNING (best-effort; claim stays persistable).</p>
     */
    private byte[] decodeBase64OrNull(String raw, List<ParseProblem> problems, long fileId, String code, String claimId) {
        if (raw == null || raw.isBlank()) return null;
        try {
            byte[] bytes = java.util.Base64.getMimeDecoder().decode(raw);
            return bytes.length == 0 ? null : bytes;
        } catch (IllegalArgumentException e) {
            addProblem(problems, fileId, null, ParseProblem.Severity.WARNING, "PARSE", "Attachment", claimId, code, "Invalid base64: " + e.getMessage());
            return null;
        }
    }

    // Resettable wrapper so we can reuse bytes for XSD + parse
    private static final class Resettable extends InputStream {
        private final ByteArrayInputStream d;

        Resettable(ByteArrayInputStream d) {
            this.d = d;
            this.d.mark(Integer.MAX_VALUE);
        }

        @Override public int read() { return d.read(); }
        @Override public int read(byte[] b) { return d.read(b, 0, b.length); }
        @Override public int read(byte[] b, int off, int len) { return d.read(b, off, len); }
        @Override public synchronized void reset() { d.reset(); }
        @Override public void close() { try { d.close(); } catch (Exception ignore) {} }
    }

    /**
     * Resolves XSD imports/includes from classpath (e.g., /xsd/CommonTypes.xsd).
     */
    private static final class ClasspathResourceResolver implements LSResourceResolver {
        private final String base; // e.g. "/xsd/"

        ClasspathResourceResolver(String base) {
            this.base = base.endsWith("/") ? base : base + "/";
        }

        @Override
        public LSInput resolveResource(String type, String ns, String publicId, String systemId, String baseURI) {
            InputStream is = open(systemId);
            if (is == null && systemId != null) {
                int i = systemId.lastIndexOf('/');
                if (i >= 0 && i + 1 < systemId.length()) is = open(systemId.substring(i + 1));
            }
            return (is == null) ? null : new SimpleLsInput(publicId, systemId, is);
        }

        private InputStream open(String name) {
            if (name == null || name.isBlank()) return null;
            String path = name.startsWith("/") ? name : base + name;
            return getClass().getResourceAsStream(path);
        }

        private static final class SimpleLsInput implements LSInput {
            private final String publicId, systemId;
            private final InputStream in;

            SimpleLsInput(String publicId, String systemId, InputStream in) {
                this.publicId = publicId;
                this.systemId = systemId;
                this.in = in;
            }

            @Override public java.io.Reader getCharacterStream() { return null; }
            @Override public void setCharacterStream(java.io.Reader r) {}
            @Override public InputStream getByteStream() { return in; }
            @Override public void setByteStream(InputStream byteStream) {}
            @Override public String getStringData() { return null; }
            @Override public void setStringData(String stringData) {}
            @Override public String getSystemId() { return systemId; }
            @Override public void setSystemId(String systemId) {}
            @Override public String getPublicId() { return publicId; }
            @Override public void setPublicId(String publicId) {}
            @Override public String getBaseURI() { return null; }
            @Override public void setBaseURI(String baseURI) {}
            @Override public String getEncoding() { return null; }
            @Override public void setEncoding(String encoding) {}
            @Override public boolean getCertifiedText() { return false; }
            @Override public void setCertifiedText(boolean certifiedText) {}
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\ClasspathResourceResolver.java =====

package com.acme.claims.ingestion.parser;

import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSResourceResolver;

import java.io.InputStream;

final class ClasspathResourceResolver implements LSResourceResolver {

    private final String base; // e.g. "/xsd/"

    ClasspathResourceResolver(String base) {
        this.base = base.endsWith("/") ? base : base + "/";
    }

    @Override
    public LSInput resolveResource(String type, String ns, String publicId, String systemId, String baseURI) {
        InputStream is = open(systemId);
        if (is == null && systemId != null) {
            int i = systemId.lastIndexOf('/');
            if (i >= 0 && i + 1 < systemId.length()) is = open(systemId.substring(i + 1));
        }
        return is == null ? null : new SimpleLSInput(publicId, systemId, is);
    }

    private InputStream open(String name) {
        if (name == null || name.isBlank()) return null;
        String path = name.startsWith("/") ? name : base + name;
        return getClass().getResourceAsStream(path);
    }

    private static final class SimpleLSInput implements LSInput {
        private final String publicId, systemId;
        private final InputStream in;
        SimpleLSInput(String publicId, String systemId, InputStream in) {
            this.publicId = publicId; this.systemId = systemId; this.in = in;
        }
        @Override public java.io.Reader getCharacterStream() { return null; }
        @Override public void setCharacterStream(java.io.Reader r) { }
        @Override public InputStream getByteStream() { return in; }
        @Override public void setByteStream(InputStream byteStream) { }
        @Override public String getStringData() { return null; }
        @Override public void setStringData(String stringData) { }
        @Override public String getSystemId() { return systemId; }
        @Override public void setSystemId(String systemId) { }
        @Override public String getPublicId() { return publicId; }
        @Override public void setPublicId(String publicId) { }
        @Override public String getBaseURI() { return null; }
        @Override public void setBaseURI(String baseURI) { }
        @Override public String getEncoding() { return null; }
        @Override public void setEncoding(String encoding) { }
        @Override public boolean getCertifiedText() { return false; }
        @Override public void setCertifiedText(boolean certifiedText) { }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\JdbcParserErrorWriter.java =====

// file: src/main/java/com/acme/claims/ingestion/parser/JdbcParserErrorWriter.java
package com.acme.claims.ingestion.parser;

import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
public class JdbcParserErrorWriter implements ParserErrorWriter {
    private final JdbcTemplate jdbc;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void write(long fileId, ParseProblem p) {
        jdbc.update("""
                        INSERT INTO claims.ingestion_error(ingestion_file_id, stage, object_type, object_key, error_code, error_message, retryable)
                        VALUES (?,?,?,?,?,?,false)
                        """,
                fileId, p.stage(), p.objectType(), p.objectKey(), p.code(), p.message()
        );
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\ParseOutcome.java =====

package com.acme.claims.ingestion.parser;


import com.acme.claims.domain.model.dto.RemittanceAdviceDTO;
import com.acme.claims.domain.model.dto.SubmissionDTO;

import java.util.List;

public final class ParseOutcome {
    public enum RootType { SUBMISSION, REMITTANCE }

    private final RootType rootType;
    private final SubmissionDTO submission;                 // non-null when SUBMISSION
    private final RemittanceAdviceDTO remittance;           // non-null when REMITTANCE
    private final List<ParseProblem> problems;
    private final List<AttachmentRecord> attachments;       // per-claim attachments (submission only)

    public ParseOutcome(RootType t, SubmissionDTO s, RemittanceAdviceDTO r,
                        List<ParseProblem> p, List<AttachmentRecord> a) {
        this.rootType = t; this.submission = s; this.remittance = r; this.problems = p; this.attachments = a;
    }

    public RootType getRootType() { return rootType; }
    public SubmissionDTO getSubmission() { return submission; }
    public RemittanceAdviceDTO getRemittance() { return remittance; }
    public List<ParseProblem> getProblems() { return problems; }
    public List<AttachmentRecord> getAttachments() { return attachments; }
    public boolean isValid() {
        return problems.stream().noneMatch(pp -> pp.severity() == ParseProblem.Severity.ERROR);
    }

    // Side-channel attachment info for PersistService
    public static record AttachmentRecord(
            String claimId, String externalId, String fileName, String contentType,
            byte[] bytes, byte[] sha256, int size
    ) {}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\ParseProblem.java =====

package com.acme.claims.ingestion.parser;

public record ParseProblem(
        Severity severity, String stage, String objectType, String objectKey,
        String code, String message, Integer line, Integer column
) {
    public enum Severity { INFO, WARNING, ERROR }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\ParserErrorWriter.java =====

package com.acme.claims.ingestion.parser;

public interface ParserErrorWriter {
    void write(long ingestionFileId, ParseProblem p);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\parser\StageParser.java =====

package com.acme.claims.ingestion.parser;


import com.acme.claims.domain.model.entity.IngestionFile;

public interface StageParser {
    ParseOutcome parse(IngestionFile file) throws Exception; // XSD + StAX + error recording per stage
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\persist\PersistService.java =====

package com.acme.claims.ingestion.persist;

import com.acme.claims.domain.model.dto.*;
import com.acme.claims.ingestion.audit.ErrorLogger;
import com.acme.claims.ingestion.parser.ParseOutcome;
import com.acme.claims.refdata.RefCodeResolver;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Set;

@Slf4j
@Service
@RequiredArgsConstructor
public class PersistService {

    private final JdbcTemplate jdbc;
    private final ErrorLogger errors;
    private final RefCodeResolver refCodeResolver;

    /* ========================= SUBMISSION PATH ========================= */

    /**
     * Back-compat overload if a caller doesn’t pass attachments.
     */
    @Transactional
    public PersistCounts persistSubmission(long ingestionFileId, SubmissionDTO file) {
        return persistSubmission(ingestionFileId, file, List.of());
    }

    /**
     * Persist a parsed submission file (with optional attachments collected by the parser).
     * Guards ensure we never violate NOT NULL/UNIQUES. Bad rows are logged+skipped, not thrown.
     */
    @Transactional
    public PersistCounts persistSubmission(long ingestionFileId, SubmissionDTO file, List<ParseOutcome.AttachmentRecord> attachments) {
        final OffsetDateTime now = OffsetDateTime.now();

        final Long submissionId = jdbc.queryForObject(
                "insert into claims.submission(ingestion_file_id) values (?) returning id",
                Long.class, ingestionFileId
        );

        int claims = 0, acts = 0, obs = 0, dxs = 0;
        int skippedDup = 0, skippedInvalidClaim = 0;

        for (SubmissionClaimDTO c : file.claims()) {
            final String claimIdBiz = c.id();
            try {
                // hard guard at claim level (before any DB writes)
                if (!claimHasRequired(ingestionFileId, c)) {
                    skippedInvalidClaim++;
                    continue; // skip this claim entirely; logged above
                }

                // Duplicate prior SUBMISSION and current has no <Resubmission> ? skip & log
                if (isAlreadySubmitted(claimIdBiz) && c.resubmission() == null) {
                    log.info("Claim already submitted : {}", claimIdBiz);
                    errors.claimError(ingestionFileId, "VALIDATE", claimIdBiz, "DUP_SUBMISSION_NO_RESUB",
                            "Duplicate Claim.Submission without <Resubmission>; skipped.", false);
                    skippedDup++;
                    continue;
                }

                // Upsert core graph
                final long claimKeyId = upsertClaimKey(claimIdBiz);

                // resolve ref IDs (inserting into ref tables + auditing if missing)
                final Long payerRefId = (c.payerId() == null) ? null
                        : refCodeResolver.resolvePayer(c.payerId(), null, "SYSTEM", ingestionFileId, c.id()).orElse(null);
                final Long providerRefId = (c.providerId() == null) ? null
                        : refCodeResolver.resolveProvider(c.providerId(), null, "SYSTEM", ingestionFileId, c.id()).orElse(null);

                final long claimId = upsertClaim(claimKeyId, submissionId, c, payerRefId, providerRefId); // PATCH: new params


                // Encounter (optional, but has NOT NULL cols in DDL)
                if (c.encounter() != null && encounterHasRequired(ingestionFileId, claimIdBiz, c.encounter())) {
                    // PATCH: resolve facility ref id
                    final Long facilityRefId = (c.encounter().facilityId() == null) ? null
                            : refCodeResolver.resolveFacility(c.encounter().facilityId(), null, null, null, "SYSTEM", ingestionFileId, c.id())
                            .orElse(null);
                    upsertEncounter(claimId, c.encounter(), facilityRefId); // PATCH: pass ref id
                }

                // Diagnoses (optional)
                if (c.diagnoses() != null) {
                    for (DiagnosisDTO d : c.diagnoses()) {
                        if (diagnosisHasRequired(ingestionFileId, claimIdBiz, d)) {
                            // PATCH: resolve diagnosis ref id
                            final Long diagnosisRefId = (d.code() == null) ? null
                                    : refCodeResolver.resolveDiagnosisCode(d.code(), null, null, "SYSTEM", ingestionFileId, c.id()).orElse(null);
                            upsertDiagnosis(claimId, d, diagnosisRefId); // PATCH
                            dxs++;

                        }
                    }
                }

                // Activities (optional)
                if (c.activities() != null) {
                    for (ActivityDTO a : c.activities()) {
                        if (!activityHasRequired(ingestionFileId, claimIdBiz, a)) continue; // logged+skip
                        // resolve activity/clinician refs
                        final Long activityCodeRefId = (a.code() == null) ? null
                                : refCodeResolver.resolveActivityCode(a.code(), null, null, "SYSTEM", ingestionFileId, c.id()).orElse(null);
                        final Long clinicianRefId = (a.clinician() == null) ? null
                                : refCodeResolver.resolveClinician(a.clinician(), null, null, "SYSTEM", ingestionFileId, c.id()).orElse(null);

                        long actId = upsertActivity(claimId, a, clinicianRefId, activityCodeRefId); // PATCH

                        acts++;
                        if (a.observations() != null) {
                            for (ObservationDTO o : a.observations()) {
                                // Observation unique index will dedupe; value_text may be null ? OK
                                upsertObservation(actId, o);
                                obs++;
                            }
                        }
                    }
                }

                // Events & Timeline (only for persisted claim)
                long ev1 = insertClaimEvent(claimKeyId, ingestionFileId, file.header().transactionDate(), (short) 1, submissionId, null);
                projectActivitiesToClaimEventFromSubmission(ev1, c.activities());
                insertStatusTimeline(claimKeyId, (short) 1, file.header().transactionDate(), ev1);

                if (c.resubmission() != null) {
                    long ev2 = insertClaimEvent(claimKeyId, ingestionFileId, file.header().transactionDate(), (short) 2, submissionId, null);
                    insertResubmission(ev2, c.resubmission());
                    insertStatusTimeline(claimKeyId, (short) 2, file.header().transactionDate(), ev2);
                }

                // Attachments (Submission-only)
                if (attachments != null && !attachments.isEmpty()) {
                    for (ParseOutcome.AttachmentRecord ar : attachments) {
                        if (!Objects.equals(ar.claimId(), claimIdBiz)) continue;
                        upsertClaimAttachment(claimKeyId, ev1, ingestionFileId, ar);
                    }
                }

                claims++; // count only persisted claims
            } catch (Exception claimEx) {
                // NEW: contain the blast radius to this claim
                errors.claimError(ingestionFileId, "PERSIST", claimIdBiz,
                        "CLAIM_PERSIST_FAIL", claimEx.getMessage(), false);
                // optionally log debug stack:
                log.debug("claim persist failed claimId={} : ", claimIdBiz, claimEx);
                // continue with next claim
            }
        }

            if (skippedDup > 0) {
                errors.fileError(ingestionFileId, "VALIDATE", "DUP_SUBMISSION_NO_RESUB_SUMMARY",
                        "Skipped " + skippedDup + " duplicate submission(s) without <Resubmission>.", false);
            }
            if (skippedInvalidClaim > 0) {
                errors.fileError(ingestionFileId, "VALIDATE", "MISSING_CLAIM_REQUIRED_SUMMARY",
                        "Skipped " + skippedInvalidClaim + " invalid claim(s) due to missing requireds.", false);
            }

        return new PersistCounts(claims, acts, obs, dxs, 0, 0);
    }

    /* ========================= REMITTANCE PATH ========================= */

    @Transactional
    public PersistCounts persistRemittance(long ingestionFileId, RemittanceAdviceDTO file) {
        final Long remittanceId = jdbc.queryForObject(
                "insert into claims.remittance(ingestion_file_id) values (?) returning id",
                Long.class, ingestionFileId
        );

        int rClaims = 0, rActs = 0, skippedInvalidRemitClaim = 0;

        for (RemittanceClaimDTO c : file.claims()) {
            // guard remittance-claim level (ID, IDPayer, ProviderID, PaymentReference as used)
            if (!remitClaimHasRequired(ingestionFileId, c)) {
                skippedInvalidRemitClaim++;
                continue; // logged above
            }

            final long claimKeyId = upsertClaimKey(c.id());
            try {
                // resolve denial code ref id for the claim scope (if any denial present at claim level)
                final Long denialRefId = (c.denialCode() == null) ? null
                        : refCodeResolver.resolveDenialCode(c.denialCode(), null, c.idPayer(), "SYSTEM", ingestionFileId, c.id())
                        .orElse(null);
                final Long payerRefId = (c.idPayer() == null) ? null
                        : refCodeResolver.resolvePayer(c.idPayer(), null, "SYSTEM", ingestionFileId, c.id())
                        .orElse(null);
                final Long providerRefId = (c.providerId() == null) ? null
                        : refCodeResolver.resolveProvider(c.providerId(), null, "SYSTEM", ingestionFileId, c.id())
                        .orElse(null);

                final long rcId = upsertRemittanceClaim(remittanceId, claimKeyId, c, denialRefId, payerRefId, providerRefId); // PATCH


                if (c.activities() != null) {
                    for (RemittanceActivityDTO a : c.activities()) {
                        if (!remitActivityHasRequired(ingestionFileId, c.id(), a)) continue; // logged+skip
                        upsertRemittanceActivity(rcId, a);
                        rActs++;
                    }
                }

                long ev = insertClaimEvent(claimKeyId, ingestionFileId, file.header().transactionDate(), (short) 3, null, remittanceId);
                projectActivitiesToClaimEventFromRemittance(ev, c.activities());

                // Decide status from amounts & denials
                var netRequested = fetchSubmissionNetRequested(claimKeyId);  // sum of submission activity.net
                var paidAmount = fetchRemittancePaidAmount(rcId);          // sum of remit activity.payment_amount
                boolean allDenied = areAllRemitActivitiesDenied(rcId);

                short status;
                final short SUBMITTED = 1, RESUBMITTED = 2, PAID = 3, PARTIALLY_PAID = 4, REJECTED = 5; // doc’d types
                int cmp = nz(paidAmount).compareTo(nz(netRequested));
                if (cmp == 0 && nz(netRequested).signum() >= 0) {
                    status = PAID;
                } else if (nz(paidAmount).signum() > 0 && cmp < 0) {
                    status = PARTIALLY_PAID;
                } else if (nz(paidAmount).signum() == 0 && allDenied) {
                    status = REJECTED;
                } else {
                    status = PARTIALLY_PAID; // conservative default
                }

                insertStatusTimeline(claimKeyId, status, file.header().transactionDate(), ev);

                rClaims++;
            } catch (Exception claimEx) {
                // NEW: contain the blast radius to this claim
                errors.claimError(ingestionFileId, "PERSIST", c.id(),
                        "CLAIM_PERSIST_FAIL", claimEx.getMessage(), false);
                // optionally log debug stack:
                log.debug("claim persist failed claimId={} : ", c.id(), claimEx);
                // continue with next claim
            }
        }

        if (skippedInvalidRemitClaim > 0) {
            errors.fileError(ingestionFileId, "VALIDATE", "MISSING_REMIT_REQUIRED_SUMMARY",
                    "Skipped " + skippedInvalidRemitClaim + " invalid remittance claim(s) due to missing requireds.", false);
        }

        return new PersistCounts(0, 0, 0, 0, rClaims, rActs);
    }

    private static BigDecimal nz(BigDecimal v) {
        return v == null ? BigDecimal.ZERO : v;
    }

    private BigDecimal fetchSubmissionNetRequested(long claimKeyId) {
        return jdbc.queryForObject("""
                    select coalesce(sum(a.net), 0.0)
                      from claims.claim c
                      join claims.activity a on a.claim_id = c.id
                     where c.claim_key_id = ?
                """, BigDecimal.class, claimKeyId);
    }

    private BigDecimal fetchRemittancePaidAmount(long remittanceClaimId) {
        return jdbc.queryForObject("""
                    select coalesce(sum(ra.payment_amount), 0.0)
                      from claims.remittance_activity ra
                     where ra.remittance_claim_id = ?
                """, BigDecimal.class, remittanceClaimId);
    }

    private boolean areAllRemitActivitiesDenied(long remittanceClaimId) {
        // True when NO rows violate "must be denied or zero payment"
        Integer cnt = jdbc.queryForObject("""
                    select count(*) from claims.remittance_activity
                     where remittance_claim_id = ?
                       and (denial_code is null or denial_code = '' or payment_amount <> 0)
                """, Integer.class, remittanceClaimId);
        return cnt != null && cnt == 0;
    }

    /* ========================= HELPERS (UPserts & Inserts) ========================= */

    private boolean isAlreadySubmitted(String claimIdBiz) {
        Long ck = jdbc.query(
                "select id from claims.claim_key where claim_id=?",
                ps -> ps.setString(1, claimIdBiz),
                rs -> rs.next() ? rs.getLong(1) : null
        );
        if (ck == null) return false;
        Integer n = jdbc.queryForObject(
                "select count(*) from claims.claim_event where claim_key_id=? and type=1",
                Integer.class, ck
        );
        return n > 0;
    }

    private long upsertClaimKey(String claimIdBiz) {
        // Single round-trip UPSERT that always returns the row's id:
        // - INSERT new row
        // - On conflict, "self-update" to force RETURNING of the existing row's id (no-op update)
        // This avoids a second SELECT and removes race windows.
        return jdbc.queryForObject("""
                    insert into claims.claim_key(claim_id) values (?)
                    on conflict (claim_id) do update set claim_id = excluded.claim_id
                    returning id
                """, Long.class, claimIdBiz);
    }


    private long upsertClaim(long claimKeyId, long submissionId, SubmissionClaimDTO c,
                             Long payerRefId, Long providerRefId) { // added ref IDs
        jdbc.update("""
                            insert into claims.claim(
                              claim_key_id, submission_id,
                              id_payer, member_id, payer_id, provider_id, emirates_id_number, gross, patient_share, net,
                              payer_ref_id, provider_ref_id, comments                                 -- PATCH: new columns
                            ) values (?,?,?,?,?,?,?,?,?,?,?,?,?)
                            on conflict (claim_key_id) do nothing
                        """, claimKeyId, submissionId,
                c.idPayer(), c.memberId(), c.payerId(), c.providerId(), c.emiratesIdNumber(),
                c.gross(), c.patientShare(), c.net(),
                payerRefId, providerRefId, c.comments()                                     // PATCH: new args
        );
        return jdbc.queryForObject("select id from claims.claim where claim_key_id=?", Long.class, claimKeyId);
    }


    private void upsertEncounter(long claimId, EncounterDTO e, Long facilityRefId) { // added ref id
        jdbc.update("""
                            insert into claims.encounter(
                              claim_id, facility_id, type, patient_id, start_at, end_at, start_type, end_type, transfer_source, transfer_destination,
                              facility_ref_id                                              -- PATCH
                            ) values (?,?,?,?,?,?,?,?,?,?,?)
                            on conflict do nothing
                        """, claimId, e.facilityId(), e.type(), e.patientId(), e.start(), e.end(),
                e.startType(), e.endType(), e.transferSource(), e.transferDestination(),
                facilityRefId                                               // PATCH
        );
    }

    private void upsertDiagnosis(long claimId, DiagnosisDTO d, Long diagnosisCodeRefId) { // PATCH
        jdbc.update("""
                    insert into claims.diagnosis(claim_id, diag_type, code, diagnosis_code_ref_id) -- PATCH
                    values (?, ?, ?, ?)
                    on conflict do nothing
                """, claimId, d.type(), d.code(), diagnosisCodeRefId); // PATCH
    }

    private long upsertActivity(long claimId, ActivityDTO a, Long clinicianRefId, Long activityCodeRefId) { // PATCH
        jdbc.update("""
                            insert into claims.activity(
                              claim_id, activity_id, start_at, type, code, quantity, net, clinician, prior_authorization_id,
                              clinician_ref_id, activity_code_ref_id                         -- PATCH
                            ) values (?,?,?,?,?,?,?,?,?,?,?)
                            on conflict (claim_id, activity_id) do nothing
                        """, claimId, a.id(), a.start(), a.type(), a.code(), a.quantity(), a.net(), a.clinician(), a.priorAuthorizationId(),
                clinicianRefId, activityCodeRefId                             // PATCH
        );
        return jdbc.queryForObject("select id from claims.activity where claim_id=? and activity_id=?", Long.class, claimId, a.id());
    }


    private void upsertObservation(long actId, ObservationDTO o) {
        jdbc.update("""
                    insert into claims.observation(activity_id, obs_type, obs_code, value_text, value_type, file_bytes)
                    values (?,?,?,?,?,?)
                    on conflict do nothing
                """, actId, o.type(), o.code(), o.value(), o.valueType(), o.fileBytes());
    }

    private long insertClaimEvent(long claimKeyId, long ingestionFileId, OffsetDateTime time, short type,
                                  Long submissionId, Long remittanceId) {
        jdbc.update("""
                    insert into claims.claim_event(
                      claim_key_id, ingestion_file_id, event_time, type, submission_id, remittance_id
                    ) values (?,?,?,?,?,?)
                    on conflict (claim_key_id, type, event_time) do nothing
                """, claimKeyId, ingestionFileId, time, type, submissionId, remittanceId);

        return jdbc.queryForObject("""
                    select id from claims.claim_event
                     where claim_key_id=? and type=?
                     order by event_time desc, id desc
                     limit 1
                """, Long.class, claimKeyId, type);
    }

    private void projectActivitiesToClaimEventFromSubmission(long eventId, Set<ActivityDTO> acts) {
        if (acts == null) return;
        for (ActivityDTO a : acts) {
            jdbc.update("""
                                insert into claims.claim_event_activity(
                                  claim_event_id, activity_id_at_event, start_at_event, type_at_event, code_at_event,
                                  quantity_at_event, net_at_event, clinician_at_event, prior_authorization_id_at_event,
                                  list_price_at_event, gross_at_event, patient_share_at_event, payment_amount_at_event, denial_code_at_event
                                ) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)
                                on conflict (claim_event_id, activity_id_at_event) do nothing
                            """, eventId, a.id(), a.start(), a.type(), a.code(),
                    a.quantity(), a.net(), a.clinician(), a.priorAuthorizationId(),
                    null, null, null, null, null);

            if (a.observations() != null) {
                for (ObservationDTO o : a.observations()) {
                    jdbc.update("""
                                insert into claims.event_observation(
                                  claim_event_activity_id, obs_type, obs_code, value_text, value_type
                                )
                                select cea.id, ?, ?, ?, ?
                                  from claims.claim_event_activity cea
                                 where cea.claim_event_id = ? and cea.activity_id_at_event = ?
                            """, o.type(), o.code(), o.value(), o.valueType(), eventId, a.id());
                }
            }
        }
    }

    private void projectActivitiesToClaimEventFromRemittance(long eventId, List<RemittanceActivityDTO> acts) {
        if (acts == null) return;
        for (RemittanceActivityDTO a : acts) {
            jdbc.update("""
                                insert into claims.claim_event_activity(
                                  claim_event_id, activity_id_at_event, start_at_event, type_at_event, code_at_event,
                                  quantity_at_event, net_at_event, clinician_at_event, prior_authorization_id_at_event,
                                  list_price_at_event, gross_at_event, patient_share_at_event, payment_amount_at_event, denial_code_at_event
                                ) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)
                                on conflict (claim_event_id, activity_id_at_event) do nothing
                            """, eventId, a.id(), a.start(), a.type(), a.code(),
                    a.quantity(), a.net(), a.clinician(), a.priorAuthorizationId(),
                    a.listPrice(), a.gross(), a.patientShare(), a.paymentAmount(), a.denialCode());
        }
    }

    private void insertResubmission(long eventId, ResubmissionDTO r) {
        jdbc.update("""
                    insert into claims.claim_resubmission(
                      claim_event_id, resubmission_type, comment, attachment
                    ) values (?,?,?,?)
                    on conflict do nothing
                """, eventId, r.type(), r.comment(), r.attachment());
    }

    private void insertStatusTimeline(long claimKeyId, short status, OffsetDateTime time, long eventId) {
        jdbc.update("""
                    insert into claims.claim_status_timeline(
                      claim_key_id, status, status_time, claim_event_id
                    ) values (?,?,?,?)
                    on conflict do nothing
                """, claimKeyId, status, time, eventId);
    }

    /**
     * NEW: Upsert remittance claim row, idempotent on (remittance_id, claim_key_id).
     */
    private long upsertRemittanceClaim(long remittanceId, long claimKeyId, RemittanceClaimDTO c, Long denialCodeRefId, Long payerCodeRefId, Long providerCodeRefId) { // PATCH
        jdbc.update("""
                            insert into claims.remittance_claim(
                              remittance_id, claim_key_id, id_payer, provider_id, denial_code, payment_reference, date_settlement, facility_id,
                              denial_code_ref_id,payer_ref_id,provider_ref_id                                               -- PATCH
                            ) values (?,?,?,?,?,?,?,?,?,?,?)
                            on conflict (remittance_id, claim_key_id) do nothing
                        """, remittanceId, claimKeyId, c.idPayer(), c.providerId(), c.denialCode(),
                c.paymentReference(), c.dateSettlement(), c.facilityId(),
                denialCodeRefId, payerCodeRefId, providerCodeRefId
        );
        return jdbc.queryForObject(
                "select id from claims.remittance_claim where remittance_id=? and claim_key_id=?",
                Long.class, remittanceId, claimKeyId
        );
    }

    /**
     * NEW: Upsert remittance activity row, idempotent on (remittance_claim_id, activity_id).
     */
    private void upsertRemittanceActivity(long remittanceClaimId, RemittanceActivityDTO a) {
        jdbc.update("""
                            insert into claims.remittance_activity(
                              remittance_claim_id, activity_id, start_at, type, code, quantity, net, list_price,
                              clinician, prior_authorization_id, gross, patient_share, payment_amount, denial_code
                            ) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)
                            on conflict (remittance_claim_id, activity_id) do nothing
                        """, remittanceClaimId, a.id(), a.start(), a.type(), a.code(), a.quantity(), a.net(), a.listPrice(),
                a.clinician(), a.priorAuthorizationId(), a.gross(), a.patientShare(), a.paymentAmount(), a.denialCode());
    }

    /**
     * Persist a submission attachment row idempotently (unique by (claim_key_id, claim_event_id, coalesce(file_name,''))).
     */
    private void upsertClaimAttachment(long claimKeyId, long claimEventId, long ingestionFileId, ParseOutcome.AttachmentRecord ar) {
        final String fileName = ar.fileName();
        final String mimeType = ar.contentType(); // may be null
        final byte[] bytes = ar.bytes();
        final Integer size = (bytes != null ? bytes.length : null);

        jdbc.update("""
                    insert into claims.claim_attachment(
                      claim_key_id, claim_event_id, file_name, mime_type, data_base64, data_length, created_at
                    ) values (?,?,?,?,?,?, now())
                    on conflict (claim_key_id, claim_event_id, coalesce(file_name,'')) do nothing
                """, claimKeyId, claimEventId, fileName, mimeType, bytes, size);
    }

    /* ========================= VALIDATION GUARDS ========================= */
    // PATCH: all guards below only check fields you already use in inserts. They log & return false; caller skips row.

    private static boolean isBlank(String s) {
        return s == null || s.isBlank();
    }

    private static boolean isNull(Object o) {
        return o == null;
    }

    private boolean claimHasRequired(long ingestionFileId, SubmissionClaimDTO c) {
        boolean ok =
                !isBlank(c.id()) &&
                        !isBlank(c.payerId()) &&
                        !isBlank(c.providerId()) &&
                        !isBlank(c.emiratesIdNumber());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", c.id(),
                    "MISSING_CLAIM_REQUIRED",
                    "Claim required fields missing; skipping claim.", false);
        }
        return ok;
    }

    private boolean encounterHasRequired(long ingestionFileId, String claimIdBiz, EncounterDTO e) {
        if (e == null) return true;
        boolean ok =
                !isBlank(e.patientId()) &&
                        !isBlank(e.facilityId()) &&
                        !isNull(e.type()) &&
                        !isNull(e.start());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", claimIdBiz,
                    "MISSING_ENCOUNTER_REQUIRED",
                    "Encounter required fields missing; skipping encounter.", false);
        }
        return ok;
    }

    private boolean diagnosisHasRequired(long ingestionFileId, String claimIdBiz, DiagnosisDTO d) {
        boolean ok = !isBlank(d.type()) && !isBlank(d.code());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", claimIdBiz,
                    "MISSING_DIAGNOSIS_REQUIRED",
                    "Diagnosis Type/Code required; skipping diagnosis.", false);
        }
        return ok;
    }

    private boolean activityHasRequired(long ingestionFileId, String claimIdBiz, ActivityDTO a) {
        boolean ok =
                !isBlank(a.id()) &&
                        !isNull(a.start()) &&
                        !isNull(a.type()) &&
                        !isBlank(a.code()) &&
                        !isNull(a.quantity()) &&
                        !isNull(a.net()) &&
                        !isNull(a.clinician());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", claimIdBiz,
                    "MISSING_ACTIVITY_REQUIRED",
                    "Activity required fields missing; skipping activity.", false);
        }
        return ok;
    }

    private boolean remitClaimHasRequired(long ingestionFileId, RemittanceClaimDTO c) {
        boolean ok =
                !isBlank(c.id()) &&
                        !isBlank(c.idPayer()) &&
                        !isBlank(c.providerId()) &&
                        !isBlank(c.paymentReference());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", c.id(),
                    "MISSING_REMIT_REQUIRED",
                    "Remittance claim required fields missing; skipping claim.", false);
        }
        return ok;
    }

    private boolean remitActivityHasRequired(long ingestionFileId, String claimIdBiz, RemittanceActivityDTO a) {
        boolean ok =
                !isBlank(a.id()) &&
                        !isNull(a.start()) &&
                        !isNull(a.type()) &&
                        !isBlank(a.code()) &&
                        !isNull(a.quantity()) &&
                        !isNull(a.net());
        if (!ok) {
            errors.claimError(ingestionFileId, "VALIDATE", claimIdBiz,
                    "MISSING_REMIT_ACTIVITY_REQUIRED",
                    "Remittance activity required fields missing; skipping activity.", false);
        }
        return ok;
    }

    /* ========================= COUNTS ========================= */

    public record PersistCounts(int claims, int acts, int obs, int dxs, int remitClaims, int remitActs) {
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\Pipeline.java =====

/*
 * SSOT NOTICE — Ingestion Pipeline (FINAL)
 * Flow: Fetcher ? Parser (StageParser) ? Validate ? Persist ? Events/Timeline ? Verify ? Audit ? (optional ACK)
 * Key decisions:
 *  - We INSERT a stub ingestion_file BEFORE parsing to provide a real FK id; placeholders are 'UNKNOWN'.
 *  - We perform a HEADER PRECHECK before any UPDATE so ingestion_file never gets nulls (keeps 'UNKNOWN').
 *  - We then run full business validation (validateSubmission/validateRemittance) before persistence.
 *  - Robust stage-to-disk archiving (best-effort).
 */
package com.acme.claims.ingestion;

import com.acme.claims.domain.model.dto.RemittanceAdviceDTO;
import com.acme.claims.domain.model.dto.SubmissionDTO;
import com.acme.claims.domain.model.entity.IngestionFile;
import com.acme.claims.ingestion.audit.ErrorLogger;
import com.acme.claims.ingestion.config.IngestionProperties;
import com.acme.claims.ingestion.fetch.WorkItem;
import com.acme.claims.ingestion.parser.ParseOutcome;
import com.acme.claims.ingestion.parser.StageParser;
import com.acme.claims.ingestion.persist.PersistService;
import com.acme.claims.ingestion.util.RootDetector;
import com.acme.claims.metrics.DhpoMetrics;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.nio.file.Files;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.util.Objects;

@Slf4j
@Service
@RequiredArgsConstructor
public class Pipeline {

    private final IngestionProperties props;
    private final StageParser parser;           // ClaimXmlParserStax implements this
    private final PersistService persist;
    private final ErrorLogger errors;
    private final JdbcTemplate jdbc;
    private final DhpoMetrics dhpoMetrics;
    @Autowired
    @Lazy
    private Pipeline self;

    public record Result(
            long ingestionFileId,
            int rootType, // 1=submission, 2=remittance
            int parsedClaims, int persistedClaims,
            int parsedActivities, int persistedActivities,
            OffsetDateTime txTime
    ) {}

    /** Process a single item end-to-end. Safe for retry; idempotency = DB uniques downstream. */
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public Result process(WorkItem wi) {
        Long filePk = null;
        long t0 = System.nanoTime();
        boolean success = false;
        try {
            // 1) Root sniff (cheap) so stub row has a valid root_type (1 or 2)
            RootDetector.RootKind sniffed = RootDetector.detect(wi.xmlBytes());
            short rootType = switch (sniffed) { case SUBMISSION -> (short)1; case REMITTANCE -> (short)2; };
            log.info("sniffed root type: {}", rootType);
            // 2) INSERT stub ingestion_file with safe placeholders
            filePk = self.insertStub(wi, rootType);
            IngestionFile fileRow = new IngestionFile();
            fileRow.setId(filePk);
            fileRow.setFileId(wi.fileId());
            fileRow.setXmlBytes(wi.xmlBytes());
            // 3) Parse (XSD ? StAX). Parser writes parse errors using ingestion_file_id=filePk
            log.info("going to parse our ingestion file : {}", filePk);
            ParseOutcome out = parser.parse(fileRow);
            log.info("successfully parsed our ingestion file : {}", filePk);

            // 4) Branch by actual root (authoritative)
            switch (out.getRootType()) {
                case SUBMISSION -> {
                    SubmissionDTO dto = out.getSubmission();

                    // PATCH: HEADER PRECHECK (before any UPDATE) — avoid nulls overwriting placeholders.
                    if (dto == null || dto.header() == null
                            || isBlank(dto.header().senderId())
                            || isBlank(dto.header().receiverId())
                            || dto.header().transactionDate() == null
                            || isBlank(dto.header().dispositionFlag())
                            || dto.claims() == null
                            || dto.header().recordCount() <= 0
                            || dto.header().recordCount() != (dto.claims() == null ? 0 : dto.claims().size())) {
                        log.info("Header Pre-Check Failed : {}", fileRow.getFileId());
                        errors.fileError(filePk, "VALIDATE", "MISSING_HEADER_FIELDS",
                                "Header required fields missing or RecordCount mismatch; file rejected.", false);
                        maybeArchive(wi, false);
                        throw new RuntimeException("Header validation failed (submission) for fileId=" + wi.fileId());
                    }

                    // Only now update ingestion_file header (COALESCE keeps existing 'UNKNOWN' if any null leaks)
                    self.updateIngestionFileHeader(
                            filePk, (short)1,
                            dto.header().senderId(), dto.header().receiverId(),
                            dto.header().transactionDate(), dto.header().recordCount(), dto.header().dispositionFlag()
                    );
                    log.info("Updated Ingestion File Header data : {}", fileRow.getFileId());

                    // Full business validation (restored per your original code)
                    try {
                        validateSubmission(dto);
                        log.info("Validation Success for file id : {}", fileRow.getFileId());
                    }
                    catch (IllegalArgumentException vex) {
                        errors.fileError(filePk, "VALIDATE", "SUBMISSION_RULES", vex.getMessage(), false);
                        maybeArchive(wi, false);
                        throw vex;
                    }

                    // Idempotency short-circuit
                    if (alreadyProjected(filePk)) {
                        log.info("file is already processed : {}", fileRow.getFileId());
                        maybeArchive(wi, true);
                        return new Result(filePk, 1, dto.claims().size(), 0, countActs(dto), 0, dto.header().transactionDate());
                    }

                    // 5) Persist graph + events/timeline
                    var counts = persist.persistSubmission(filePk, dto, out.getAttachments());
                    log.info("submission persisted");
                    maybeArchive(wi, true);
                    return new Result(filePk, 1, dto.claims().size(), counts.claims(), countActs(dto), counts.acts(), dto.header().transactionDate());
                }

                case REMITTANCE -> {
                    RemittanceAdviceDTO dto = out.getRemittance();

                    // PATCH: HEADER PRECHECK (remittance)
                    if (dto == null || dto.header() == null
                            || isBlank(dto.header().senderId())
                            || isBlank(dto.header().receiverId())
                            || dto.header().transactionDate() == null
                            || isBlank(dto.header().dispositionFlag())
                            || dto.claims() == null
                            || dto.header().recordCount() <= 0
                            || dto.header().recordCount() != (dto.claims() == null ? 0 : dto.claims().size())) {
                        errors.fileError(filePk, "VALIDATE", "MISSING_HEADER_FIELDS",
                                "Header required fields missing or RecordCount mismatch; file rejected.", false);
                        maybeArchive(wi, false);
                        throw new RuntimeException("Header validation failed (remittance) for fileId=" + wi.fileId());
                    }

                    // PATCH: Update header now (COALESCE-safe)
                    self.updateIngestionFileHeader(
                            filePk, (short)2,
                            dto.header().senderId(), dto.header().receiverId(),
                            dto.header().transactionDate(), dto.header().recordCount(), dto.header().dispositionFlag()
                    );

                    try { validateRemittance(dto); }
                    catch (IllegalArgumentException vex) {
                        errors.fileError(filePk, "VALIDATE", "REMITTANCE_RULES", vex.getMessage(), false);
                        maybeArchive(wi, false);
                        throw vex;
                    }

                    if (alreadyProjected(filePk)) {
                        maybeArchive(wi, true);
                        return new Result(filePk, 2, dto.claims().size(), 0, countActs(dto), 0, dto.header().transactionDate());
                    }

                    var counts = persist.persistRemittance(filePk, dto);
                    // maybeArchive(wi, true);
                    success = true;
                    return new Result(filePk, 2, dto.claims().size(), counts.remitClaims(), countActs(dto), counts.remitActs(), dto.header().transactionDate());
                }
            }

            throw new IllegalStateException("Unknown root type from parser for fileId=" + wi.fileId());
        } catch (Exception ex) {
            success = false;
            maybeArchive(wi, false);
            if (filePk != null) {
                errors.fileError(filePk, "PIPELINE", "PIPELINE_FAIL",
                        "fileId=" + wi.fileId() + " msg=" + ex.getMessage(), false);
            } else {
                log.warn("PIPELINE_FAIL before file registration. fileId={} msg={}", wi.fileId(), ex.toString());
            }
            throw (ex instanceof RuntimeException re) ? re : new RuntimeException(ex);
        } finally {
            long durMs = (System.nanoTime() - t0) / 1_000_000L;      // duration in ms
            String mode   = (wi.sourcePath() != null) ? "disk" : "mem";
            String source = (wi.source() != null) ? wi.source() : "unknown";
            dhpoMetrics.recordIngestion(wi.source(), mode, Boolean.TRUE, durMs);
            maybeArchive(wi, success);                               // ? your existing cleanup
        }
    }

    // ---------- DB helpers ----------

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public Long insertStub(WorkItem wi, short rootType) {
        try {
            return jdbc.queryForObject("""
                INSERT INTO claims.ingestion_file
                  (file_id, root_type, sender_id, receiver_id, transaction_date,
                   record_count_declared, disposition_flag, xml_bytes, created_at, updated_at)
                VALUES
                  (?,       ?,         'UNKNOWN', 'UNKNOWN',  now(),
                   0,                   'UNKNOWN', ?,         now(),   now())
                RETURNING id
            """, Long.class, wi.fileId(), rootType, wi.xmlBytes());
        } catch (org.springframework.dao.DuplicateKeyException dup) {
            return jdbc.queryForObject("SELECT id FROM claims.ingestion_file WHERE file_id = ?", Long.class, wi.fileId());
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateIngestionFileHeader(Long id, short rootType,
                                             String sender, String receiver,
                                             OffsetDateTime tx, Integer recordCount, String disp) {
        jdbc.update("""
          UPDATE claims.ingestion_file
             SET root_type = ?,
                 sender_id = COALESCE(?, sender_id),
                 receiver_id = COALESCE(?, receiver_id),
                 transaction_date = COALESCE(?, transaction_date),
                 record_count_declared = COALESCE(?, record_count_declared),
                 disposition_flag = COALESCE(?, disposition_flag),
                 updated_at = now()
           WHERE id = ?
        """, rootType, sender, receiver, tx, recordCount, disp, id);
    }

    private boolean alreadyProjected(long ingestionFileId) {
        Integer n = jdbc.queryForObject("select count(*) from claims.claim_event where ingestion_file_id = ?", Integer.class, ingestionFileId);
        return Objects.requireNonNullElse(n, 0) > 0;
    }

    private void maybeArchive(WorkItem wi, boolean ok) {
        if (!props.isStageToDisk() || wi.sourcePath() == null) return;
        try {
            if(ok) {
                // SUCCESS: delete the staged source
                Files.deleteIfExists(wi.sourcePath());
                log.debug("Deleted staged file on success: {}", wi.sourcePath());
            } else {
                Path target = Path.of(ok ? props.getLocalfs().getArchiveOkDir() : props.getLocalfs().getArchiveFailDir());
                Files.createDirectories(target);
                Files.move(wi.sourcePath(), target.resolve(wi.fileId()), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (Exception ignore) {
            log.debug("Cleanup,Archive skipped for {}: {}",wi.sourcePath(), ignore.getMessage());
        }
    }

    // ---------- Counters ----------

    private static int countActs(SubmissionDTO dto) {
        return dto.claims().stream().mapToInt(c -> c.activities() == null ? 0 : c.activities().size()).sum();
    }
    private static int countActs(RemittanceAdviceDTO dto) {
        return dto.claims().stream().mapToInt(c -> c.activities() == null ? 0 : c.activities().size()).sum();
    }

    // ---------- Business validation (RESTORED as requested) ----------

    // PATCH: kept exactly in spirit with your earlier version; throws IllegalArgumentException on violations.
    private static void validateSubmission(SubmissionDTO f) {
        req(f.header(), "Header");
        req(f.header().senderId(), "Header.SenderID");
        req(f.header().receiverId(), "Header.ReceiverID");
        req(f.header().transactionDate(), "Header.TransactionDate");
        req(f.header().dispositionFlag(), "Header.DispositionFlag");
        if (f.claims() == null || f.claims().isEmpty()) throw new IllegalArgumentException("No claims in submission");
        //if (!Objects.equals(f.header().recordCount(), f.claims().size()))
         //   throw new IllegalArgumentException("RecordCount mismatch in submission");
        for (var c : f.claims()) {
            req(c.id(), "Claim.ID");
            req(c.payerId(), "Claim.PayerID (claimId=" + c.id() + ")");
            req(c.providerId(), "Claim.ProviderID (claimId=" + c.id() + ")");
            req(c.emiratesIdNumber(), "Claim.EmiratesIDNumber (claimId=" + c.id() + ")");
            //if (c.activities() == null || c.activities().isEmpty())
              //  throw new IllegalArgumentException("No activities (claimId=" + c.id() + ")");
        }
    }

    private static void validateRemittance(RemittanceAdviceDTO f) {
        req(f.header(), "Header");
        req(f.header().senderId(), "Header.SenderID");
        req(f.header().receiverId(), "Header.ReceiverID");
        req(f.header().transactionDate(), "Header.TransactionDate");
        req(f.header().dispositionFlag(), "Header.DispositionFlag");
        if (f.claims() == null || f.claims().isEmpty()) throw new IllegalArgumentException("No claims in remittance");
        //if (!Objects.equals(f.header().recordCount(), f.claims().size()))
          //  throw new IllegalArgumentException("RecordCount mismatch in remittance");
        for (var c : f.claims()) {
            req(c.id(), "Claim.ID");
            req(c.idPayer(), "Claim.IDPayer (claimId=" + c.id() + ")");
            req(c.paymentReference(), "Claim.PaymentReference (claimId=" + c.id() + ")");
            //if (c.activities() == null || c.activities().isEmpty())
              //  throw new IllegalArgumentException("No activities (claimId=" + c.id() + ")");
        }
    }

    private static void req(Object v, String f) {
        if (v == null || (v instanceof String s && s.isBlank()))
            throw new IllegalArgumentException("Missing required: " + f);
    }

    private static boolean isBlank(String s) { return s == null || s.isBlank(); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\util\RootDetector.java =====

/*
 * SSOT NOTICE — RootDetector
 * Purpose: Lightweight XML root detection to route parsing without a full pass.
 * Contract: Returns SUBMISSION for <Claim.Submission ...> and REMITTANCE for <Remittance.Advice ...>.
 */
package com.acme.claims.ingestion.util;

public final class RootDetector {
    public enum  RootKind { SUBMISSION, REMITTANCE }
    private RootDetector() {}

    public static RootKind detect(byte[] xml) {
        String s = new String(xml, java.nio.charset.StandardCharsets.UTF_8);
        if (s.contains("<Claim.Submission")) return RootKind.SUBMISSION;
        if (s.contains("<Remittance.Advice")) return RootKind.REMITTANCE;
        throw new IllegalArgumentException("Unknown XML root");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\ingestion\verify\VerifyService.java =====

/*
 * SSOT NOTICE — Verify Service
 * Purpose: Lightweight, fast, per-file SQL integrity checks after ingestion completes.
 * Checks:
 *   1) At least one claim_event exists for this ingestion_file_id (projection happened).
 *   2) No orphans:
 *        - activity rows must have a parent claim
 *        - claim_event_activity rows must have a parent claim_event
 *        - event_observation rows must have a parent claim_event_activity
 *   3) Optional uniqueness spot-checks can be added if needed.
 * Returns: true if all checks pass; false otherwise (or throws on SQL errors).
 */
package com.acme.claims.ingestion.verify;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

@Service
public class VerifyService {

    private static final Logger log = LoggerFactory.getLogger(VerifyService.class);
    private final JdbcTemplate jdbc;

    public VerifyService(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    /** Run post-file verification; keep it quick and side-effect free. */
    public boolean verifyFile(long ingestionFileId) {
        try {
            // 1) Ensure at least one claim_event was projected for this file
            Integer ev = jdbc.queryForObject(
                    "select count(*) from claims.claim_event where ingestion_file_id = ?",
                    Integer.class, ingestionFileId);
            if (ev == null || ev <= 0) {
                log.warn("Verify: no claim_event rows for ingestion_file_id={}", ingestionFileId);
                return false;
            }

            // 2a) Orphan activities (activity.claim_id must exist in claim)
            Integer orphansAct = jdbc.queryForObject("""
          select count(*) from claims.activity a
          left join claims.claim c on c.id = a.claim_id
          where c.id is null
        """, Integer.class);
            if (orphansAct != null && orphansAct > 0) {
                log.warn("Verify: {} orphan activity rows (no parent claim) for ingestion_file_id={}", orphansAct, ingestionFileId);
                return false;
            }

            // 2b) Orphan claim_event_activity (must have parent claim_event)
            Integer orphansCEA = jdbc.queryForObject("""
          select count(*) from claims.claim_event_activity cea
          left join claims.claim_event ce on ce.id = cea.claim_event_id
          where ce.id is null
        """, Integer.class);
            if (orphansCEA != null && orphansCEA > 0) {
                log.warn("Verify: {} orphan claim_event_activity rows (no parent event) for ingestion_file_id={}", orphansCEA, ingestionFileId);
                return false;
            }

            // 2c) Orphan event_observation (must have parent claim_event_activity)
            Integer orphansEO = jdbc.queryForObject("""
          select count(*) from claims.event_observation eo
          left join claims.claim_event_activity cea on cea.id = eo.claim_event_activity_id
          where cea.id is null
        """, Integer.class);
            if (orphansEO != null && orphansEO > 0) {
                log.warn("Verify: {} orphan event_observation rows (no parent cea) for ingestion_file_id={}", orphansEO, ingestionFileId);
                return false;
            }

            // All checks passed
            return true;
        } catch (Exception e) {
            log.error("Verify exception for ingestion_file_id={}: {}", ingestionFileId, e.getMessage(), e);
            return false;
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\ClaimAttachmentMapper.java =====

package com.acme.claims.mapper;

import com.acme.claims.domain.model.dto.AttachmentDTO;
import com.acme.claims.domain.model.entity.ClaimAttachment;
import org.mapstruct.*;

@Mapper(componentModel = "spring", config = MapStructCentralConfig.class)
public interface ClaimAttachmentMapper {

    @Mapping(target="id", ignore=true)
    @Mapping(target="createdAt", expression="java(java.time.OffsetDateTime.now())")
    @Mapping(target="dataBase64", expression="java(dto.decode())")
    ClaimAttachment toEntity(AttachmentDTO dto,
                             Long claimKeyId,
                             Long claimEventId);

    @InheritInverseConfiguration
    @Mapping(target="base64Data", expression="java(java.util.Base64.getEncoder().encodeToString(entity.getDataBase64()))")
    AttachmentDTO toDto(ClaimAttachment entity);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\IngestionFileMapper.java =====

// FILE: src/main/java/com/acme/claims/ingestion/mapper/IngestionFileMapper.java
// Version: v1.0.0
// Maps: Header DTOs ? claims.ingestion_file (SSOT)  (rootType and xmlBytes provided by caller)
// We intentionally map only persisted header fields.  :contentReference[oaicite:15]{index=15} :contentReference[oaicite:16]{index=16}
package com.acme.claims.mapper;


import com.acme.claims.domain.model.dto.RemittanceHeaderDTO;
import com.acme.claims.domain.model.dto.SubmissionHeaderDTO;
import com.acme.claims.domain.model.entity.IngestionFile;
import org.mapstruct.*;

@Mapper(config = MapStructCentralConfig.class)
public interface IngestionFileMapper {
    @Mapping(target="id", ignore = true)
    @Mapping(target="fileId", source="fileId")
    @Mapping(target="rootType", constant = "1") // 1 = Claim.Submission
    @Mapping(target="senderId", source="header.senderId")
    @Mapping(target="receiverId", source="header.receiverId")
    @Mapping(target="transactionDate", source="header.transactionDate")
    @Mapping(target="recordCountDeclared", source="header.recordCount")
    @Mapping(target="dispositionFlag", source="header.dispositionFlag")
    @Mapping(target="xmlBytes", source="xmlBytes")
    @Mapping(target="createdAt", expression = "java(java.time.OffsetDateTime.now())")
    @Mapping(target="updatedAt", expression = "java(java.time.OffsetDateTime.now())")
    IngestionFile fromSubmissionHeader(SubmissionHeaderDTO header, String fileId, byte[] xmlBytes);

    @Mapping(target="id", ignore = true)
    @Mapping(target="fileId", source="fileId")
    @Mapping(target="rootType", constant = "2") // 2 = Remittance.Advice
    @Mapping(target="senderId", source="header.senderId")
    @Mapping(target="receiverId", source="header.receiverId")
    @Mapping(target="transactionDate", source="header.transactionDate")
    @Mapping(target="recordCountDeclared", source="header.recordCount")
    @Mapping(target="dispositionFlag", source="header.dispositionFlag")
    @Mapping(target="xmlBytes", source="xmlBytes")
    @Mapping(target="createdAt", expression = "java(java.time.OffsetDateTime.now())")
    @Mapping(target="updatedAt", expression = "java(java.time.OffsetDateTime.now())")
    IngestionFile fromRemittanceHeader(RemittanceHeaderDTO header, String fileId, byte[] xmlBytes);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\MapStructCentralConfig.java =====

// FILE: src/main/java/com/acme/claims/ingestion/mapper/MapperConfig.java
// Version: v1.0.0
package com.acme.claims.mapper;


import org.mapstruct.ReportingPolicy;
import org.mapstruct.MapperConfig;

@MapperConfig(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.ERROR // fail-fast if a persisted field is missed
)
public interface MapStructCentralConfig  {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\RemittanceGraphMapper.java =====

// FILE: src/main/java/com/acme/claims/ingestion/mapper/RemittanceGraphMapper.java
// Version: v1.0.0
// Maps: Remittance aggregate ? Remittance/RemittanceClaim/RemittanceActivity entities
package com.acme.claims.mapper;

import com.acme.claims.domain.model.dto.*;
import com.acme.claims.domain.model.entity.*;
import org.mapstruct.*;

@Mapper(config = MapStructCentralConfig.class)
public interface RemittanceGraphMapper {

    // group row per file
    @Mapping(target="id", ignore = true)
    @Mapping(target="ingestionFile", source="file")
    @Mapping(target = "txAt", ignore = true)
    Remittance toRemittance(RemittanceAdviceDTO dto, IngestionFile file);

    // claim adjudication (requires ClaimKey + Remittance)
    @Mapping(target="id", ignore = true)
    @Mapping(target="remittance", source="remittance")
    @Mapping(target="claimKey", source="key")
    @Mapping(target="idPayer", source="dto.idPayer")
    @Mapping(target="providerId", source="dto.providerId")
    @Mapping(target="denialCode", source="dto.denialCode")
    @Mapping(target="paymentReference", source="dto.paymentReference")
    @Mapping(target="dateSettlement", source="dto.dateSettlement")
    @Mapping(target="facilityId", source="dto.facilityId") // flattened Encounter.FacilityID per SSOT
    @Mapping(target="createdAt", expression = "java(java.time.OffsetDateTime.now())")
    @Mapping(target = "denialCodeRefId", ignore = true)
    @Mapping(target = "payerRefId", ignore = true)
    @Mapping(target = "providerRefId", ignore = true)
    RemittanceClaim toRemittanceClaim(RemittanceClaimDTO dto, Remittance remittance, ClaimKey key);

    // activity adjudication
    @Mapping(target="id", ignore = true)
    @Mapping(target="remittanceClaim", source="rc")
    @Mapping(target="activityId", source="dto.id")
    @Mapping(target="startAt", source="dto.start")
    @Mapping(target="type", source="dto.type")
    @Mapping(target="code", source="dto.code")
    @Mapping(target="quantity", source="dto.quantity")
    @Mapping(target="net", source="dto.net")
    @Mapping(target="listPrice", source="dto.listPrice")
    @Mapping(target="clinician", source="dto.clinician")
    @Mapping(target="priorAuthorizationId", source="dto.priorAuthorizationId")
    @Mapping(target="gross", source="dto.gross")
    @Mapping(target="patientShare", source="dto.patientShare")
    @Mapping(target="paymentAmount", source="dto.paymentAmount")
    @Mapping(target="denialCode", source="dto.denialCode")
    @Mapping(target="createdAt", expression = "java(java.time.OffsetDateTime.now())")
    RemittanceActivity toRemittanceActivity(RemittanceActivityDTO dto, RemittanceClaim rc);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\ResubmissionEventMapper.java =====

// FILE: src/main/java/com/acme/claims/ingestion/mapper/ResubmissionEventMapper.java
// Version: v1.0.0
package com.acme.claims.mapper;


import com.acme.claims.domain.model.dto.ResubmissionDTO;
import com.acme.claims.domain.model.entity.ClaimEvent;
import com.acme.claims.domain.model.entity.ClaimResubmission;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(config = MapStructCentralConfig.class)
public interface ResubmissionEventMapper {
    @Mapping(target="id", ignore = true)
    @Mapping(target="claimEvent", source="event")
    @Mapping(target="resubmissionType", source="dto.type")
    @Mapping(target="comment", source="dto.comment")
    @Mapping(target="attachment", source="dto.attachment") // byte[] -> byte[]
    ClaimResubmission toEntity(ResubmissionDTO dto, ClaimEvent event);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\mapper\SubmissionGraphMapper.java =====

// FILE: src/main/java/com/acme/claims/ingestion/mapper/SubmissionGraphMapper.java
// Version: v1.0.0
// Maps: Submission aggregate ? Submission/Claim/Encounter/Diagnosis/Activity/Observation entities
package com.acme.claims.mapper;


import com.acme.claims.domain.model.dto.*;
import com.acme.claims.domain.model.entity.*;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

@Mapper(config = MapStructCentralConfig.class, uses = {})
public interface SubmissionGraphMapper {

    // group row per file
    @Mapping(target="id", ignore = true)
    @Mapping(target="ingestionFile", source="file")
    Submission toSubmission(SubmissionDTO dto, IngestionFile file);

    // claim (requires existing ClaimKey + Submission)
    @Mapping(target="id", ignore = true)
    @Mapping(target="claimKey", source="key")
    @Mapping(target="submission", source="submission")
    @Mapping(target="idPayer", source="dto.idPayer")
    @Mapping(target="memberId", source="dto.memberId")
    @Mapping(target="payerId", source="dto.payerId")
    @Mapping(target="providerId", source="dto.providerId")
    @Mapping(target="emiratesIdNumber", source="dto.emiratesIdNumber")
    @Mapping(target="gross", source="dto.gross")
    @Mapping(target="patientShare", source="dto.patientShare")
    @Mapping(target="net", source="dto.net")
    @Mapping(target="createdAt", ignore = true)
    @Mapping(target="updatedAt", ignore = true)
    @Mapping(target="payerRefId", ignore = true)
    @Mapping(target="providerRefId", ignore = true)
    @Mapping(target = "txAt", ignore = true)
    @Mapping(target = "comments", source = "dto.comments")
    Claim toClaim(SubmissionClaimDTO dto, ClaimKey key, Submission submission);

    // encounter (optional)
    @Mapping(target="id", ignore = true)
    @Mapping(target="claim", source="claim")
    @Mapping(target="facilityId", source="dto.facilityId")
    @Mapping(target="type", source="dto.type")
    @Mapping(target="patientId", source="dto.patientId")
    @Mapping(target="startAt", source="dto.start")
    @Mapping(target="endAt", source="dto.end")
    @Mapping(target="startType", source="dto.startType")
    @Mapping(target="endType", source="dto.endType")
    @Mapping(target="transferSource", source="dto.transferSource")
    @Mapping(target="transferDestination", source="dto.transferDestination")
    @Mapping(target = "facilityRefId", ignore = true)
    Encounter toEncounter(EncounterDTO dto, Claim claim);

    // diagnosis
    @Mapping(target="id", ignore = true)
    @Mapping(target="diagType", source="dto.type")
    @Mapping(target = "claim", source = "claim")
    @Mapping(target="code", source="dto.code")
    @Mapping(target = "diagnosisCodeRefId", ignore = true)
    Diagnosis toDiagnosis(DiagnosisDTO dto, Claim claim);

    // activity
    @Mapping(target="id", ignore = true)
    @Mapping(target="claim", source="claim")
    @Mapping(target="activityId", source="dto.id")
    @Mapping(target="startAt", source="dto.start")
    @Mapping(target="type", source="dto.type")
    @Mapping(target="code", source="dto.code")
    @Mapping(target="quantity", source="dto.quantity")
    @Mapping(target="net", source="dto.net")
    @Mapping(target="clinician", source="dto.clinician")
    @Mapping(target="priorAuthorizationId", source="dto.priorAuthorizationId")
    @Mapping(target="createdAt", expression = "java(java.time.OffsetDateTime.now())")
    @Mapping(target="updatedAt", expression = "java(java.time.OffsetDateTime.now())")
    @Mapping(target = "activityCodeRefId", ignore = true)
    @Mapping(target = "clinicianRefId", ignore = true)
    Activity toActivity(ActivityDTO dto, Claim claim);

    // observation
    @Mapping(target="id", ignore = true)
    @Mapping(target="activity", source="activity")
    @Mapping(target="obsType", source="dto.type")
    @Mapping(target="obsCode", source="dto.code")
    @Mapping(target="valueText", source="dto.value")
    @Mapping(target="valueType", source="dto.valueType")
    @Mapping(target="createdAt", ignore = true)
    @Mapping(target = "fileBytes", source = "dto.fileBytes")
    Observation toObservation(ObservationDTO dto, Activity activity);

    @Named("hashOrPlain")
    default String hashOrPlain(String emiratesId, boolean hashEnabled){
        if (!hashEnabled) return emiratesId;
        return sha256(emiratesId.getBytes()).toString() ;
    }

    private static byte[] sha256(byte[] bytes) {
        if (bytes == null) return null;
        try {
            return java.security.MessageDigest.getInstance("SHA-256").digest(bytes);
        } catch (java.security.NoSuchAlgorithmException e) {
            throw new IllegalStateException("SHA-256 not available", e);
        }
    }

    private static String md5Hex(String s) {
        try {
            var md = java.security.MessageDigest.getInstance("MD5");
            byte[] input = (s == null) ? new byte[0] : s.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            byte[] dig = md.digest(input);
            // fast hex (no external libs)
            char[] HEX = "0123456789abcdef".toCharArray();
            char[] out = new char[dig.length * 2];
            for (int i = 0, j = 0; i < dig.length; i++) {
                int v = dig[i] & 0xFF;
                out[j++] = HEX[v >>> 4];
                out[j++] = HEX[v & 0x0F];
            }
            return new String(out);
        } catch (java.security.NoSuchAlgorithmException e) {
            throw new IllegalStateException("MD5 not available", e);
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\metrics\DhpoMetrics.java =====

package com.acme.claims.metrics;

import io.micrometer.core.instrument.*;
import org.springframework.stereotype.Component;
import java.util.concurrent.TimeUnit;

@Component
public class DhpoMetrics {
    private final MeterRegistry reg;
    public DhpoMetrics(MeterRegistry reg){ this.reg = reg; }

    public void recordDownload(String facility, String mode, long bytes, long latencyMs){
        Tags t = Tags.of("facility", nv(facility), "mode", nv(mode));
        reg.counter("dhpo.download.count", t).increment();
        DistributionSummary.builder("dhpo.download.size.bytes").baseUnit("bytes").tags(t).register(reg).record(bytes);
        Timer.builder("dhpo.download.latency").tags(t).register(reg).record(latencyMs, TimeUnit.MILLISECONDS);
    }

    public void recordIngestion(String source, String mode, boolean ok, long durMs){
        Tags t = Tags.of("source", nv(source), "mode", nv(mode), "result", ok ? "ok" : "fail");
        reg.counter("ingestion.process.count", t).increment();
        Timer.builder("ingestion.process.duration").tags(t).register(reg).record(durMs, TimeUnit.MILLISECONDS);
    }

    public void recordAck(String facility, String fileId, boolean ok, String dhpoCode){
        Tags t = Tags.of("facility", nv(facility), "code", nv(dhpoCode), "result", ok ? "ok" : "fail");
        reg.counter("dhpo.ack.count", t).increment();
    }

    private static String nv(String s){ return (s==null||s.isBlank()) ? "unknown" : s; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\config\RefdataBootstrapProperties.java =====

package com.acme.claims.refdata.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.List;

@Getter @Setter
@ConfigurationProperties(prefix = "claims.refdata.bootstrap")
public class RefdataBootstrapProperties {
    /** Enable/disable bootstrap on startup (default false) */
    private boolean enabled = false;
    /** Strict mode: missing file or bad headers cause startup failure (default false) */
    private boolean strict = false;
    /** Location of CSVs: classpath:refdata/ or file:/opt/refdata/ */
    private String location = "classpath:refdata/";
    /** CSV delimiter: default ',' */
    private char delimiter = ',';
    /** Batch size for JDBC batchUpdate */
    private int batchSize = 500;
    /** Filenames that must exist in strict mode; otherwise optional */
    private List<String> requiredFiles = List.of(
            "payers.csv",
            "facilities.csv",
            "providers.csv",
            "clinicians.csv",
            "activity_codes.csv",
            "diagnosis_codes.csv",
            "denial_codes.csv",
            "contract_packages.csv"
    );
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\config\RefdataConfig.java =====

package com.acme.claims.refdata.config;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties({RefdataBootstrapProperties.class, RefDataProperties.class})
public class RefdataConfig {
    // no-op; just wires @ConfigurationProperties bean
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\config\RefDataProperties.java =====

package com.acme.claims.refdata.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "claims.refdata")
public class RefDataProperties {
    /** When true, resolver upserts missing codes; when false, only audits and returns empty. */
    private boolean autoInsert = true;
    public boolean isAutoInsert() { return autoInsert; }
    public void setAutoInsert(boolean autoInsert) { this.autoInsert = autoInsert; }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\RefCodeResolver.java =====

package com.acme.claims.refdata;

import com.acme.claims.refdata.config.RefDataProperties;
import com.acme.claims.refdata.config.RefdataBootstrapProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Map;
import java.util.Optional;

@Slf4j
@Service
@RequiredArgsConstructor
public class RefCodeResolver {

    private final JdbcTemplate jdbc;
    private final RefdataBootstrapProperties refdataBootstrapProperties;
    private final RefDataProperties refDataProperties;

    /* ========= Public API: return DB surrogate ids (or text PK note) ========= */

    /** Return payer.id for PayerID (e.g., INS025); creates row if missing. */
    @Transactional
    public Optional<Long> resolvePayer(String payerCode, String name, String actor, Long ingestionFileId, String claimExternalId) {
        return resolveId(
                "select id from claims_ref.payer where payer_code=?",
                ps -> ps.setString(1, payerCode),
                () -> jdbc.queryForObject("""
                        insert into claims_ref.payer(payer_code, name, status)
                        values (?,?, 'ACTIVE')
                        on conflict (payer_code) do update set name=coalesce(excluded.name, claims_ref.payer.name)
                        returning id
                        """, Long.class, payerCode, name),
                "claims_ref.payer", payerCode, null, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return provider.id for ProviderID (often same format as facility). */
    @Transactional
    public Optional<Long> resolveProvider(String providerCode, String name, String actor, Long ingestionFileId, String claimExternalId) {
        return resolveId(
                "select id from claims_ref.provider where provider_code=?",
                ps -> ps.setString(1, providerCode),
                () -> jdbc.queryForObject("""
                        insert into claims_ref.provider(provider_code, name, status)
                        values (?,?, 'ACTIVE')
                        on conflict (provider_code) do update set name=coalesce(excluded.name, claims_ref.provider.name)
                        returning id
                        """, Long.class, providerCode, name),
                "claims_ref.provider", providerCode, null, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return facility.id for Encounter.FacilityID (e.g., DHA-F-0045446). */
    @Transactional
    public Optional<Long> resolveFacility(String facilityCode, String name, String city, String country,
                                          String actor, Long ingestionFileId, String claimExternalId) {
        return resolveId(
                "select id from claims_ref.facility where facility_code=?",
                ps -> ps.setString(1, facilityCode),
                () -> jdbc.queryForObject("""
                        insert into claims_ref.facility(facility_code, name, city, country, status)
                        values (?,?,?,?,'ACTIVE')
                        on conflict (facility_code) do update
                          set name = coalesce(excluded.name, claims_ref.facility.name),
                              city = coalesce(excluded.city, claims_ref.facility.city),
                              country = coalesce(excluded.country, claims_ref.facility.country)
                        returning id
                        """, Long.class, facilityCode, name, city, country),
                "claims_ref.facility", facilityCode, null, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return clinician.id for Activity.Clinician (e.g., DHA-P-0228312). */
    @Transactional
    public Optional<Long> resolveClinician(String clinicianCode, String name, String specialty,
                                           String actor, Long ingestionFileId, String claimExternalId) {
        return resolveId(
                "select id from claims_ref.clinician where clinician_code=?",
                ps -> ps.setString(1, clinicianCode),
                () -> jdbc.queryForObject("""
                        insert into claims_ref.clinician(clinician_code, name, specialty, status)
                        values (?,?,?, 'ACTIVE')
                        on conflict (clinician_code) do update
                          set name = coalesce(excluded.name, claims_ref.clinician.name),
                              specialty = coalesce(excluded.specialty, claims_ref.clinician.specialty)
                        returning id
                        """, Long.class, clinicianCode, name, specialty),
                "claims_ref.clinician", clinicianCode, null, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return activity_code.id for (code, system) (e.g., 83036, CPT). */
    @Transactional
    public Optional<Long> resolveActivityCode(String code, String system, String description,
                                              String actor, Long ingestionFileId, String claimExternalId) {
        String sys = Optional.ofNullable(system).filter(s -> !s.isBlank()).orElse("LOCAL");
        return resolveId(
                "select id from claims_ref.activity_code where code=? and code_system=?",
                ps -> { ps.setString(1, code); ps.setString(2, sys); },
                () -> jdbc.queryForObject("""
                        insert into claims_ref.activity_code(code, code_system, description, status)
                        values (?,?,?, 'ACTIVE')
                        on conflict (code, code_system) do update
                          set description = coalesce(excluded.description, claims_ref.activity_code.description)
                        returning id
                        """, Long.class, code, sys, description),
                "claims_ref.activity_code", code, sys, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return diagnosis_code.id for (code, system) (default ICD-10). */
    @Transactional
    public Optional<Long> resolveDiagnosisCode(String code, String system, String description,
                                               String actor, Long ingestionFileId, String claimExternalId) {
        String sys = Optional.ofNullable(system).filter(s -> !s.isBlank()).orElse("ICD-10");
        return resolveId(
                "select id from claims_ref.diagnosis_code where code=? and code_system=?",
                ps -> { ps.setString(1, code); ps.setString(2, sys); },
                () -> jdbc.queryForObject("""
                        insert into claims_ref.diagnosis_code(code, code_system, description, status)
                        values (?,?,?, 'ACTIVE')
                        on conflict (code, code_system) do update
                          set description = coalesce(excluded.description, claims_ref.diagnosis_code.description)
                        returning id
                        """, Long.class, code, sys, description),
                "claims_ref.diagnosis_code", code, sys, actor, ingestionFileId, claimExternalId
        );
    }

    /**
     * Return denial_code.id for denial codes.
     * NOTE: If your current table uses TEXT PK on code (no surrogate id), either:
     *  (a) add a bigserial id + unique(code) (recommended), or
     *  (b) change return type to Optional<String> and wire FK as TEXT.
     */
    @Transactional
    public Optional<Long> resolveDenialCode(String code, String description, String payerCode,
                                            String actor, Long ingestionFileId, String claimExternalId) {
        // Preferred schema: claims_ref.denial_code(id bigserial PK, code unique)
        // Adjust if you kept TEXT PK on code.
        //ensureDenialIdColumnExists(); // no-op if already there; see comment below.
        return resolveId(
                "select id from claims_ref.denial_code where code=?",
                ps -> ps.setString(1, code),
                () -> jdbc.queryForObject("""
                        insert into claims_ref.denial_code(code, description, payer_code)
                        values (?,?,?)
                        on conflict (code) do update
                          set description = coalesce(excluded.description, claims_ref.denial_code.description),
                              payer_code  = coalesce(excluded.payer_code, claims_ref.denial_code.payer_code)
                        returning id
                        """, Long.class, code, description, payerCode),
                "claims_ref.denial_code", code, null, actor, ingestionFileId, claimExternalId
        );
    }

    /** Return contract_package.package_name (text PK) as confirmation that it exists; we don’t use numeric id. */
    @Transactional
    public boolean ensureContractPackage(String packageName, String description,
                                         String actor, Long ingestionFileId, String claimExternalId) {
        Integer present = jdbc.query(
                "select 1 from claims_ref.contract_package where package_name=?",
                ps -> ps.setString(1, packageName),
                rs -> rs.next() ? 1 : null
        );
        if (present != null) return true;

        int inserted = jdbc.update("""
                insert into claims_ref.contract_package(package_name, description, status)
                values (?,?, 'ACTIVE')
                on conflict (package_name) do update
                  set description = coalesce(excluded.description, claims_ref.contract_package.description)
                """, packageName, description);
        if (inserted > 0) audit("claims_ref.contract_package", packageName, null, actor, ingestionFileId, claimExternalId, Map.of());
        return true;
    }

    /* =========================== Internals ================================ */

    private Optional<Long> resolveId(String findSql,
                                     SqlSetter findSetter,
                                     SupplierWithSql<Long> insertReturningId,
                                     String sourceTable,
                                     String code,
                                     String codeSystem,
                                     String actor,
                                     Long ingestionFileId,
                                     String claimExternalId) {
        // NOTE: You previously used refdataBootstrapProperties.isEnabled() to short-circuit the resolver.
        // Keeping that behavior unchanged: if bootstrap is disabled, we don’t resolve/insert and just return empty.
        if (!refdataBootstrapProperties.isEnabled()) {
            // PATCH: Resolver disabled by bootstrap flag ? do nothing (caller persists only string columns)
            return Optional.empty();
        }

        // 1) Try to find existing id
        Long id = jdbc.query(findSql, findSetter::set, rs -> rs.next() ? rs.getLong(1) : null);
        if (id != null) {
            return Optional.of(id); // found ? fast path
        }

        // 2) MISS ? always audit the discovery (first time we see a new code)
        //    This is written regardless of auto-insert mode.
        // PATCH: audit-on-miss (before any optional insert)
        audit(sourceTable, code, codeSystem, actor, ingestionFileId, claimExternalId, Map.of());

        // 3) Respect the auto-insert flag:
        //    - true  ? insert (UPSERT) and return new id
        //    - false ? audit-only, return empty so caller writes *_ref_id = NULL (string columns still persisted)
        if (!refDataProperties.isAutoInsert()) {
            // PATCH: audit-only mode ? do not mutate ref tables
            return Optional.empty();
        }

        // 4) Auto-insert mode: perform single round-trip UPSERT … RETURNING id (idempotent)
        // PATCH: perform insert and return id
        Long newId = insertReturningId.get();
        return Optional.ofNullable(newId);
    }


    private void audit(String sourceTable, String code, String codeSystem, String actor,
                       Long ingestionFileId, String claimExternalId, Map<String, Object> details) {
        jdbc.update("""
            insert into claims.code_discovery_audit(
              source_table, code, code_system, discovered_by, ingestion_file_id, claim_external_id, details
            ) values (?,?,?,?,?,?, to_jsonb(?::text))
            """, sourceTable, code, codeSystem, Optional.ofNullable(actor).orElse("SYSTEM"),
                ingestionFileId, claimExternalId, details == null ? "{}" : details.toString());
    }

    /* Small functional helpers (keep code readable) */
    @FunctionalInterface private interface SupplierWithSql<T> { T get(); }
    @FunctionalInterface private interface SqlSetter { void set(java.sql.PreparedStatement ps) throws java.sql.SQLException; }

    /* NOTE:
       If your current denial_code table lacks a surrogate id, add it once with:
         alter table claims_ref.denial_code add column if not exists id bigserial;
         create unique index if not exists uq_denial_code on claims_ref.denial_code(code);
       And prefer FK ? denial_code(id). If you must keep TEXT PK, change resolveDenialCode to return Optional<String>.
    */
    private void ensureDenialIdColumnExists() { /* no-op placeholder to highlight the note above */ }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\RefdataBootstrapRunner.java =====

package com.acme.claims.refdata;

import com.acme.claims.refdata.config.RefdataBootstrapProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Order(10)
@RequiredArgsConstructor
@ConditionalOnProperty(prefix = "claims.refdata.bootstrap", name = "enabled", havingValue = "true")
public class RefdataBootstrapRunner implements ApplicationRunner {

    private final RefdataCsvLoader loader;
    private final RefdataBootstrapProperties props;

    @Override
    public void run(ApplicationArguments args) {
        log.info("Refdata bootstrap starting. source={} strict={} delimiter='{}' batch={}",
                props.getLocation(), props.isStrict(), props.getDelimiter(), props.getBatchSize());
        int total = 0;
        total += loader.loadPayers();
        total += loader.loadFacilities();
        total += loader.loadProviders();
        total += loader.loadClinicians();
        total += loader.loadActivityCodes();
        total += loader.loadDiagnosisCodes();
        total += loader.loadDenialCodes();
        total += loader.loadContractPackages();
        log.info("Refdata bootstrap finished. total rows affected={}", total);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\refdata\RefdataCsvLoader.java =====

package com.acme.claims.refdata;

import com.acme.claims.refdata.config.RefdataBootstrapProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Function;

@Slf4j
@Service
@RequiredArgsConstructor
public class RefdataCsvLoader {

    private final JdbcTemplate jdbc;
    private final ResourceLoader resources;
    private final RefdataBootstrapProperties props;

    // ===== Public file loaders (kept same method names for call sites) =====

    @Transactional
    public int loadPayers() {
        return loadCsv("payers.csv",
                Set.of("payer_code","name","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.payer(payer_code, name, status)
                        values (?,?,?)
                        on conflict (payer_code) do update set name=excluded.name, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"payer_code", 1, 120, true),
                                opt(rec,"name", 0, 256),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadFacilities() {
        return loadCsv("facilities.csv",
                Set.of("facility_code","name","city","country","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.facility(facility_code, name, city, country, status)
                        values (?,?,?,?,?)
                        on conflict (facility_code) do update
                           set name=excluded.name, city=excluded.city, country=excluded.country, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"facility_code", 1, 120, true),
                                opt(rec,"name", 0, 256),
                                opt(rec,"city", 0, 128),
                                opt(rec,"country", 0, 64),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadProviders() {
        return loadCsv("providers.csv",
                Set.of("provider_code","name","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.provider(provider_code, name, status)
                        values (?,?,?)
                        on conflict (provider_code) do update set name=excluded.name, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"provider_code", 1, 120, true),
                                opt(rec,"name", 0, 256),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadClinicians() {
        return loadCsv("clinicians.csv",
                Set.of("clinician_code","name","specialty","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.clinician(clinician_code, name, specialty, status)
                        values (?,?,?,?)
                        on conflict (clinician_code) do update
                           set name=excluded.name, specialty=excluded.specialty, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"clinician_code", 1, 120, true),
                                opt(rec,"name", 0, 256),
                                opt(rec,"specialty", 0, 128),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadActivityCodes() {
        return loadCsv("activity_codes.csv",
                Set.of("code","code_system","description","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.activity_code(code, code_system, description, status)
                        values (?,?,?,?)
                        on conflict (code, code_system) do update
                           set description=excluded.description, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"code", 1, 64, true),                               // ActivityCode: no whitespace
                                def(rec,"code_system","LOCAL", 1, 32, true),
                                opt(rec,"description", 0, 512),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadDiagnosisCodes() {
        return loadCsv("diagnosis_codes.csv",
                Set.of("code","code_system","description","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.diagnosis_code(code, code_system, description, status)
                        values (?,?,?,?)
                        on conflict (code, code_system) do update
                           set description=excluded.description, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"code", 1, 16, true),                                // ICD-10 codes are short
                                def(rec,"code_system","ICD-10", 1, 32, true),
                                opt(rec,"description", 0, 512),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    @Transactional
    public int loadDenialCodes() {
        return loadCsv("denial_codes.csv",
                Set.of("code","description","payer_code"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.denial_code(code, description, payer_code)
                        values (?,?,?)
                        on conflict (code) do update set description=excluded.description, payer_code=excluded.payer_code
                        """,
                        (rec) -> new Object[]{
                                req(rec,"code", 1, 64, true),
                                opt(rec,"description", 0, 512),
                                opt(rec,"payer_code", 0, 120)
                        }));
    }

    @Transactional
    public int loadContractPackages() {
        return loadCsv("contract_packages.csv",
                Set.of("package_name","description","status"),
                recs -> batchUpsert(recs, """
                        insert into claims_ref.contract_package(package_name, description, status)
                        values (?,?,?)
                        on conflict (package_name) do update set description=excluded.description, status=excluded.status
                        """,
                        (rec) -> new Object[]{
                                req(rec,"package_name", 1, 120, false),                      // package names may have spaces
                                opt(rec,"description", 0, 512),
                                def(rec,"status","ACTIVE", 1, 32, true)
                        }));
    }

    // ===== Generic CSV framework (strict/lenient, headers, batching) =====

    private int loadCsv(String fileName,
                        Set<String> requiredHeaders,
                        Function<List<CSVRecord>, Integer> batchHandler) {
        final String uri = (props.getLocation().endsWith("/") ? props.getLocation() : props.getLocation()+"/") + fileName;
        final Resource res = resources.getResource(uri);

        if (!res.exists()) {
            final boolean required = props.isStrict() && props.getRequiredFiles().contains(fileName);
            final String msg = "Refdata CSV not found: " + uri + (required ? " [STRICT]" : " [optional]");
            if (required) throw new IllegalStateException(msg);
            log.info("{} — skipping.", msg);
            return 0;
        }

        try (var reader = new BufferedReader(new InputStreamReader(res.getInputStream(), StandardCharsets.UTF_8))) {
            var format = CSVFormat.DEFAULT.builder()
                    .setHeader()
                    .setSkipHeaderRecord(true)
                    .setTrim(true)
                    .setIgnoreSurroundingSpaces(true)
                    .setDelimiter(props.getDelimiter())
                    .build();

            try (var parser = new CSVParser(reader, format)) {
                var headerMap = parser.getHeaderMap();
                validateHeaders(fileName, headerMap.keySet(), requiredHeaders);

                // Collect all records (we apply JDBC batch ourselves)
                List<CSVRecord> all = parser.getRecords();
                if (all.isEmpty()) {
                    log.info("Refdata CSV empty: {} — nothing to do.", fileName);
                    return 0;
                }
                return batchHandler.apply(all);
            }
        } catch (RuntimeException re) {
            // honor strictness
            if (props.isStrict()) throw re;
            log.error("Refdata load failed (lenient): {} -> {}", fileName, re.getMessage(), re);
            return 0;
        } catch (Exception e) {
            if (props.isStrict()) throw new IllegalStateException("Failed to load " + fileName + ": " + e.getMessage(), e);
            log.error("Refdata load failed (lenient): {} -> {}", fileName, e.getMessage(), e);
            return 0;
        }
    }

    private void validateHeaders(String fileName, Set<String> actual, Set<String> required) {
        Set<String> missing = new LinkedHashSet<>(required);
        missing.removeAll(lowercase(actual));
        if (!missing.isEmpty()) {
            var msg = "CSV " + fileName + " missing headers: " + missing;
            if (props.isStrict()) throw new IllegalStateException(msg);
            log.warn("{} (lenient mode: continuing, rows may be skipped)", msg);
        }
    }

    private Set<String> lowercase(Set<String> names) {
        Set<String> out = new HashSet<>();
        for (String n : names) out.add(n == null ? null : n.toLowerCase(Locale.ROOT));
        return out;
    }

    private int batchUpsert(List<CSVRecord> recs, String sql, Function<CSVRecord,Object[]> binder) {
        final int batch = Math.max(50, props.getBatchSize());
        int total = 0;

        List<Object[]> buffer = new ArrayList<>(batch);
        for (CSVRecord r : recs) {
            try {
                buffer.add(binder.apply(r));
                if (buffer.size() == batch) {
                    total += execBatch(sql, buffer);
                    buffer.clear();
                }
            } catch (IllegalArgumentException ex) {
                // validation error for this row
                handleRowError(r, ex);
            }
        }
        if (!buffer.isEmpty()) total += execBatch(sql, buffer);
        log.info("Refdata upsert ok: rows affected={}", total);
        return total;
    }

    private int execBatch(String sql, List<Object[]> buffer) {
        try {
            int[] counts = jdbc.batchUpdate(sql, buffer);
            int sum = 0; for (int c : counts) sum += Math.max(0, c);
            return sum;
        } catch (DataAccessException dae) {
            if (props.isStrict()) throw dae;
            log.error("Batch upsert failed (lenient): {}", dae.getMessage(), dae);
            return 0;
        }
    }

    private void handleRowError(CSVRecord r, IllegalArgumentException ex) {
        String preview = "[line " + r.getRecordNumber() + "] " + ex.getMessage();
        if (props.isStrict()) throw ex;
        log.warn("Refdata row skipped (lenient): {}", preview);
    }

    // ===== Field helpers (trim, defaults, XSD-like checks) ==================

    private static String trimOrNull(String v) {
        if (v == null) return null;
        String t = v.trim();
        return t.isEmpty() ? null : t;
    }

    /** Required field with optional "no whitespace" check and length bounds. */
    private static String req(CSVRecord rec, String name, int minLen, int maxLen, boolean noWhitespace) {
        String v = trimOrNull(rec.get(name));
        if (v == null) throw new IllegalArgumentException("Missing required column '" + name + "'");
        if (noWhitespace && containsWhitespace(v)) {
            throw new IllegalArgumentException("Column '" + name + "' contains whitespace");
        }
        if (v.length() < minLen || v.length() > maxLen) {
            throw new IllegalArgumentException("Column '" + name + "' length out of bounds");
        }
        return v;
    }

    /** Optional field with length bounds; returns null if blank. */
    private static String opt(CSVRecord rec, String name, int minLen, int maxLen) {
        if (!rec.isMapped(name)) return null;
        String v = trimOrNull(rec.get(name));
        if (v == null) return null;
        if (v.length() < minLen || v.length() > maxLen) {
            throw new IllegalArgumentException("Column '" + name + "' length out of bounds");
        }
        return v;
    }

    /** Defaulted field (if blank) with length bounds and optional "no whitespace". */
    private static String def(CSVRecord rec, String name, String def, int minLen, int maxLen, boolean noWhitespace) {
        String v = rec.isMapped(name) ? trimOrNull(rec.get(name)) : null;
        if (v == null) v = def;
        if (noWhitespace && containsWhitespace(v)) {
            throw new IllegalArgumentException("Column '" + name + "' contains whitespace");
        }
        if (v.length() < minLen || v.length() > maxLen) {
            throw new IllegalArgumentException("Column '" + name + "' length out of bounds");
        }
        return v;
    }

    private static boolean containsWhitespace(String s) {
        for (int i = 0; i < s.length(); i++) {
            if (Character.isWhitespace(s.charAt(i))) return true;
        }
        return false;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\ame\AesGcmCrypto.java =====

package com.acme.claims.security.ame;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.security.SecureRandom;
import java.util.HexFormat;

public final class AesGcmCrypto {
    private static final SecureRandom RNG = new SecureRandom();
    private AesGcmCrypto(){}

    public record Blob(byte[] iv, byte[] ct, int tagBits, String keyId){}

    public static Blob encrypt(SecretKey key, byte[] plain, byte[] aad, int tagBits, String keyId) {
        try {
            byte[] iv = new byte[12]; RNG.nextBytes(iv);
            Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
            c.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(tagBits, iv));
            if (aad != null) c.updateAAD(aad);
            byte[] out = c.doFinal(plain);
            return new Blob(iv, out, tagBits, keyId);
        } catch (Exception e) {
            throw new IllegalStateException("GCM encrypt failed", e);
        }
    }

    public static byte[] decrypt(SecretKey key, Blob blob, byte[] aad) {
        try {
            Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
            c.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(blob.tagBits(), blob.iv()));
            if (aad != null) c.updateAAD(aad);
            return c.doFinal(blob.ct());
        } catch (Exception e) {
            throw new IllegalStateException("GCM decrypt failed (keyId="+blob.keyId()+")", e);
        }
    }

    public static String ivHex(byte[] iv){ return HexFormat.of().formatHex(iv); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\ame\AmeKeyProvider.java =====

package com.acme.claims.security.ame;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.util.Base64;

@Slf4j
@Component
@RequiredArgsConstructor
@Profile("soap")
public class AmeKeyProvider {

    private final com.acme.claims.security.ame.AmeProperties props;
    private SecretKey key;

    @PostConstruct
    void init() {
        if (!props.enabled()) {
            log.warn("AME disabled; falling back to plaintext creds (not recommended).");
            return;
        }
        String type = props.keystore().type();
        if ("FILE".equalsIgnoreCase(type)) {
            loadFromFile(props.keystore().path());
        } else {
            loadFromKeyStore(type, props.keystore().path(), props.keystore().alias(), props.keystore().passwordEnv());
        }
        if (key == null) throw new IllegalStateException("AME key load failed");
        log.info("AME key loaded: type={}, id={}", props.keystore().type(), props.crypto().keyId());
    }

    private void loadFromKeyStore(String ksType, String path, String alias, String passEnv) {
        try (InputStream in = resolve(path)) {
            var ks = KeyStore.getInstance(ksType == null ? "JKS" : ksType);
            log.debug("CLAIMS_AME_STORE_PASS present? {}", System.getenv(props.keystore().passwordEnv()) != null);
            char[] pass = System.getenv(passEnv) != null ? System.getenv(passEnv).toCharArray() : new char[0];
            ks.load(in, pass);
            var sk = (KeyStore.SecretKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(pass));
            this.key = sk.getSecretKey();
        } catch (Exception e) {
            throw new IllegalStateException("Load keystore failed: " + e.getMessage(), e);
        }
    }

    private void loadFromFile(String path) {
        try (InputStream in = resolve(path)) {
            byte[] raw = in.readAllBytes();
            // accept either base64 or raw 32 bytes
            byte[] material = raw.length == 32 ? raw : Base64.getDecoder().decode(raw);
            if (material.length != 32) throw new IllegalStateException("FILE key must be 32 bytes (AES-256)");
            this.key = new SecretKeySpec(material, "AES");
        } catch (Exception e) {
            throw new IllegalStateException("Load file key failed: " + e.getMessage(), e);
        }
    }

    private static InputStream resolve(String location) throws Exception {
        if (location.startsWith("file:")) {
            return Files.newInputStream(Path.of(location.substring("file:".length())));
        }
        // classpath:… support if you want
        return Files.newInputStream(Path.of(location));
    }

    public SecretKey getKey() {
        if (key == null) throw new IllegalStateException("AME key not initialized");
        return key;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\ame\AmeProperties.java =====

package com.acme.claims.security.ame;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "claims.security.ame")
public record AmeProperties(
        boolean enabled,
        Keystore keystore,
        Crypto crypto
) {
    public record Keystore(String type, String path, String alias, String passwordEnv) {}
    public record Crypto(Integer gcmTagBits, String keyId) {}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\ame\CredsCipherService.java =====

// src/main/java/com/acme/claims/security/ame/CredsCipherService.java
package com.acme.claims.security.ame;

import com.acme.claims.domain.model.entity.FacilityDhpoConfig;
import com.acme.claims.domain.repo.FacilityDhpoConfigRepo;
import lombok.RequiredArgsConstructor;
import org.json.JSONObject;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Service
@Profile("soap")
@RequiredArgsConstructor
public class CredsCipherService {

    private final AmeProperties props;               // crypto defaults (keyId, tag bits)
    private final AmeKeyProvider keyProvider;        // active SecretKey provider
    private final FacilityDhpoConfigRepo facilityRepo;

    public record PlainCreds(String login, String pwd) {}
    public record CipherCreds(byte[] loginCt, byte[] pwdCt, String encMetaJson) {}

    /** Primary entry: resolve plaintext creds for a facility row (used by DHPO coordinator). */
    public PlainCreds decryptFor(FacilityDhpoConfig f) {
        if (!props.enabled())
            throw new IllegalStateException("App-managed encryption is disabled; encrypted creds required.");

        byte[] userCt = f.getDhpoUsernameEnc();
        byte[] pwdCt  = f.getDhpoPasswordEnc();
        String meta   = f.getEncMetaJson();
        String facilityCode = f.getFacilityCode();

        if (userCt == null || pwdCt == null || isBlank(meta))
            throw new IllegalStateException("Facility " + facilityCode + " has missing ciphertext or enc_meta_json.");

        String login = decryptUsername(userCt, meta, facilityCode);
        String pwd   = decryptPassword(pwdCt,  meta, facilityCode);
        return new PlainCreds(login, pwd);
    }

    /** Decrypt a username blob using ivLogin (or fallback to iv). */
    public String decryptUsername(byte[] ct, String encMetaJson, String facilityCode) {
        return decryptWithIvKey(ct, encMetaJson, facilityCode, "ivLogin");
    }

    /** Decrypt a password blob using ivPwd (or fallback to iv). */
    public String decryptPassword(byte[] ct, String encMetaJson, String facilityCode) {
        return decryptWithIvKey(ct, encMetaJson, facilityCode, "ivPwd");
    }

    /** Generic helper; prefers specific iv keyName, falls back to 'iv'. */
    private String decryptWithIvKey(byte[] ct, String encMetaJson, String facilityCode, String ivKeyName) {
        var meta = parseMeta(encMetaJson);
        int tagBits = meta.optInt("gcmTagBits", props.crypto().gcmTagBits());
        String keyId = meta.optString("keyId", props.crypto().keyId());

        String ivB64 = meta.optString(ivKeyName);
        if (isBlank(ivB64)) ivB64 = meta.optString("iv"); // future single-IV variant
        if (isBlank(ivB64)) throw new IllegalStateException("Missing IV in enc_meta_json (" + ivKeyName + "/iv)");

        SecretKey key = keyProvider.getKey();
        var blob = new AesGcmCrypto.Blob(Base64.getDecoder().decode(ivB64), ct, tagBits, keyId);
        byte[] pt = AesGcmCrypto.decrypt(key, blob, aad(facilityCode));
        return new String(pt, StandardCharsets.UTF_8);
    }

    /** Encrypt and produce enc_meta_json with split IVs (ivLogin/ivPwd). */
    public CipherCreds encrypt(String facilityCode, String login, String pwd) {
        if (!props.enabled())
            throw new IllegalStateException("App-managed encryption is disabled; encrypt requested.");

        SecretKey key = keyProvider.getKey();
        int tagBits = props.crypto().gcmTagBits();
        String keyId = props.crypto().keyId();

        var ebLogin = AesGcmCrypto.encrypt(key, bytes(login), aad(facilityCode), tagBits, keyId);
        var ebPwd   = AesGcmCrypto.encrypt(key, bytes(pwd),   aad(facilityCode), tagBits, keyId);

        var meta = new JSONObject();
        meta.put("v", 1);
        meta.put("alg", "AES-256-GCM");
        meta.put("gcmTagBits", tagBits);
        meta.put("keyId", keyId);
        meta.put("ivLogin", Base64.getEncoder().encodeToString(ebLogin.iv()));
        meta.put("ivPwd",   Base64.getEncoder().encodeToString(ebPwd.iv()));
        meta.put("aad", "facility_code");

        return new CipherCreds(ebLogin.ct(), ebPwd.ct(), meta.toString());
    }

    // ---------- helpers

    private static JSONObject parseMeta(String json) {
        if (isBlank(json)) throw new IllegalStateException("enc_meta_json is empty");
        try { return new JSONObject(json); }
        catch (Exception e) { throw new IllegalStateException("Invalid enc_meta_json: " + e.getMessage(), e); }
    }

    private static byte[] aad(String facilityCode) {
        return (facilityCode == null ? "" : facilityCode).getBytes(StandardCharsets.UTF_8);
    }

    private static byte[] bytes(String s) { return (s == null ? "" : s).getBytes(StandardCharsets.UTF_8); }

    private static boolean isBlank(String s){ return s == null || s.isBlank(); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\ame\ReencryptJob.java =====

// src/main/java/com/acme/claims/security/ame/ReencryptJob.java
package com.acme.claims.security.ame;

import com.acme.claims.domain.model.entity.FacilityDhpoConfig;
import com.acme.claims.domain.repo.FacilityDhpoConfigRepo;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;
import org.springframework.context.annotation.Profile;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Profile("soap")
@RequiredArgsConstructor
public class ReencryptJob {

    private final FacilityDhpoConfigRepo repo;
    private final CredsCipherService cipher;
    private final JdbcTemplate jdbc;
    private final AmeProperties props;

    /**
     * Run from an admin-only endpoint after rotating the KEK (keyId).
     * Re-encrypts all rows whose enc_meta_json.keyId != current keyId.
     */
    public int reencryptAllIfNeeded() {
        var all = repo.findAll();
        int changed = 0;
        String targetKeyId = props.crypto().keyId();

        for (FacilityDhpoConfig f : all) {
            byte[] userCt = f.getDhpoUsernameEnc();
            byte[] pwdCt  = f.getDhpoPasswordEnc();
            String meta   = f.getEncMetaJson();
            if (userCt == null || pwdCt == null || isBlank(meta)) {
                continue; // nothing to migrate
            }

            var metaObj = safeMeta(meta);
            String rowKeyId = metaObj.optString("keyId", "");
            if (targetKeyId.equals(rowKeyId)) {
                continue; // already on latest key
            }

            try {
                // decrypt with old key/meta
                String login = cipher.decryptUsername(userCt, meta, f.getFacilityCode());
                String pwd   = cipher.decryptPassword(pwdCt,  meta, f.getFacilityCode());

                // encrypt with current key/meta (split IVs)
                var c = cipher.encrypt(f.getFacilityCode(), login, pwd);

                // persist using exact column names
                int updated = jdbc.update("""
                    UPDATE claims.facility_dhpo_config
                       SET dhpo_username_enc = ?,
                           dhpo_password_enc = ?,
                           enc_meta_json     = ?,
                           updated_at        = now()
                     WHERE facility_code    = ?
                """, c.loginCt(), c.pwdCt(), c.encMetaJson(), f.getFacilityCode());

                if (updated == 1) changed++;
                else log.warn("Reencrypt: no row updated for facility_code={}", f.getFacilityCode());
            } catch (Exception e) {
                log.error("Reencrypt failed for facility_code={} : {}", f.getFacilityCode(), e.toString());
            }
        }
        log.info("Reencrypt complete; rows updated={}", changed);
        return changed;
    }

    private static JSONObject safeMeta(String json) {
        try { return new JSONObject(json); } catch (Exception e) { return new JSONObject(); }
    }
    private static boolean isBlank(String s){ return s == null || s.isBlank(); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\security\Role.java =====

package com.acme.claims.security; public enum Role { SUPER_ADMIN, FACILITY_ADMIN, STAFF }



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\client\DhpoSoapClient.java =====

// src/main/java/com/acme/claims/soap/DhpoSoapClient.java
package com.acme.claims.soap.client;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.hc.client5.http.classic.methods.HttpPost;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.core5.http.ClassicHttpResponse;
import org.apache.hc.core5.http.io.entity.StringEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;

@Slf4j
@Component
@RequiredArgsConstructor
public class DhpoSoapClient {

    private final CloseableHttpClient http;

    public String callSoap11(String endpoint, String soapAction, String envelopeXml) {
        var req = new HttpPost(endpoint);
        req.setHeader(HttpHeaders.CONTENT_TYPE, "text/xml; charset=utf-8"); // SOAP 1.1
        req.setHeader(HttpHeaders.ACCEPT, "text/xml");
        if (soapAction != null && !soapAction.isBlank()) {
            // .asmx requires SOAPAction **quoted**
            req.setHeader("SOAPAction", "\"" + soapAction + "\"");
        }
        req.setEntity(new StringEntity(envelopeXml, StandardCharsets.UTF_8));

        try {
            return http.execute(req, (ClassicHttpResponse resp) -> {
                var sc = resp.getCode();
                var body = resp.getEntity() == null ? "" :
                        new String(resp.getEntity().getContent().readAllBytes(), StandardCharsets.UTF_8);
                log.info("soap.call status={} action={} endpoint={}", sc, soapAction, endpoint);
                if (sc >= 200 && sc < 300) return body;
                throw new IllegalStateException("SOAP HTTP " + sc + " body=" + body);
            });
        } catch (Exception e) {
            throw new IllegalStateException("SOAP call failed action=" + soapAction + " endpoint=" + endpoint, e);
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\config\DhpoClientProperties.java =====

package com.acme.claims.soap.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "dhpo.client")
public record DhpoClientProperties(
        boolean getNewEnabled,            // toggle GetNewTransactions
        int searchDaysBack,               // usually 100
        int retriesOnMinus4,              // agreed: 3
        int connectTimeoutMs,
        int readTimeoutMs,
        int downloadTimeoutMs,
        int stageToDiskThresholdMb        // when >= switch to disk
) {
    public DhpoClientProperties {
        if (retriesOnMinus4 < 0 || retriesOnMinus4 > 5) throw new IllegalArgumentException("retriesOnMinus4 out of range");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\config\HttpClientConfig.java =====

// src/main/java/com/acme/claims/soap/transport/HttpClientConfig.java
package com.acme.claims.soap.config;


import com.acme.claims.soap.SoapProperties;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.util.Timeout;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class HttpClientConfig {

    @Bean
    @Primary
    public CloseableHttpClient dhpoHttpClient(SoapProperties props) {
        var rc = RequestConfig.custom()
                .setConnectTimeout(Timeout.ofMilliseconds(props.connectTimeoutMs()))
                .setResponseTimeout(Timeout.ofMilliseconds(props.readTimeoutMs()))
                .build();

        return HttpClients.custom()
                .setDefaultRequestConfig(rc)
                .evictExpiredConnections()
                .evictIdleConnections(Timeout.ofSeconds(30))
                .build();
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\crypto\DhpoCredentialResolver.java =====

package com.acme.claims.soap.crypto;

import com.acme.claims.domain.model.entity.FacilityDhpoConfig;
import com.acme.claims.security.ame.AesGcmCrypto;
import com.acme.claims.security.ame.AmeKeyProvider;
import lombok.RequiredArgsConstructor;
import org.json.JSONObject;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Base64;

@Component
@Profile("soap")
@RequiredArgsConstructor
public class DhpoCredentialResolver {

    private final AmeKeyProvider ame; // present in your project; loads SecretKey when AME enabled

    public DhpoCredentials resolve(FacilityDhpoConfig f) {
        // enc_meta_json -> {kek_version, alg, iv, tagBits, keyId?}
        var meta = new JSONObject(f.getEncMetaJson());
        String ivB64 = meta.optString("iv", null);
        int tagBits = meta.optInt("tagBits", 128);
        String keyId  = meta.optString("kek_version", "v1");

        // If AME is disabled, assume plaintext was stored (you asked for “app-managed encryption”, but make it resilient)
        // check this : AmeKeyProvider#getKeyOrNull() must exist; if your class exposes SecretKey getKey(), just adapt to return null when disabled.
        SecretKey key = ame.getKey();
        if (key == null) {
            return new DhpoCredentials(new String(f.getDhpoUsernameEnc()), new String(f.getDhpoPasswordEnc()));
        }

        var userBlob = new AesGcmCrypto.Blob(Base64.getDecoder().decode(ivB64), f.getDhpoUsernameEnc(), tagBits, keyId);
        var passBlob = new AesGcmCrypto.Blob(Base64.getDecoder().decode(ivB64), f.getDhpoPasswordEnc(), tagBits, keyId);

        String user = new String(AesGcmCrypto.decrypt(key, userBlob, facilityAad(f)));
        String pass = new String(AesGcmCrypto.decrypt(key, passBlob, facilityAad(f)));
        return new DhpoCredentials(user, pass);
    }

    private byte[] facilityAad(FacilityDhpoConfig f) {
        // bind ciphertexts to facility_code as AAD for integrity
        return f.getFacilityCode() == null ? null : f.getFacilityCode().getBytes();
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\crypto\DhpoCredentials.java =====

package com.acme.claims.soap.crypto;

public record DhpoCredentials(String username, String password) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\db\FacilityConfigRepo.java =====

// src/main/java/com/acme/claims/soap/db/FacilityConfigRepo.java
package com.acme.claims.soap.db;

import lombok.Builder;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.DataClassRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
@RequiredArgsConstructor
public class FacilityConfigRepo {
    private final JdbcTemplate jdbc;

    public List<Facility> findActive() {
        return jdbc.query("""
      select facility_id, facility_code, facility_name, active,
             endpoint_url, soap_version_12, caller_license, e_partner,
             last_polled_at, last_success_at, last_error_code, breaker_open_until
        from claims.facility_dhpo_config
       where active = true
       order by facility_code
      """, new DataClassRowMapper<>(Facility.class));
    }

    @Builder
    public record Facility(
            Long facilityId,
            String facilityCode,
            String facilityName,
            Boolean active,
            String endpointUrl,
            Boolean soapVersion12,
            String callerLicense,
            String ePartner,
            String loginCt,
            String pwdCt,
            java.time.OffsetDateTime lastPolledAt,
            java.time.OffsetDateTime lastSuccessAt,
            Integer lastErrorCode,
            java.time.OffsetDateTime breakerOpenUntil
    ) {}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\db\ToggleRepo.java =====

// src/main/java/com/acme/claims/soap/db/ToggleRepo.java
package com.acme.claims.soap.db;

import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
@RequiredArgsConstructor
public class ToggleRepo {
    private final JdbcTemplate jdbc;

    public boolean isEnabled(String code) {
        Boolean v = jdbc.query("select enabled from claims.integration_toggle where code=?",
                ps -> ps.setString(1, code),
                rs -> rs.next() ? rs.getBoolean(1) : Boolean.FALSE);
        return Boolean.TRUE.equals(v);
    }

    public void setEnabled(String code, boolean enabled) {
        jdbc.update("""
      insert into claims.integration_toggle(code, enabled) values(?, ?)
      on conflict(code) do update set enabled=excluded.enabled, updated_at=now()
      """, code, enabled);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\fetch\DhpoFetchCoordinator.java =====

// src/main/java/com/acme/claims/soap/fetch/DhpoFetchCoordinator.java
package com.acme.claims.soap.fetch;

import com.acme.claims.domain.model.entity.FacilityDhpoConfig;
import com.acme.claims.domain.repo.FacilityDhpoConfigRepo;
import com.acme.claims.ingestion.fetch.soap.DhpoFetchInbox;
import com.acme.claims.metrics.DhpoMetrics;
import com.acme.claims.security.ame.CredsCipherService;
import com.acme.claims.soap.SoapProperties;
import com.acme.claims.soap.config.DhpoClientProperties;
import com.acme.claims.soap.db.ToggleRepo;
import com.acme.claims.soap.parse.DownloadFileParser;
import com.acme.claims.soap.parse.ListFilesParser;
import com.acme.claims.soap.req.DownloadTransactionFileRequest;
import com.acme.claims.soap.req.GetNewTransactionsRequest;
import com.acme.claims.soap.req.SearchTransactionsRequest;
import com.acme.claims.soap.transport.SoapCaller;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Slf4j
@Component
@Profile("soap")
@RequiredArgsConstructor
public class DhpoFetchCoordinator {

    //private final SoapGateway gateway;
    private final SoapCaller soapCaller;
    private final SoapProperties soapProps;
    private final FacilityDhpoConfigRepo facilities;
    private final ToggleRepo toggles;
    private final DhpoClientProperties dhpoProps;
    private final StagingService staging;
    private final CredsCipherService creds; // << use AME to decrypt per-facility
    private final DhpoFetchInbox inbox;
    private final DhpoFileRegistry fileRegistry;
    private final DhpoMetrics dhpoMetrics;

    @Value("${claims.fetch.stageToDisk.force:false}") boolean forceDisk;
    @Value("${claims.fetch.stageToDisk.sizeThresholdBytes:26214400}") long sizeThreshold;
    @Value("${claims.fetch.stageToDisk.latencyThresholdMs:8000}") long latencyThreshold;
    @Value("${claims.fetch.stageToDisk.readyDir:data/ready}") String readyDir;

    private static final DateTimeFormatter FMT = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

    // ===== Delta poll (GetNewTransactions) =====
    @Scheduled(fixedDelayString = "${claims.soap.poll.fixedDelayMs:1800000}", initialDelay = 0) // default 30 min
    public void pollNew() {
        // disabled via db - only admin can toggle it
        if (!toggles.isEnabled("dhpo.client.getNewEnabled")) {
            return;
        }
        var list = facilities.findByActiveTrue();
        for (var f : list) {
            try {
                processDelta(f);
            } catch (Exception e) {
                log.error("Facility {} delta poll failed: {}", f.getFacilityCode(), e.toString());
            }
        }
    }

    private void processDelta(FacilityDhpoConfig f) {
        var plain = creds.decryptFor(f); // decrypt once per facility per call
        var req = GetNewTransactionsRequest.build(plain.login(), plain.pwd(), false /*soap1.1*/);
        //var resp = gateway.call(req);
         var resp = soapCaller.call(req);

        var parsed = new ListFilesParser().parse(resp.envelopeXml());
        if (!handleResultCode("GetNewTransactions", parsed.code(), parsed.errorMessage(), f.getFacilityCode())) return;

        if (parsed.files().isEmpty()) {
            log.debug("Facility {}: no new transactions", f.getFacilityCode());
            return;
        }
        log.info("Facility {}: {} new items", f.getFacilityCode(), parsed.files().size());

        for (var row : parsed.files()) {
            // For GetNewTransactions DHPO typically returns isDownloaded=false; we download + stage all.
            downloadAndStage(f, row.fileId());
        }
    }

    // ===== Backfill/ops search (toggle) =====
    @Scheduled(fixedDelayString = "${claims.soap.poll.fixedDelayMs:1800000}", initialDelay = 5000)
    public void pollSearch() {
        var list = facilities.findByActiveTrue();
        for (var f : list) {
            try {
                // Two searches per facility: submissions(sent=2, direction=1) & remittances(received=8, direction=2)
                searchWindow(f, 1, 2);
                searchWindow(f, 2, 8);
            } catch (Exception e) {
                log.error("Facility {} search poll failed: {}", f.getFacilityCode(), e.toString());
            }
        }
    }

    private void searchWindow(FacilityDhpoConfig f, int direction, int transactionId) {
        var plain = creds.decryptFor(f);
        LocalDateTime to = LocalDateTime.now();
        LocalDateTime from = to.minusDays(100);

        var req = SearchTransactionsRequest.build(
                plain.login(), plain.pwd(), direction,
                f.getFacilityCode(), "",                            // callerLicense = facility_code, ePartner blank
                transactionId, 1,                                   // TransactionStatus=1 (new/undownloaded)
                FMT.format(from), FMT.format(to),
                1, 500, false /*soap1.1*/
        );
        //var resp = gateway.call(req);
        var resp = soapCaller.call(req);
        var parsed = new ListFilesParser().parse(resp.envelopeXml());
        if (!handleResultCode("SearchTransactions", parsed.code(), parsed.errorMessage(), f.getFacilityCode())) return;

        long candidates = parsed.files().stream().filter(fr -> fr.isDownloaded()==null || Boolean.FALSE.equals(fr.isDownloaded())).count();
        log.info("Facility {} Search dir={} tx={} candidates={}",
                f.getFacilityCode(), direction, transactionId, candidates);

        parsed.files().stream()
                .filter(fr -> fr.isDownloaded()==null || Boolean.FALSE.equals(fr.isDownloaded()))
                .forEach(fr -> downloadAndStage(f, fr.fileId()));
    }

    // ===== Download + dynamic staging =====
    private void downloadAndStage(FacilityDhpoConfig f, String fileId) {
        var plain = creds.decryptFor(f);
        long t0 = System.nanoTime();
        var req = DownloadTransactionFileRequest.build(plain.login(), plain.pwd(), fileId, false /*soap1.1*/);
        //var resp = gateway.call(req);
        var resp = soapCaller.call(req);
        long dlMs = (System.nanoTime() - t0) / 1_000_000;

        var parsed = new DownloadFileParser().parse(resp.envelopeXml());
        if (!handleResultCode("DownloadTransactionFile", parsed.code(), parsed.errorMessage(), f.getFacilityCode())) return;

        byte[] fileBytes = parsed.fileBytes();
        if (fileBytes.length == 0 || !new String(fileBytes, StandardCharsets.UTF_8).trim().startsWith("<")) {
            log.error("Facility {} fileId {}: downloaded bytes empty or not XML", f.getFacilityCode(), fileId);
            return;
        }

        var pol = new StagingPolicy(forceDisk, sizeThreshold, latencyThreshold, readyDir);
        try {
            var staged = staging.decideAndStage(fileBytes, parsed.fileName(), dlMs, pol);
            dhpoMetrics.recordDownload(f.getFacilityCode(), staged.mode().name().toLowerCase(),
                    fileBytes.length, dlMs);

            log.info("Facility {} fileId {} staged as {} (name={})", f.getFacilityCode(), fileId, staged.mode(), staged.fileId());
            // Hand-off to parser/persist remains in your existing flow.
            fileRegistry.remember(fileId, f.getFacilityCode());
            switch (staged.mode()) {
                case DISK -> inbox.submit(fileId, null, staged.path(), "soap"); // path-based
                case MEM  -> inbox.submitSoap(fileId, staged.bytes());          // in-memory
            }
            // NOTE: SetTransactionDownloaded will be invoked post-verify with **fieldId** (your rule).
        } catch (Exception e) {
            log.error("Facility {} fileId {} staging failed: {}", f.getFacilityCode(), fileId, e.toString());
        }
    }

    // ===== Common result handling (retry only on -4; transport retries live in SoapGateway) =====
    private boolean handleResultCode(String op, int code, String err, String facility) {
        if (code == Integer.MIN_VALUE) {
            log.error("Facility {} {}: missing result code", facility, op);
            return false;
        }
        if (code >= 0) { // success or no-data; >0 may be warnings
            if (code > 0 && err != null && !err.isBlank()) {
                log.info("{} facility {} returned warnings code={} msg={}", op, facility, code, err);
            }
            return true;
        }
        // error (<0): we only retry on transport or DHPO -4 at gateway level; coordinator logs and moves on
        log.warn("Facility {} {} error code={} msg={}", facility, op, code, err);
        return false;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\fetch\DhpoFileRegistry.java =====


package com.acme.claims.soap.fetch;

import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Bounded ephemeral map of fileId -> facilityCode for ACK.
 * Written by DhpoFetchCoordinator at download time, read by SoapAckerAdapter post-verify.
 */
@Component
@Profile("soap")
public class DhpoFileRegistry {
    private final Map<String, String> byFileId = new ConcurrentHashMap<>(4096);

    public void remember(String fileId, String facilityCode) {
        if (fileId != null && facilityCode != null) byFileId.put(fileId, facilityCode);
    }

    public Optional<String> facilityFor(String fileId) {
        return Optional.ofNullable(byFileId.get(fileId));
    }

    public void forget(String fileId) {
        if (fileId != null) byFileId.remove(fileId);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\fetch\SetDownloadedHook.java =====

// src/main/java/com/acme/claims/fetch/SetownloadedHook.java
package com.acme.claims.soap.fetch;

import com.acme.claims.domain.repo.FacilityDhpoConfigRepo;
import com.acme.claims.metrics.DhpoMetrics;
import com.acme.claims.security.ame.CredsCipherService;
import com.acme.claims.soap.db.ToggleRepo;
import com.acme.claims.soap.parse.SetDownloadedParser;
import com.acme.claims.soap.req.SetTransactionDownloadedRequest;
import com.acme.claims.soap.transport.SoapCaller;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@Profile("soap")
@RequiredArgsConstructor
public class SetDownloadedHook {

    // private final SoapGateway gateway;
    private final SoapCaller soapCaller;
    private final FacilityDhpoConfigRepo facilities;
    private final ToggleRepo toggles;
    private final CredsCipherService creds;
    private final DhpoMetrics dhpoMetrics;

    /**
     * Call from your Verify stage once the file is persisted and verified OK.
     * @param facilityCode which facility the file belongs to
     * @param fileId remote DHPO FileID (we store this alongside ingestion_file)
     */
    public void maybeMarkDownloaded(String facilityCode, String fileId) {
        if (!toggles.isEnabled("dhpo.setDownloaded.enabled")) {
            log.debug("SetDownloaded disabled; skipping for facility={} fileId={}", facilityCode, fileId);
            return;
        }
        var f = facilities.findByActiveTrue().stream()
                .filter(x -> x.getFacilityCode().equals(facilityCode)).findFirst()
                .orElse(null);
        if (f == null) {
            log.warn("SetDownloaded: no active facility for code={}", facilityCode);
            return;
        }
        try {
            var plain = creds.decryptFor(f);
            var req = SetTransactionDownloadedRequest.build(plain.login(), plain.pwd(), fileId, Boolean.FALSE);
            // var resp = gateway.call(req);
            var resp = soapCaller.call(req);
            var parsed = new SetDownloadedParser().parse(resp.envelopeXml());
            if (parsed.code() > 0 || parsed.code() == 0) {
                dhpoMetrics.recordAck(facilityCode, fileId, Boolean.TRUE, String.valueOf(parsed.code()));
                log.info("SetDownloaded OK facility={} fileId={} code={}", facilityCode, fileId, parsed.code());
            } else {
                log.warn("SetDownloaded FAIL facility={} fileId={} code={} msg={}", facilityCode, fileId, parsed.code(), parsed.errorMessage());
            }
        } catch (Exception e) {
            log.error("SetDownloaded EX facility={} fileId={} : {}", facilityCode, fileId, e.toString());
        }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\fetch\StagingPolicy.java =====

// src/main/java/com/acme/claims/fetch/StagingPolicy.java
package com.acme.claims.soap.fetch;

public record StagingPolicy(
        boolean forceDisk,
        long sizeThresholdBytes,
        long latencyThresholdMs,
        String readyDir
) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\fetch\StagingService.java =====

// src/main/java/com/acme/claims/fetch/StagingService.java
package com.acme.claims.soap.fetch;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.nio.file.*;
import java.security.MessageDigest;
import java.util.HexFormat;

@Slf4j
@Service
@RequiredArgsConstructor
public class StagingService {

    public enum Mode { MEM, DISK }

    public record Staged(Mode mode, String fileId, byte[] bytes, Path path) {}

    public Staged decideAndStage(byte[] bytes, String serverFileName, long downloadLatencyMs, StagingPolicy pol) throws Exception {
        boolean toDisk = pol.forceDisk()
                || bytes.length >= pol.sizeThresholdBytes()
                || downloadLatencyMs >= pol.latencyThresholdMs();
        String fileId = safeName(serverFileName);
        if (fileId == null) fileId = sha256Name(bytes);

        if (!toDisk) {
            return new Staged(Mode.MEM, fileId, bytes, null);
        }
        Path readyDir = Paths.get(pol.readyDir());
        Files.createDirectories(readyDir);
        Path tmp = readyDir.resolve(fileId + ".tmp");
        Path fin = readyDir.resolve(fileId);
        Files.write(tmp, bytes, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        Files.move(tmp, fin, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
        log.info("Staged to disk: {} ({} bytes)", fin.getFileName(), bytes.length);
        return new Staged(Mode.DISK, fileId, null, fin);
    }

    private static String safeName(String name) {
        if (name==null) return null;
        String n = name.trim();
        if (n.isBlank()) return null;
        if (!n.toLowerCase().endsWith(".xml")) return null;
        if (n.contains("/")||n.contains("\\")||n.contains("..")) return null;
        return n;
    }
    private static String sha256Name(byte[] bytes) throws Exception {
        var md = MessageDigest.getInstance("SHA-256");
        md.update(bytes);
        return HexFormat.of().formatHex(md.digest()) + ".xml";
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\parse\DownloadFileParser.java =====

// src/main/java/com/acme/claims/soap/parse/DownloadFileParser.java
package com.acme.claims.soap.parse;

import com.acme.claims.soap.util.Xmls;
import org.w3c.dom.Document;

public class DownloadFileParser {
    public record Result(int code, String fileName, byte[] fileBytes, String errorMessage) {}

    public Result parse(String soapEnvelope) {
        try {
            Document d = Xmls.parse(soapEnvelope);
            int code = toInt(Xmls.gl(d, "DownloadTransactionFileResult"));
            String name = Xmls.gl(d, "fileName");
            String b64  = Xmls.gl(d, "file");
            byte[] bytes = (b64 == null || b64.isBlank())
                    ? new byte[0]
                    : java.util.Base64.getMimeDecoder().decode(b64);
            String err = Xmls.gl(d, "errorMessage");
            return new Result(code, name, bytes, err);
        } catch (Exception ex) {
            throw new IllegalStateException("Parse download failed: " + ex.getMessage(), ex);
        }
    }
    private static int toInt(String s){ try{ return Integer.parseInt(s==null?"":s.trim()); } catch(Exception e){ return Integer.MIN_VALUE; } }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\parse\ListFilesParser.java =====

// src/main/java/com/acme/claims/soap/parse/ListFilesParser.java
package com.acme.claims.soap.parse;

import com.acme.claims.soap.util.Xmls;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.List;

public class ListFilesParser {

    public record FileRow(String fileId, String fileName, String senderId, String receiverId,
                          String transactionDate, Integer recordCount, Boolean isDownloaded) {}

    public record Result(int code, String errorMessage, List<FileRow> files) {}

    /**
     * Handles both GetNewTransactions (xmlTransactions) and SearchTransactions (foundTransactions).
     * Will look for either element; 'IsDownloaded' may be present only for Search.
     */
    public Result parse(String soapEnvelope) {
        try {
            Document d = Xmls.parse(soapEnvelope);
            int gCode = toInt(Xmls.gl(d, "GetNewTransactionsResult"));
            int sCode = toInt(Xmls.gl(d, "SearchTransactionsResult"));
            int code = (gCode != Integer.MIN_VALUE) ? gCode : (sCode != Integer.MIN_VALUE ? sCode : Integer.MIN_VALUE);
            String err = Xmls.gl(d, "errorMessage");

            String xml = Xmls.gl(d, "xmlTransaction");
            if (xml == null || xml.isBlank()) xml = Xmls.gl(d, "foundTransactions");

            List<FileRow> rows = new ArrayList<>();
            if (xml != null && !xml.isBlank() && xml.contains("<")) {
                Document li = Xmls.parse(xml);
                NodeList nl = li.getElementsByTagNameNS("*", "File");
                for (int i=0;i<nl.getLength();i++) {
                    var e = nl.item(i).getAttributes();
                    String fileId = e.getNamedItem("FileID").getNodeValue();
                    String fileName = attr(e,"FileName");
                    String sender = attr(e,"SenderID");
                    String receiver = attr(e,"ReceiverID");
                    String txDate = attr(e,"TransactionDate");
                    Integer rc = toIntOrNull(attr(e,"RecordCount"));
                    Boolean isDl = toBoolOrNull(attr(e,"IsDownloaded"));
                    rows.add(new FileRow(fileId, fileName, sender, receiver, txDate, rc, isDl));
                }
            }
            return new Result(code, err, rows);
        } catch (Exception ex) {
            throw new IllegalStateException("Parse list files failed: " + ex.getMessage(), ex);
        }
    }

    private static String attr(org.w3c.dom.NamedNodeMap a, String n) {
        var x = a.getNamedItem(n); return x==null?null:x.getNodeValue();
    }
    private static int toInt(String s){ try{ return Integer.parseInt(s==null?"":s.trim()); } catch(Exception e){ return Integer.MIN_VALUE; } }
    private static Integer toIntOrNull(String s){ try{ return s==null?null:Integer.parseInt(s.trim()); } catch(Exception e){ return null; } }
    private static Boolean toBoolOrNull(String s){ if (s==null) return null; return "true".equalsIgnoreCase(s) || "1".equals(s); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\parse\SetDownloadedParser.java =====

// src/main/java/com/acme/claims/soap/parse/SetDownloadedParser.java
package com.acme.claims.soap.parse;

import com.acme.claims.soap.util.Xmls;
import org.w3c.dom.Document;

public class SetDownloadedParser {
    public record Result(int code, String errorMessage) {}
    public Result parse(String soapEnvelope) {
        try {
            Document d = Xmls.parse(soapEnvelope);
            int code = toInt(Xmls.gl(d, "SetTransactionDownloadedResult"));
            String err = Xmls.gl(d, "errorMessage");
            return new Result(code, err);
        } catch (Exception ex) {
            throw new IllegalStateException("Parse set-downloaded failed: " + ex.getMessage(), ex);
        }
    }
    private static int toInt(String s){ try{ return Integer.parseInt(s==null?"":s.trim()); } catch(Exception e){ return Integer.MIN_VALUE; } }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\parse\SoapResult.java =====

package com.acme.claims.soap.parse;

import java.util.List;

public record SoapResult(
        int code,                // DHPO result code (0 OK, -4 transient, etc.)
        String errorMessage,     // optional
        String xmlPayload,       // e.g., xmlTransaction or foundTransactions
        List<SoapTxMeta> metas   // optional parsed rows (fileId, fileName, isDownloaded)
) {
    public boolean okOrNoData() { return code >= 0 || code == 2; } // 0 OK; 2 "no new" (per DHPO)
    public boolean shouldRetryTransient() { return code == -4; }   // DHPO transient error. :contentReference[oaicite:9]{index=9}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\parse\SoapTxMeta.java =====

package com.acme.claims.soap.parse;

public record SoapTxMeta(String fileId, String fileName, boolean isDownloaded) {}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\req\DhpoEnvelopes.java =====

// src/main/java/com/acme/claims/soap/DhpoEnvelopes.java
package com.acme.claims.soap.req;

public final class DhpoEnvelopes {
    private DhpoEnvelopes() {}

    // Minimal SOAP 1.1 envelope for SearchTransactions (matches your working client)
    public static String searchTransactions(String login, String password, String facilityCode) {
        return """
            <?xml version="1.0" encoding="utf-8"?>
            <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                           xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
              <soap:Body>
                <SearchTransactions xmlns="http://www.eClaimLink.ae/">
                  <login>%s</login>
                  <pwd>%s</pwd>
                  <FacilityID>%s</FacilityID>
                </SearchTransactions>
              </soap:Body>
            </soap:Envelope>
            """.formatted(escape(login), escape(password), escape(facilityCode));
    }

    // Very basic XML text escaper for credentials/ids
    private static String escape(String s) {
        if (s == null) return "";
        return s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"","&quot;")
                .replace("'","&apos;");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\req\DownloadTransactionFileRequest.java =====

// src/main/java/com/acme/claims/soap/req/DownloadTransactionFileRequest.java
package com.acme.claims.soap.req;

import com.acme.claims.soap.SoapGateway.SoapRequest;
import static com.acme.claims.soap.util.Xmls.xe;

public final class DownloadTransactionFileRequest {
    private DownloadTransactionFileRequest(){}

    private static final String ACTION = "http://www.eClaimLink.ae/DownloadTransactionFile";

    public static SoapRequest build(String login, String pwd, String fileId, boolean soap12) {
        String pfx="soap", ns="http://schemas.xmlsoap.org/soap/envelope/";
        if (soap12) { pfx="soap12"; ns="http://www.w3.org/2003/05/soap-envelope"; }
        String body = """
      <%s:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:%s="%s">
        <%s:Body>
          <DownloadTransactionFile xmlns="http://www.eClaimLink.ae/">
            <login>%s</login><pwd>%s</pwd><fileId>%s</fileId>
          </DownloadTransactionFile>
        </%s:Body>
      </%s:Envelope>
    """.formatted(pfx,pfx,ns,pfx,xe(login), xe(pwd), xe(fileId), pfx, pfx);
        return new SoapRequest("DownloadTransactionFile", soap12 ? null : ACTION, body);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\req\GetNewTransactionsRequest.java =====

// src/main/java/com/acme/claims/soap/req/GetNewTransactionsRequest.java
package com.acme.claims.soap.req;

import com.acme.claims.soap.SoapGateway.SoapRequest;
import static com.acme.claims.soap.util.Xmls.xe;

public final class GetNewTransactionsRequest {
    private GetNewTransactionsRequest(){}

    private static final String ACTION = "http://www.eClaimLink.ae/GetNewTransactions";

    public static SoapRequest build(String login, String pwd, boolean soap12) {
        String pfx="soap", ns="http://schemas.xmlsoap.org/soap/envelope/";
        if (soap12) { pfx="soap12"; ns="http://www.w3.org/2003/05/soap-envelope"; }
        String body = """
      <%s:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:%s="%s">
        <%s:Body>
          <GetNewTransactions xmlns="http://www.eClaimLink.ae/">
            <login>%s</login><pwd>%s</pwd>
          </GetNewTransactions>
        </%s:Body>
      </%s:Envelope>
    """.formatted(pfx,pfx,ns,pfx,xe(login),xe(pwd),pfx,pfx);
        return new SoapRequest("GetNewTransactions", soap12 ? null : ACTION, body);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\req\SearchTransactionsRequest.java =====

// src/main/java/com/acme/claims/soap/req/SearchTransactionsRequest.java
package com.acme.claims.soap.req;

import com.acme.claims.soap.SoapGateway.SoapRequest;
import static com.acme.claims.soap.util.Xmls.xe;

public final class SearchTransactionsRequest {
    private SearchTransactionsRequest(){}

    private static final String ACTION = "http://www.eClaimLink.ae/SearchTransactions";

    public static SoapRequest build(
            String login, String pwd, int direction, String callerLicense, String ePartner,
            int transactionID, Integer transactionStatus, String from, String to,
            Integer minRecordCount, Integer maxRecordCount, boolean soap12
    ) {
        String pfx="soap", ns="http://schemas.xmlsoap.org/soap/envelope/";
        if (soap12) { pfx="soap12"; ns="http://www.w3.org/2003/05/soap-envelope"; }
        String body = """
      <%s:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:%s="%s">
        <%s:Body>
          <SearchTransactions xmlns="http://www.eClaimLink.ae/">
            <login>%s</login><pwd>%s</pwd>
            <direction>%d</direction>
            <callerLicense>%s</callerLicense>
            <ePartner>%s</ePartner>
            <transactionID>%d</transactionID>
            <TransactionStatus>%s</TransactionStatus>
            <transactionFileName></transactionFileName>
            <transactionFromDate>%s</transactionFromDate>
            <transactionToDate>%s</transactionToDate>
            <minRecordCount>%s</minRecordCount>
            <maxRecordCount>%s</maxRecordCount>
          </SearchTransactions>
        </%s:Body>
      </%s:Envelope>
    """.formatted(pfx,pfx,ns,pfx,
                xe(login), xe(pwd),
                direction, xe(callerLicense), xe(ePartner),
                transactionID,
                transactionStatus==null?"":transactionStatus.toString(),
                xe(from), xe(to),
                minRecordCount==null?"":minRecordCount.toString(),
                maxRecordCount==null?"":maxRecordCount.toString(),
                pfx,pfx);
        return new SoapRequest("SearchTransactions", soap12 ? null : ACTION, body);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\req\SetTransactionDownloadedRequest.java =====

// src/main/java/com/acme/claims/soap/req/SetTransactionDownloadedRequest.java
package com.acme.claims.soap.req;

import com.acme.claims.soap.SoapGateway.SoapRequest;
import static com.acme.claims.soap.util.Xmls.xe;

public final class SetTransactionDownloadedRequest {
    private SetTransactionDownloadedRequest(){}

    private static final String ACTION = "http://www.eClaimLink.ae/SetTransactionDownloaded";

    public static SoapRequest build(String login, String pwd, String fileId, boolean soap12) {
        String pfx="soap", ns="http://schemas.xmlsoap.org/soap/envelope/";
        if (soap12) { pfx="soap12"; ns="http://www.w3.org/2003/05/soap-envelope"; }
        // Spec samples sometimes use <fieldId>; we’ll send <fileId> (works at DHPO)
        String body = """
      <%s:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:%s="%s">
        <%s:Body>
          <SetTransactionDownloaded xmlns="http://www.eClaimLink.ae/">
            <login>%s</login><pwd>%s</pwd><fieldId>%s</fieldId>
          </SetTransactionDownloaded>
        </%s:Body>
      </%s:Envelope>
    """.formatted(pfx,pfx,ns,pfx,xe(login), xe(pwd), xe(fileId), pfx, pfx);
        return new SoapRequest("SetTransactionDownloaded", soap12 ? null : ACTION, body);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\service\SetDownloadedService.java =====

package com.acme.claims.soap.service;

public interface SetDownloadedService {
    void markDownloaded(String facilityCode, String fieldId);
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\SoapConfig.java =====

// src/main/java/com/acme/claims/soap/SoapConfig.java
package com.acme.claims.soap;

import lombok.RequiredArgsConstructor;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.util.Timeout;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.soap.SoapVersion;
import org.springframework.ws.soap.saaj.SaajSoapMessageFactory;
import org.springframework.ws.transport.http.HttpComponents5MessageSender;

@Profile("soap")
@Configuration
@RequiredArgsConstructor
@EnableConfigurationProperties(SoapProperties.class)
public class SoapConfig {

    private final SoapProperties props; // @ConfigurationProperties(prefix="claims.soap")

    @Bean
    public SaajSoapMessageFactory messageFactory() {
        // Choose SOAP version via config; default to 1.1 if null/false
        SaajSoapMessageFactory mf = new SaajSoapMessageFactory();
        mf.setSoapVersion(Boolean.TRUE.equals(props.soap12())
                ? SoapVersion.SOAP_12
                : SoapVersion.SOAP_11);
        mf.afterPropertiesSet(); // initialize internal SAAJ MessageFactory
        return mf;
    }

    @Bean
    public CloseableHttpClient httpClient() {
        // HttpClient 5 requires Timeout objects (not int milliseconds)
        RequestConfig rc = RequestConfig.custom()
                .setConnectTimeout(Timeout.ofMilliseconds(props.connectTimeoutMs()))
                .setResponseTimeout(Timeout.ofMilliseconds(props.readTimeoutMs()))
                .build();

        return HttpClients.custom()
                .setDefaultRequestConfig(rc)
                .evictExpiredConnections()
                .build();
    }

    @Bean
    public HttpComponents5MessageSender httpSender(CloseableHttpClient httpClient) {
        HttpComponents5MessageSender sender = new HttpComponents5MessageSender();
        sender.setHttpClient(httpClient); // matches 5.x CloseableHttpClient
        return sender;
    }

    @Bean
    public WebServiceTemplate webServiceTemplate(
            SaajSoapMessageFactory messageFactory,
            HttpComponents5MessageSender httpSender
    ) {
        WebServiceTemplate tpl = new WebServiceTemplate();
        tpl.setMessageFactory(messageFactory);
        tpl.setMessageSender(httpSender);
        tpl.setDefaultUri(props.endpoint()); // base endpoint; per-call override allowed
        return tpl;
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\SoapGateway.java =====

// src/main/java/com/acme/claims/soap/SoapGateway.java
package com.acme.claims.soap;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;
import org.springframework.ws.client.core.WebServiceMessageCallback;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.soap.SoapMessage;
import org.springframework.xml.transform.StringSource;

import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;

@Slf4j
@Component
@Profile("soap")
@RequiredArgsConstructor
public class SoapGateway {
    private final WebServiceTemplate wst;
    private final SoapProperties props;

    public SoapResponse call(SoapRequest req) {
        int max = props.retry().maxAttempts() == null ? 1 : props.retry().maxAttempts();
        long backoff = props.retry().backoffMs() == null ? 0 : props.retry().backoffMs();

        int attempt = 0;
        RuntimeException last = null;
        while (attempt++ < max) {
            long t0 = System.nanoTime();
            try {
                var out = new StringWriter();
                var cb = (WebServiceMessageCallback) msg -> {
                    if (!Boolean.TRUE.equals(props.soap12()) && req.soapAction() != null && !req.soapAction().isBlank()) {
                        ((SoapMessage) msg).setSoapAction("\""+req.soapAction() +"\""); // SOAP 1.1 only
                        //msg.setProperty(org.springframework.ws.transport.TransportConstants.HEADER_CONTENT_TYPE, "text/xml; charset=utf-8");
                    }
                };
                log.info("SOAP call op={} action=\"{}\" soap12={}", req.operationName(), req.soapAction(), props.soap12());
                wst.sendSourceAndReceiveToResult(new StringSource(req.envelopeXml()), cb, new StreamResult(out));
                long ms = (System.nanoTime() - t0) / 1_000_000;
                log.debug("SOAP {} ok in {}ms action={}", req.operationName(), ms, req.soapAction());
                return new SoapResponse(req.operationName(), req.soapAction(), out.toString());
            } catch (RuntimeException ex) {
                last = ex;
                log.warn("SOAP transport failure op={} attempt={}/{} : {}", req.operationName(), attempt, max, ex.toString());
                if (attempt < max && backoff > 0) sleep(backoff * attempt);
            }
        }
        throw last != null ? last : new IllegalStateException("SOAP call failed");
    }

    private static void sleep(long ms) { try { Thread.sleep(ms); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } }

    public record SoapRequest(String operationName, String soapAction, String envelopeXml) {}
    public record SoapResponse(String operationName, String soapAction, String envelopeXml) {
        public byte[] bytes() { return envelopeXml.getBytes(StandardCharsets.UTF_8); }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\SoapProperties.java =====

// src/main/java/com/acme/claims/soap/SoapProperties.java
package com.acme.claims.soap;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "claims.soap")
public record SoapProperties(
        String endpoint,
        Boolean soap12, // false => SOAP 1.1
        Integer connectTimeoutMs,
        Integer readTimeoutMs,
        RetryProps retry,
        PollProps poll,
        String transport
) {
    public record RetryProps(Integer maxAttempts, Long backoffMs) {}
    public record PollProps(Integer fixedDelayMs) {}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\transport\HttpSoapCaller.java =====

// src/main/java/com/acme/claims/soap/transport/HttpSoapCaller.java
package com.acme.claims.soap.transport;


import com.acme.claims.soap.SoapGateway;
import com.acme.claims.soap.SoapProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.hc.client5.http.classic.methods.HttpPost;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.core5.http.ClassicHttpResponse;
import org.apache.hc.core5.http.ContentType;
import org.apache.hc.core5.http.HttpHeaders;
import org.apache.hc.core5.http.io.entity.StringEntity;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.time.Duration;

@Slf4j
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "claims.soap.transport", havingValue = "http")
public class HttpSoapCaller implements SoapCaller {

    private final CloseableHttpClient httpClient;      // define a @Bean elsewhere
    private final SoapProperties props;                // your existing properties holder

    @Override
    public SoapGateway.SoapResponse call(SoapGateway.SoapRequest req) {
        final String url = props.endpoint();

        final boolean soap12 = Boolean.TRUE.equals(props.soap12());
        final String action = req.soapAction(); // may be null for SOAP 1.2

        int attempt = 0;
        final int max = Math.max(1, props.retry().maxAttempts());
        final long backoffMs = Math.max(0, props.retry().backoffMs());

        Exception last = null;
        while (attempt++ < max) {
            long t0 = System.nanoTime();
            try {
                HttpPost post = new HttpPost(url);

                if (soap12) {
                    // SOAP 1.2 ? action lives in Content-Type param; SOAPAction header MUST NOT be sent
                    String ct = ContentType.create("application/soap+xml", StandardCharsets.UTF_8).toString();
                    if (action != null && !action.isBlank()) {
                        ct = ct + "; action=\"" + action + "\"";
                    }
                    post.setHeader(HttpHeaders.CONTENT_TYPE, ct);
                    post.setHeader(HttpHeaders.ACCEPT, "application/soap+xml, text/xml");
                } else {
                    // SOAP 1.1 ? must send quoted SOAPAction header + text/xml content-type
                    post.setHeader(HttpHeaders.CONTENT_TYPE, "text/xml; charset=utf-8");
                    post.setHeader(HttpHeaders.ACCEPT, "text/xml");
                    if (action != null && !action.isBlank()) {
                        post.setHeader("SOAPAction", "\"" + action + "\"");
                    }
                }

                post.setEntity(new StringEntity(req.envelopeXml(), StandardCharsets.UTF_8));

                String body = httpClient.execute(post, (ClassicHttpResponse resp) -> {
                    final int sc = resp.getCode();
                    final String respXml = (resp.getEntity() == null)
                            ? ""
                            : new String(resp.getEntity().getContent().readAllBytes(), StandardCharsets.UTF_8);
                    final long tookMs = Duration.ofNanos(System.nanoTime() - t0).toMillis();
                    log.info("soap.call transport=http op={} action={} status={} tookMs={} url={}",
                            req.operationName(), action, sc, tookMs, url);

                    if (sc >= 200 && sc < 300) return respXml;

                    // Retry on transient statuses
                    if (sc == 408 || sc == 429 || sc == 500 || sc == 502 || sc == 503 || sc == 504) {
                        throw new TransientStatusException("HTTP " + sc);
                    }
                    // Non-retryable: surface as-is
                    throw new NonRetryableStatusException("HTTP " + sc + " body=" + excerpt(respXml));
                });

                return new SoapGateway.SoapResponse(req.operationName(), action, body);

            } catch (TransientStatusException | java.io.IOException e) {
                last = e;
                if (attempt < max) {
                    log.warn("soap.call retryable op={} attempt={}/{} backoffMs={} cause={}",
                            req.operationName(), attempt, max, backoffMs, e.getMessage());
                    sleep(backoffMs);
                    continue;
                }
            } catch (NonRetryableStatusException e) {
                throw new IllegalStateException("SOAP non-retryable op=" + req.operationName() + " url=" + url + " : " + e.getMessage(), e);
            } catch (Exception e) {
                last = e;
                if (attempt < max) {
                    log.warn("soap.call retry op={} attempt={}/{} backoffMs={} cause={}",
                            req.operationName(), attempt, max, backoffMs, e.getMessage());
                    sleep(backoffMs);
                    continue;
                }
            }
            break;
        }
        throw new IllegalStateException("SOAP call failed op=" + req.operationName() + " url=" + url, last);
    }

    private static void sleep(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
    }

    private static String excerpt(String s) {
        if (s == null) return "";
        return s.length() <= 512 ? s : s.substring(0, 512) + "...";
    }

    private static final class TransientStatusException extends RuntimeException {
        TransientStatusException(String m){ super(m); }
    }
    private static final class NonRetryableStatusException extends RuntimeException {
        NonRetryableStatusException(String m){ super(m); }
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\transport\SoapCaller.java =====

// src/main/java/com/acme/claims/soap/transport/SoapCaller.java
package com.acme.claims.soap.transport;


import com.acme.claims.soap.SoapGateway;

public interface SoapCaller {
    SoapGateway.SoapResponse call(SoapGateway.SoapRequest req); // preserve existing DTOs
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\transport\WsSoapCaller.java =====

// src/main/java/com/acme/claims/soap/transport/WsSoapCaller.java
package com.acme.claims.soap.transport;


import com.acme.claims.soap.SoapGateway;
import com.acme.claims.soap.SoapProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.client.core.WebServiceMessageCallback;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.soap.SoapMessage;
import org.springframework.xml.transform.StringSource;

import java.time.Duration;

@Slf4j
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "claims.soap.transport", havingValue = "ws", matchIfMissing = true)
public class WsSoapCaller implements SoapCaller {

    private final WebServiceTemplate wst; // your existing WebServiceTemplate bean
    private final SoapProperties props;

    @Override
    public SoapGateway.SoapResponse call(SoapGateway.SoapRequest req) {
        final String url = props.endpoint();

        var src = new StringSource(req.envelopeXml());
        var res = new org.springframework.xml.transform.StringResult();

        final boolean soap12 = Boolean.TRUE.equals(props.soap12());
        final String action = req.soapAction();

        WebServiceMessageCallback cb = (WebServiceMessage msg) -> {
            if (!soap12 && action != null && !action.isBlank()) {
                // Spring-WS SOAP 1.1: set SOAPAction (note: transport header quoting is not exposed here)
                ((SoapMessage) msg).setSoapAction(action);
            }
        };

        int attempt = 0;
        final int max = Math.max(1, props.retry().maxAttempts());
        final long backoffMs = Math.max(0, props.retry().backoffMs());
        Exception last = null;

        while (attempt++ < max) {
            long t0 = System.nanoTime();
            try {
                wst.sendSourceAndReceiveToResult(url, src, cb, res);
                final long tookMs = Duration.ofNanos(System.nanoTime() - t0).toMillis();
                log.info("soap.call transport=ws op={} action={} status={} tookMs={} url={}",
                        req.operationName(), action, 200, tookMs, url);
                return new SoapGateway.SoapResponse(req.operationName(), action, res.toString());
            } catch (Exception ex) {
                last = ex;
                if (attempt < max) {
                    log.warn("soap.call retry op={} attempt={}/{} backoffMs={} cause={}",
                            req.operationName(), attempt, max, backoffMs, ex.getMessage());
                    try { Thread.sleep(backoffMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
                    continue;
                }
                break;
            }
        }
        throw new IllegalStateException("SOAP call failed op=" + req.operationName() + " url=" + url, last);
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\soap\util\Xmls.java =====

// src/main/java/com/acme/claims/soap/util/Xmls.java
package com.acme.claims.soap.util;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import javax.xml.parsers.DocumentBuilderFactory;
import java.nio.charset.StandardCharsets;

public final class Xmls {
    private Xmls(){}

    public static Document parse(String xml) throws Exception {
        var dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        return dbf.newDocumentBuilder().parse(new java.io.ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));
    }

    public static String gl(Document d, String localName) {
        var nl = d.getElementsByTagNameNS("*", localName);
        Node n = nl.getLength() > 0 ? nl.item(0) : null;
        return n == null ? null : n.getTextContent();
    }

    public static String xe(String s){
        return s == null ? "" : s.replace("&","&amp;").replace("<","&lt;").replace(">","&gt;");
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\util\FileDownloadCoordinator.java =====

package com.acme.claims.util;

/**
 * Coordinates downloading of claim/remittance XML files in parallel.
 *
 * - Launches async downloads for each fileId using FileFetchService.
 * - Limits concurrent in-flight requests via a Semaphore (default 200).
 * - Waits for all downloads to finish.
 * - Returns a Map<fileId, xmlOrError>.
 *
 * Guarantees:
 *   • For every input fileId, there will be exactly one output entry.
 *   • Even if a download fails, the map contains fileId ? "ERROR: ..." entry.
 */
//@Service
//@RequiredArgsConstructor
public class FileDownloadCoordinator {
//
//    private final FileFetchService fetchService;
//    private final Semaphore bulkhead = new Semaphore(200); // at most 200 inflight
//
//    /**
//     * Downloads all files by fileId, in parallel, with bulkhead limit.
//     *
//     * @param fileIdsWithName Map<fileId, fileName> from SearchTransactionsParser
//     * @return Map<fileId, xmlOrError>
//     */
//    public Map<String, String> fetchAll(Map<String, String> fileIdsWithName) {
//        if (fileIdsWithName == null || fileIdsWithName.isEmpty()) {
//            return Collections.emptyMap();
//        }
//
//        // Maintain the order of fileIds so we can recover keys if futures fail
//        List<String> order = new ArrayList<>(fileIdsWithName.keySet());
//
//        // Launch async calls
//        List<CompletableFuture<Map.Entry<String, String>>> futures = new ArrayList<>();
//        for (String fileId : order) {
//            try {
//                bulkhead.acquire();
//                futures.add(fetchService.fetchFile(fileId)
//                        .whenComplete((r, t) -> bulkhead.release()));
//            } catch (InterruptedException e) {
//                Thread.currentThread().interrupt();
//                futures.add(CompletableFuture.completedFuture(
//                        Map.entry(fileId, "ERROR: <interrupted/>")));
//            }
//        }
//
//        // Wait for all
//        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
//
//        // Collect results
//        Map<String, String> out = new LinkedHashMap<>();
//        for (int i = 0; i < futures.size(); i++) {
//            String fileId = order.get(i); // fallback key if future fails
//            CompletableFuture<Map.Entry<String, String>> f = futures.get(i);
//            try {
//                Map.Entry<String, String> e = f.get(); // already completed
//                out.put(e.getKey(), e.getValue());
//            } catch (Exception ex) {
//                out.put(fileId, "ERROR: <error>" + ex.getMessage() + "</error>");
//            }
//        }
//        return out;
//    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\util\SoapTestRunner.java =====

package com.acme.claims.util;

import org.springframework.boot.CommandLineRunner;

//@Component
//@Slf4j
//@Profile("local")
public class SoapTestRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {

    }
//    private final IngestSearchedTransactionSoapClient ingestSearchedTransactionSoapClient;
//    private final FileDownloadCoordinator downloadCoord;
//    private final ClaimSubmissionPersisterInsertOnly claimSubmissionPersister;
//    private final RemittancePersisterInsertOnly remittancePersister;
//
//    public SoapTestRunner(IngestSearchedTransactionSoapClient ingestSearchedTransactionSoapClient,
//                          FileDownloadCoordinator downloadCoord, ClaimSubmissionPersisterInsertOnly claimSubmissionPersister, RemittancePersisterInsertOnly remittancePersister) {
//        this.ingestSearchedTransactionSoapClient = ingestSearchedTransactionSoapClient;
//        this.downloadCoord = downloadCoord;
//        this.claimSubmissionPersister = claimSubmissionPersister;
//        this.remittancePersister = remittancePersister;
//    }
//
//    @Override
//    public void run(String... args) throws Exception {
//        try {
//            System.out.println("?? Sending SOAP request...");
//            //String response = client.searchTransactionsRaw();
//            // below makes SOAP call to fetch response which will have fileid, filename etc..
//            String response = ingestSearchedTransactionSoapClient.callSearchTransactions();
//            // now we are parsing that response to get fileid, filename
//            SearchTransactionsParser.ParseResult parsed = SearchTransactionsParser.parseFileIds(response);
//
//            System.out.println("Found " + parsed.fileIds.size() + " file IDs.");
//
//            System.out.println("? SOAP Response:\n" + response);
//            // parsed record has a map of fileid with their name
//            Map<String, String> fileIdsWithName = parsed.getFileIds();
//            System.out.println("?? FileIDs found: " + fileIdsWithName.size());
//            if (fileIdsWithName.isEmpty()) return;
//
//            // 3) Async fan-out: download each file
//            // you need to go into this method call to see that we are downloading each file via fileid in async manner
//            // the downloaded file is parsed and stored, and return along with file id <fileid, payload(parsed)
//            Map<String, String> fileIdToXml = downloadCoord.fetchAll(fileIdsWithName);
//            System.out.println("? Downloads done. Map size = " + fileIdToXml.size());
//            int successfulDownloads = getSuccessCount(fileIdToXml);
//            int failedDownloads = fileIdToXml.size() - successfulDownloads;
//            // for successful download mark as true
//            log.info(STR."Success: \{successfulDownloads}, Failed: \{failedDownloads}");
//            fileIdToXml = getSuccessXmls(fileIdToXml);
//            // now we have successful response i.e. fileId for which we got success and parsed response
//            // now we need to convert each parsed xml into respective dto using respective mapper, then we are calling persist
//            fileIdToXml.forEach((fid, payload) -> {
//                if (payload.startsWith("ERROR:")) {
//                    // skip, or record a light row later when we enable file-tracking
//                    return;
//                }
//                try {
//                    Document doc = XmlUtil.parse(payload);
//                    String root = doc.getDocumentElement().getNodeName();
//                    if("Claim.Submission".equalsIgnoreCase(root)) {
//                        ClaimSubmissionDto claimSubmissionDto = XmlToClaimSubmissionDtoMapper.toDto(XmlUtil.parse(payload));
//                        claimSubmissionPersister.persist(getIngestionFileEntity(claimSubmissionDto, fid, fileIdsWithName, payload), claimSubmissionDto);
//                    } else if ("Remittance.Advice".equalsIgnoreCase(root)) {
//                        RemittanceAdviceDto remittanceAdviceDto = XmlToRemittanceDtoMapper.toDto(doc);
//                        remittancePersister.persist(getIngestionFileEntity(remittanceAdviceDto, fid, fileIdsWithName, payload), remittanceAdviceDto);
//                    }
//                    //ingestSearchedTransactionSoapClient.setTrueForSuccessfulDownloads(fid);
//                } catch (Exception e) {
//                    // log error; we can move to a DLQ/retry later
//                    log.error("Exception : {}", e.getMessage());
//                    System.err.println("Persist failed for " + fid + ": " + e.getMessage());
//                }
//            });
//
//            // 4) (Optional) Print a couple for sanity
////            fileIdToXml.entrySet().stream().limit(2).forEach(e -> {
////                System.out.println("— FileID: " + e.getKey());
////                System.out.println("  Payload (first 400 chars): " + e.getValue().substring(0, Math.min(400, e.getValue().length())));
////            });
//            summarizeResults(fileIdToXml);
//        } catch (Exception e) {
//            System.err.println("? SOAP call failed: " + e.getMessage());
//            e.printStackTrace();
//        }
//    }
//
//    private IngestionFileEntity getIngestionFileEntity(RemittanceAdviceDto remittanceAdviceDto, String fid, Map<String, String> fileIdsWithName, String payload) {
//        if(remittanceAdviceDto != null){
//            return IngestionFileEntity.builder()
//                    .fileId(fid)
//                    .fileName(fileIdsWithName.get(fid))
//                    .downloadMarked((short) 0)
//                    .xmlBytes(payload.getBytes())
//                    .senderId(remittanceAdviceDto.getSenderId())
//                    .transactionDate(remittanceAdviceDto.getTransactionDate())
//                    .receiverId(remittanceAdviceDto.getReceiverId())
//                    .recordCountHint(remittanceAdviceDto.getRecordCount())
//                    .build();
//        }
//        return  null;
//    }
//
//    private IngestionFileEntity getIngestionFileEntity(ClaimSubmissionDto claimSubmissionDto, String fid, Map<String, String> fileIdsWithName, String payload) {
//        if(claimSubmissionDto != null) {
//            return IngestionFileEntity.builder()
//                    .fileId(fid)
//                    .fileName(fileIdsWithName.get(fid))
//                    .downloadMarked((short) 0)
//                    .xmlBytes(payload.getBytes())
//                    .senderId(claimSubmissionDto.getSenderId())
//                    .transactionDate(claimSubmissionDto.getTransactionDate())
//                    .receiverId(claimSubmissionDto.getReceiverId())
//                    .recordCountHint(claimSubmissionDto.getRecordCount())
//                    .build();
//        }
//        return null;
//    }
//
//    private Map<String, String> getSuccessXmls(Map<String, String> fileIdToXml) {
//        if (CollectionUtils.isEmpty(fileIdToXml)) {
//            return Collections.emptyMap();
//        }
//
//        return fileIdToXml.entrySet()
//                .stream()
//                .filter(e -> {
//                    String v = e.getValue();
//                    return v != null && !v.startsWith("ERROR"); // keep only non-ERROR
//                })
//                .collect(Collectors.toMap(
//                        Map.Entry::getKey,
//                        Map.Entry::getValue,
//                        (a, b) -> a,
//                        LinkedHashMap::new
//                ));
//    }
//
//
//    private int getSuccessCount(Map<String, String> fileIdToXml) {
//        if (!CollectionUtils.isEmpty(fileIdToXml.values())) {
//            long errorCount = fileIdToXml.values().stream()
//                    .filter(v -> v != null && v.startsWith("ERROR:"))
//                    .count();
//            return Math.toIntExact(fileIdToXml.size() - errorCount);
//        }
//        return 0;
//    }
//
//    public void summarizeResults(Map<String, String> fileIdToResponse) {
//        long errorCount = fileIdToResponse.values().stream()
//                .filter(v -> v != null && v.startsWith("ERROR:"))
//                .count();
//
//        long successCount = fileIdToResponse.size() - errorCount;
//
//        System.out.println("?? Download summary:");
//        System.out.println("   ? Success: " + successCount);
//        System.out.println("   ? Failed : " + errorCount);
//    }

}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\util\StopWatchLog.java =====

package com.acme.claims.util;

import lombok.extern.slf4j.Slf4j;

import java.time.Duration;
import java.time.Instant;
import java.util.function.Supplier;

/**
 * Measures and logs elapsed time for a task without leaking exceptions.
 */
@Slf4j
public final class StopWatchLog {

    private StopWatchLog() { }

    public static <T> T time(String label, Supplier<T> task) {
        final Instant start = Instant.now();
        try {
            T result = task.get();
            log.info("[STOPWATCH] {} took {} ms", label, Duration.between(start, Instant.now()).toMillis());
            return result;
        } catch (RuntimeException ex) {
            log.warn("[STOPWATCH] {} failed after {} ms: {}", label,
                    Duration.between(start, Instant.now()).toMillis(), ex.getMessage());
            throw ex; // rethrow for upstream handling
        }
    }

    public static void run(String label, Runnable task) {
        time(label, () -> { task.run(); return null; });
    }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\util\XmlUtil.java =====

package com.acme.claims.util;

import lombok.SneakyThrows;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.security.MessageDigest;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Base64;

public class XmlUtil {
    private static final XPathFactory XPF = XPathFactory.newInstance();
    private static final DocumentBuilderFactory DBF = DocumentBuilderFactory.newInstance();
    private static final DateTimeFormatter DMY_HM = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
    private static final DateTimeFormatter[] DTF = new DateTimeFormatter[] {
            DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"),
            DateTimeFormatter.ofPattern("dd/MM/yyyy")
    };

    static {
        DBF.setNamespaceAware(true);
        DBF.setIgnoringComments(true);
    }
    public static String toString(Node node) {
        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            StringWriter writer = new StringWriter();
            transformer.transform(new DOMSource(node), new StreamResult(writer));
            return writer.toString();
        } catch (Exception e) {
            throw new RuntimeException("Error converting XML to String", e);
        }
    }

    public static byte[] b64(String s) {
        if (s == null || s.isBlank()) return null;
        return Base64.getDecoder().decode(s.trim());
    }
    public static BigDecimal decimal(String s) {
        if (s == null || s.isBlank()) return null;
        return new BigDecimal(s.trim());
    }


    public static OffsetDateTime time(String s) {
        if (s == null || s.isBlank()) return null;
        for (DateTimeFormatter f : DTF) {
            try {
                LocalDateTime ldt = LocalDateTime.parse(s.trim(), f);
                return ldt.atZone(ZoneId.systemDefault()).toOffsetDateTime();
            } catch (Exception ignore) {}
        }
        return null;
    }

    @SneakyThrows
    public static String sha256(byte[] bytes) {
        if (bytes == null) return null;
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] d = md.digest(bytes);
        StringBuilder sb = new StringBuilder(d.length * 2);
        for (byte b : d) sb.append(String.format("%02x", b));
        return sb.toString();
    }

    public static Document parse(String xml) {
        if (xml == null) return null;
        String cleaned = stripUnknownPrefixes(xml);

        try {
            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
            f.setNamespaceAware(true);
            // secure processing
            f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);
            f.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            f.setExpandEntityReferences(false);

            DocumentBuilder b = f.newDocumentBuilder();
            try (java.io.StringReader r = new java.io.StringReader(cleaned)) {
                org.xml.sax.InputSource is = new org.xml.sax.InputSource(r);
                return b.parse(is);
            }
        } catch (Exception e) {
            throw new RuntimeException("XML parse failed: " + e.getMessage(), e);
        }
    }

    private static String stripUnknownPrefixes(String xml) {
        String s = xml.replace("\uFEFF", ""); // strip BOM if present

        // Common undeclared prefix patterns in test fixtures: ns1:, ns2:, soap:, tns:
        // Remove prefix from element names
        s = s.replaceAll("<(/?)ns\\d+:", "<$1");
        s = s.replaceAll("<(/?)(soap|tns):", "<$1");

        // Remove xmlns:* declarations for those if present but broken
        s = s.replaceAll("\\sxmlns:ns\\d+=\"[^\"]*\"", "");
        s = s.replaceAll("\\sxmlns:(soap|tns)=\"[^\"]*\"", "");

        // If the root itself is prefixed (e.g., <ns1:Claim.Submission ...>), also strip in-place tag
        // The above rules already handle it, but this keeps things extra safe.

        return s;
    }

    public static Document parse(byte[] xml) {
        if (xml == null) return null;
        return parse(new String(xml, java.nio.charset.StandardCharsets.UTF_8));
    }




    public static XPath xpath() {
        return XPathFactory.newInstance().newXPath();
    }

    public static String parseEncodedXml(String xml) {
        // get content of file tag
        try {
            Document doc = XmlUtil.parse(xml);
            String fileContent = XmlUtil.xpath().evaluate("//*[local-name()='file']", doc);
            if (fileContent != null && !fileContent.isBlank()) {
                return new String(Base64.getDecoder().decode(fileContent));
            }
            return null;
        } catch (Exception ignore) {}
        return null;
    }

    public static byte[] parseAttachment(String xml) {
        // get content of file tag
        try {
            Document doc = XmlUtil.parse(xml);
            String fileContent = XmlUtil.xpath().evaluate("//*[local-name()='Attachment']", doc);
            if (fileContent != null && !fileContent.isBlank()) {
                return (Base64.getDecoder().decode(fileContent));
            }
            return null;
        } catch (Exception ignore) {}
        return null;
    }

    public static String text(Node ctx, String path) {
        try {
            return xpath().evaluate(path, ctx);
        } catch (Exception e) {
            return null;
        }
    }

    public static LocalDateTime timeNoZone(String text) {
        if (text == null || text.isBlank()) return null;
        String s = text.trim();
        // primary pattern: dd/MM/yyyy HH:mm
        try {
            return LocalDateTime.parse(s, DMY_HM);
        } catch (Exception ignore) { }
        // secondary common variations
        try {
            return LocalDateTime.parse(s, DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"));
        } catch (Exception ignore) { }
        // last resort: if an ISO-like string sneaks in without zone
        try {
            return LocalDateTime.parse(s);
        } catch (Exception ignore) { }
        // give up quietly (keeps ingestion robust)
        return null;
    }

    public static java.time.LocalDateTime timeLocal(String s) {
        if (s == null || s.isBlank()) return null;
        String v = s.trim();
        // common DHA formats: "dd/MM/yyyy HH:mm" or "dd/MM/yyyy"
        java.time.format.DateTimeFormatter dt = java.time.format.DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
        java.time.format.DateTimeFormatter d = java.time.format.DateTimeFormatter.ofPattern("dd/MM/yyyy");
        try {
            if (v.length() <= 10) { // "dd/MM/yyyy"
                return java.time.LocalDate.parse(v, d).atStartOfDay();
            }
            return java.time.LocalDateTime.parse(v, dt);
        } catch (Exception e) {
            // last resort: try ISO-8601 without zone
            try { return java.time.LocalDateTime.parse(v); } catch (Exception ignore) { return null; }
        }
    }



}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\validator\DtoValidator.java =====

// FILE: src/main/java/com/acme/claims/ingestion/validate/DtoValidator.java
// Version: v1.0.0
// Validates required XSD fields and cross-record rules (counts, uniqueness).
// Sources: DHPO XSDs for required minOccurs=1 fields. :contentReference[oaicite:6]{index=6} :contentReference[oaicite:7]{index=7}
package com.acme.claims.validator;

import com.acme.claims.domain.model.dto.*;
import org.springframework.util.CollectionUtils;


import java.util.*;

public class DtoValidator {

    // --- Submission ---
    public void validate(SubmissionDTO dto) {
        if (dto == null) throw new IllegalArgumentException("SubmissionDTO is null");
        var h = dto.header();
        require(h.senderId(), "Header.SenderID");
        require(h.receiverId(), "Header.ReceiverID");
        require(h.transactionDate(), "Header.TransactionDate");
        require(h.dispositionFlag(), "Header.DispositionFlag");

        List<SubmissionClaimDTO> claims = orEmpty(dto.claims());
        if (claims.isEmpty()) fail("RecordCount>0 expected but claims list is empty");
        // if (h.recordCount() != claims.size()) fail("Header.RecordCount != number of Claim elements");

        for (SubmissionClaimDTO c : claims) {
            require(c.id(), "Claim.ID");
            require(c.payerId(), "Claim.PayerID");
            require(c.providerId(), "Claim.ProviderID");
            require(c.emiratesIdNumber(), "Claim.EmiratesIDNumber");
            require(c.gross(), "Claim.Gross");
            require(c.patientShare(), "Claim.PatientShare");
            require(c.net(), "Claim.Net");

            if (c.encounter() != null) {
                var e = c.encounter();
                require(e.facilityId(), "Encounter.FacilityID");
                require(e.type(), "Encounter.Type");
                require(e.patientId(), "Encounter.PatientID");
                require(e.start(), "Encounter.Start");
            }

            if(!CollectionUtils.isEmpty(c.diagnoses())){
                for(var d : c.diagnoses()){
                    require(d.code(), "Diagnoses.Code");
                    require(d.type(), "Diagnoses.Type");
                }
            }

            // Activities (minOccurs=1)
            var acts = orEmpty(c.activities().stream().toList());
            if (acts.isEmpty()) fail("Claim.Activity must have at least one entry for Claim.ID=" + c.id());
            // ensureUnique(acts.stream().map(ActivityDTO::id).toList(), "Activity.ID duplicate in Claim.ID=" + c.id());

            for (ActivityDTO a : acts) {
                require(a.id(), "Activity.ID");
                require(a.start(), "Activity.Start");
                require(a.type(), "Activity.Type");
                require(a.code(), "Activity.Code");
                require(a.quantity(), "Activity.Quantity");
                require(a.net(), "Activity.Net");
                require(a.clinician(), "Activity.Clinician");
                // Observations are optional; when present, Type & Code are required
                for (ObservationDTO o : orEmpty(a.observations().stream().toList())) {
                    require(o.type(), "Observation.Type");
                    require(o.code(), "Observation.Code");
                }
            }
            if (c.resubmission() != null) {
                require(c.resubmission().type(), "Resubmission.Type");
                require(c.resubmission().comment(), "Resubmission.Comment");
                // require(c.resubmission().attachment(), "Resubmission.Attachment");
            }
        }
    }

    // --- Remittance ---
    public void validate(RemittanceAdviceDTO dto) {
        if (dto == null) throw new IllegalArgumentException("RemittanceAdviceDTO is null");
        var h = dto.header();
        require(h.senderId(), "Header.SenderID");
        require(h.receiverId(), "Header.ReceiverID");
        require(h.transactionDate(), "Header.TransactionDate");
        require(h.dispositionFlag(), "Header.DispositionFlag");

        List<RemittanceClaimDTO> claims = orEmpty(dto.claims());
        if (claims.isEmpty()) fail("RecordCount>0 expected but remittance claims list is empty");
        // if (h.recordCount() != claims.size()) fail("Header.RecordCount != number of Remittance Claim elements");

        for (RemittanceClaimDTO c : claims) {
            require(c.id(), "Claim.ID");
            require(c.idPayer(), "Claim.IDPayer");
            require(c.paymentReference(), "Claim.PaymentReference");
            // facilityId is optional per XSD (Encounter/FacilityID is 0..1)  :contentReference[oaicite:8]{index=8}

            var acts = orEmpty(c.activities());
            if (acts.isEmpty()) fail("Remittance Claim.Activity must have at least one entry for Claim.ID=" + c.id());
            ensureUnique(acts.stream().map(RemittanceActivityDTO::id).toList(), "Remittance Activity.ID duplicate in Claim.ID=" + c.id());

            for (RemittanceActivityDTO a : acts) {
                require(a.id(), "Activity.ID");
                require(a.start(), "Activity.Start");
                require(a.type(), "Activity.Type");
                require(a.code(), "Activity.Code");
                require(a.quantity(), "Activity.Quantity");
                require(a.net(), "Activity.Net");
                require(a.clinician(), "Activity.Clinician");
                require(a.paymentAmount(), "Activity.PaymentAmount");
            }
        }
    }

    // --- helpers ---
    private static <T> List<T> orEmpty(List<T> l){ return l==null? List.of() : l; }
    private static void require(Object v, String path){
        if (v==null || (v instanceof String s && s.isBlank()))
            throw new IllegalArgumentException("Required field missing: " + path);
    }
    private static void ensureUnique(List<String> keys, String context){
        Set<String> seen = new HashSet<>();
        for (String k: keys){
            if (k==null) continue;
            if (!seen.add(k)) throw new IllegalArgumentException("Duplicate key: " + k + " (" + context + ")");
        }
    }
    private static void fail(String m){ throw new IllegalArgumentException(m); }
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\java\com\acme\claims\web\ClaimController.java =====

package com.acme.claims.web;

//@RestController
//@RequestMapping("/api/claims")
//@RequiredArgsConstructor
public class ClaimController {
//	@Autowired
//	private ClaimService service;
//
//	@GetMapping
//	public Page<ClaimEntity> search(@RequestParam Optional<String> idPayer, @RequestParam Optional<String> providerId,
//                                    Pageable pageable) {
//		return service.search(idPayer, providerId, pageable);
//	}
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\application.yml =====

spring:
  application:
    name: claims-app
  main:
    allow-bean-definition-overriding: false   # fail fast if a bean is defined twice
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none                          # no schema mutations
    properties:
      hibernate:
        default_schema: claims                # matches DDL
        jdbc:
          batch_size: 100
        order_inserts: true
        order_updates: true

# Flyway stays off by default; enable in prod profile
flyway:
  enabled: false

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,loggers,threaddump,env,configprops

logging:
  level:
    com.acme.claims: INFO                     # orchestrator/fetcher/pipeline visibility
    org.springframework.scheduling: INFO
    org.hibernate.SQL: INFO
    org.hibernate.orm.jdbc.bind: INFO

claims:
  refdata:
    bootstrap:
      enabled: false                           # profiles override
      strict: false
      location: classpath:refdata/
      delimiter: ','
      batch-size: 500
    auto-insert: true                          # profiles override



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\application-localfs.yml =====

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/claims
    username: claims_user
    password: securepass
    hikari:
      maximum-pool-size: 12
      minimum-idle: 3
      auto-commit: false
      connection-timeout: 30000
      leak-detection-threshold: 15000

  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none

  # (Optional) Flyway: keep disabled during dev unless you want migrations to run locally
  flyway:
    enabled: false

  main:
    allow-bean-definition-overriding: true
  cache:
    type: simple

logging:
  level:
    com.acme.claims: DEBUG
    org.springframework.jdbc.core.JdbcTemplate: INFO
    org.springframework.ws: WARN

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,env,threaddump,loggers"
  endpoint:
    health:
      probes:
        enabled: true

# ================== CLAIMS APP ==================
claims:
  metrics:
    batch:
      enabled: true
  ingestion:
    # our logical profile switch that IngestionConfig uses to select Fetcher/Acker beans
    profile: localfs

    # Scheduler cadence (fast for dev)
    scheduler:
      fixedDelayString: "PT10S"          # every 10s
      initialDelayString: "PT0S"

    # Local filesystem fetcher config (only this fetcher is active under 'localfs')
    localfs:
      readyDir: ${CLAIMS_LOCALFS_WATCH:data/ready}
      archiveOkDir: ${CLAIMS_LOCALFS_ARCHIVE:data/archive/done}
      archiveFailDir: ${CLAIMS_LOCALFS_ERROR:data/archive/error}

    # ACK policy (default OFF per requirements)
    ack:
      enabled: false

    # Threading (executor used by orchestrator/pipeline)
    executor:
      core-pool-size: 2
      max-pool-size: 4
      queue-capacity: 100
    poll:
      fixedDelayMs: ${INGESTION_POLL_MS:20000}   # 20s default

  parser:
    allowNonSchemaAttachments: false
    maxAttachmentBytes: 10485760         # 10MB
    failOnXsdError: false


  # ===== Refdata & Bootstrap =====
  refdata:
    auto-insert: true                    # local: insert-on-miss to keep dev smooth
  bootstrap:
    enabled: false                       # keep OFF locally unless testing CSV
    csv-path: "classpath:refdata/"       # your CSVs are already under resources/refdata

# Optional simple cache tuning for refdata lookups (if you use Spring Cache)



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\application-prod.yml =====

spring:
  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/claims}          # e.g. jdbc:postgresql://db:5432/claims
    username: ${DB_USER:claims_user}
    password: ${DB_PASSWORD:securepass}
    hikari:
      maximum-pool-size: 30
      minimum-idle: 8
      auto-commit: true
      connection-timeout: 15000
      validation-timeout: 5000

  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none
    properties:
      hibernate.jdbc.batch_size: 200
      hibernate.order_inserts: true
      hibernate.order_updates: true

  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

  main:
    allow-bean-definition-overriding: false
  cache:
    type: caffeine
  caffeine:
    spec: maximumSize=20000,expireAfterAccess=30m,recordStats

logging:
  pattern:
    console: "%d{ISO8601} %-5level [%thread] %logger{36} - %msg%n"
  level:
    com.acme.claims: INFO
    org.springframework.jdbc.core.JdbcTemplate: INFO
    org.springframework.ws.client: INFO
    org.springframework.web: INFO

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,prometheus,threaddump,env,loggers"
  endpoint:
    health:
      probes:
        enabled: true
  prometheus:
    metrics:
      export:
        enabled: true

# ================== CLAIMS APP ==================
claims:
  ingestion:
    # SOAP profile in prod – IngestionConfig ensures only a single fetcher/acker is active
    profile: soap
    localfs:
      archive-fail-dir: ./data/archive/fail
      archive-ok-dir: ./data/archive/ok

    scheduler:
      fixedDelayString: "PT2M"            # poll every 2 minutes
      initialDelayString: "PT0S"

    # SOAP fetcher / acker config
    soap:
      endpoint: ${DHPO_SOAP_ENDPOINT}     # e.g. https://dhpo.example/soap
      username: ${DHPO_SOAP_USER}
      password: ${DHPO_SOAP_PASSWORD}
      connect-timeout-ms: 5000
      read-timeout-ms: 15000
      # optional TLS trust/key settings can be added here

    ack:
      enabled: true                       # best-effort after success (per requirements)

    executor:
      core-pool-size: 6
      max-pool-size: 12
      queue-capacity: 1000
    poll:
      fixedDelayMs: ${INGESTION_POLL_MS:20000}   # 20s default

  parser:
    allowNonSchemaAttachments: false
    maxAttachmentBytes: 10485760
    failOnXsdError: true                  # stricter in prod


  # ===== Refdata & Bootstrap =====
  refdata:
    # Start with true to auto-seed on first sightings; flip to false once dictionaries are governed
    auto-insert: true
  bootstrap:
    enabled: false                        # prod CSV Bootstrap is typically OFF; run migrations instead
    csv-path: "classpath:refdata/"

# Optional: enable a real cache for ref lookups in prod (Caffeine)
claims.security.ame:
  enabled: true
  keystore:
    type: "PKCS12"                    # or "PKCS12" or "FILE"
    path: "file:config/claims.p12" # or "file:config/claims.p12" or "file:config/ame.key"
    alias: "claims-ame"
    passwordEnv: "CLAIMS_AME_STORE_PASS"   # only store/pass are env-based
  crypto:
    kekRotationAllowed: true
    gcmTagBits: 128
    keyId : claims-ame.v1 #  used in enc_meta to mark which key encrypted the row



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\application-soap.yml =====

# src/main/resources/application.yml (excerpt)
spring:
  task:
    execution:
      pool:
        core-size: 8
        max-size: 16

claims:
  soap:
    transport: http
    endpoint: "https://dhpo.eclaimlink.ae/validateTransactions.asmx"
    # SOAP 1.1 default (SOAPAction is set). Keep switch if you ever need 1.2 later.
    soap12: false
    connectTimeoutMs: 15000
    readTimeoutMs: 120000   # longer reads for Download
    retry:
      maxAttempts: 3        # 1 retry total
      backoffMs: 500
    poll:
      fixedDelayMs: 4000    # 4s between delta polls per facility
  fetch:
    stageToDisk:
      force: false          # global override
      sizeThresholdBytes: 26214400  # 25 MB ? disk
      latencyThresholdMs: 8000      # >8s download ? disk
      readyDir: "data/ready"

# env defaults (may be overridden by DB per facility)
#DHPO_DEFAULT_LOGIN: "env-user"
#DHPO_DEFAULT_PWD: "env-pass"

dhpo:
  client:
    getNewEnabled: false
    searchDaysBack: 100
    retriesOnMinus4: 3
    connectTimeoutMs: 6000
    readTimeoutMs: 15000
    downloadTimeoutMs: 120000
    stageToDiskThresholdMb: 25

claims.security.ame:
  enabled: true
  keystore:
    type: "PKCS12"                    # or "PKCS12" or "FILE"
    path: "file:config/claims.p12" # or "file:config/claims.p12" or "file:config/ame.key"
    alias: "claims-ame"
    passwordEnv: "CLAIMS_AME_STORE_PASS"   # only store/pass are env-based
  crypto:
    kekRotationAllowed: true
    gcmTagBits: 128
    keyId : claims-ame.v1 #  used in enc_meta to mark which key encrypted the row



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\application-test.yml =====

spring:
  # Prevent accidental DB auto-config when tests don't supply a datasource
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      - org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration

  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none  # matches base; tests/E2E keep schema management manual

logging:
  level:
    com.acme.claims: DEBUG      # keep orchestrator/fetcher/pipeline visibility like base
    org.springframework.scheduling: INFO
    org.hibernate.SQL: INFO
    org.hibernate.orm.jdbc.bind: INFO

# Keep Flyway off in test as in base config
flyway:
  enabled: false

# App profile-safe defaults used by ingestion+soap tests
claims:
  ingestion:
    # Threading small & deterministic for tests; orchestrator uses this executor
    executor:
      core-pool-size: 2
      max-pool-size: 4
      queue-capacity: 32
    poll:
      fixedDelayMs: 200   # fast poll cadence for test profile
    ack:
      enabled: false      # tests flip this per-method via @TestPropertySource when needed
  fetch:
    stageToDisk:
      force: false
      sizeThresholdBytes: 26214400   # mirror soap profile default (25MB)
      latencyThresholdMs: 8000
      readyDir: "target/test-ready"  # safe temp location for tests
  security:
    ame:
      enabled: false
  soap:
    # Do NOT hit real endpoints by default in tests.
    endpoint: "http://localhost:0/soap"
    soap12: false
    connectTimeoutMs: 1500
    readTimeoutMs: 3000
    retry:
      maxAttempts: 2
      backoffMs: 200

# For tests that rely on the generic baseUrl style (your E2E overrides this explicitly)
dhpo:
  soap:
    baseUrl: "http://localhost:0/soap"



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\db\claims_ddl.sql =====

-- ============================================================
-- CLAIMS APP — Full Combined DDL (SSOT)
-- Date: 2025-09-05 (IST)
-- Notes / Decisions:
--   • Duplicate SUBMISSION (same Claim/ID) without <Resubmission> is IGNORED.
--     Enforced by: one claims.claim per claim_key_id, and one SUBMISSION claim_event per claim.
--   • StAX/XSD-driven model; amounts are non-negative by CHECKs.
--   • ‘updated_at’ maintained by a single trigger across mutable tables.
--   • Event types centralized via domain.
--   • Inline tags for easy manual verification: [XSD], [PK], [FK], [UQ], [IDX], [CHK], [AUDIT], [EVT], [MON]
-- ============================================================

-- ---------- 0) Extensions ----------
create extension if not exists pg_trgm;
create extension if not exists citext;
create extension if not exists pgcrypto;

-- ---------- 1) Schemas ----------
create schema if not exists claims;
create schema if not exists auth; -- reserved

-- ---------- 2) Roles (runtime app role) ----------
do $$
begin
  if not exists (select 1 from pg_roles where rolname = 'claims_user') then
    create role claims_user login;
  end if;
end$$ language plpgsql;

-- ---------- 3) Domains / Enums ----------
-- Centralized event type domain: 1=SUBMISSION, 2=RESUBMISSION, 3=REMITTANCE
do $$
begin
  if not exists (select 1 from pg_type where typname = 'claim_event_type') then
    execute 'create domain claims.claim_event_type as smallint check (value in (1,2,3))';
  end if;
end$$;

-- ---------- 4) Audit helper (updated_at) ----------
create or replace function claims.set_updated_at()
returns trigger language plpgsql as $$
begin
  if NEW is distinct from OLD then
    NEW.updated_at := now();
  end if;
  return NEW;
end$$;

-- ============================================================
-- 5) RAW XML SSOT + XSD Header (common to both roots)
--    Root types: 1=Claim.Submission, 2=Remittance.Advice
-- ============================================================
create table if not exists claims.ingestion_file (
  id                     bigserial primary key,                                -- [PK]
  file_id                text not null,                                        -- [UQ] external idempotency
  root_type              smallint not null check (root_type in (1,2)),         -- [CHK]
  -- XSD Header (1..1 for both schemas)
  sender_id              text not null,                                        -- [XSD (1..1)]
  receiver_id            text not null,                                        -- [XSD (1..1)]
  transaction_date       timestamptz not null,                                 -- [XSD (1..1)]
  record_count_declared  int not null check (record_count_declared >= 0),      -- [XSD (1..1)] [CHK]
  disposition_flag       text not null,                                        -- [XSD (1..1)]
  -- Raw XML SSOT
  xml_bytes              bytea not null,                                       -- [SSOT]
  created_at             timestamptz not null default now(),                   -- [AUDIT]
  updated_at             timestamptz not null default now(),                   -- [AUDIT]
  constraint uq_ingestion_file unique (file_id)                                -- [UQ]
);
comment on table claims.ingestion_file is
  'SSOT: raw XML + XSD Header; duplicate files rejected by unique(file_id).';
create index if not exists idx_ing_file_root_type on claims.ingestion_file(root_type); -- [IDX]
create trigger trg_ingestion_file_updated_at
  before update on claims.ingestion_file
  for each row execute function claims.set_updated_at();

-- ============================================================
-- 6) CANONICAL CLAIM KEY (Claim/ID appears in both roots)
-- ============================================================
create table if not exists claims.claim_key (
  id          bigserial primary key,                -- [PK]
  claim_id    text not null unique,                 -- [UQ] canonical business id
  created_at  timestamptz not null default now(),   -- [AUDIT]
  updated_at  timestamptz not null default now()    -- [AUDIT]
);
create trigger trg_claim_key_updated_at
  before update on claims.claim_key
  for each row execute function claims.set_updated_at();

-- ============================================================
-- 7) CLAIM.SUBMISSION graph
-- ============================================================

-- One submission row per file (grouping)
create table if not exists claims.submission (
  id                 bigserial primary key,                                -- [PK]
  ingestion_file_id  bigint not null                                      -- [FK]
    references claims.ingestion_file(id) on delete restrict,
  created_at         timestamptz not null default now(),                  -- [AUDIT]
  updated_at         timestamptz not null default now()                   -- [AUDIT]
);
create index if not exists idx_submission_file on claims.submission(ingestion_file_id); -- [IDX]
create trigger trg_submission_updated_at
  before update on claims.submission
  for each row execute function claims.set_updated_at();

-- Claim (submission)
create table if not exists claims.claim (
  id                 bigserial primary key,                                -- [PK]
  claim_key_id       bigint not null                                       -- [FK]
    references claims.claim_key(id) on delete restrict,
  submission_id      bigint not null                                       -- [FK]
    references claims.submission(id) on delete restrict,
  -- Claim-level fields (XSD)
  id_payer           text,                                                 -- [XSD (0..1)]
  member_id          text,                                                 -- [XSD (0..1)]
  payer_id           text not null,                                        -- [XSD (1..1)]
  provider_id        text not null,                                        -- [XSD (1..1)]
  emirates_id_number text not null,                                        -- [XSD (1..1)]
  gross              numeric(14,2) not null check (gross >= 0),            -- [XSD (1..1)] [CHK]
  patient_share      numeric(14,2) not null check (patient_share >= 0),    -- [XSD (1..1)] [CHK]
  net                numeric(14,2) not null check (net >= 0),              -- [XSD (1..1)] [CHK]
  comments			  text,													-- store comments if found
  created_at         timestamptz not null default now(),                   -- [AUDIT]
  updated_at         timestamptz not null default now(),                   -- [AUDIT]
  -- Idempotency rules:
  --  • Only ONE claims.claim per claim_key_id globally ? duplicate SUBMISSION (no <Resubmission>) is ignored by app on conflict.
  --  • Also unique within a submission file.
  constraint uq_claim_per_key unique (claim_key_id),                       -- [UQ]
  constraint uq_claim_submission_claimkey unique (submission_id, claim_key_id) -- [UQ]
);
create index if not exists idx_claim_claim_key   on claims.claim(claim_key_id);       -- [IDX]
create index if not exists idx_claim_payer       on claims.claim(payer_id);           -- [IDX]
create index if not exists idx_claim_provider    on claims.claim(provider_id);        -- [IDX]
create index if not exists idx_claim_member      on claims.claim(member_id);          -- [IDX]
create index if not exists idx_claim_emirates    on claims.claim(emirates_id_number); -- [IDX]
create index if not exists idx_claim_has_comments on claims.claim((comments is not null));

create trigger trg_claim_updated_at
  before update on claims.claim
  for each row execute function claims.set_updated_at();
comment on table claims.claim is
  'Core submission claim; duplicates without <Resubmission> are ignored (one row per claim_key_id).';

-- Encounter (submission)
create table if not exists claims.encounter (
  id                    bigserial primary key,                                -- [PK]
  claim_id              bigint not null                                       -- [FK]
    references claims.claim(id) on delete cascade,
  facility_id           text not null,                                        -- [XSD (1..1)]
  type                  text not null,                                        -- [XSD (1..1)]
  patient_id            text not null,                                        -- [XSD (1..1)]
  start_at              timestamptz not null,                                 -- [XSD (1..1)]
  end_at                timestamptz,                                          -- [XSD (0..1)]
  start_type            text,                                                 -- [XSD (0..1)]
  end_type              text,                                                 -- [XSD (0..1)]
  transfer_source       text,                                                 -- [XSD (0..1)]
  transfer_destination  text,                                                 -- [XSD (0..1)]
  created_at            timestamptz not null default now(),                   -- [AUDIT]
  updated_at            timestamptz not null default now()                    -- [AUDIT]
);
create index if not exists idx_encounter_claim on claims.encounter(claim_id); -- [IDX]
create trigger trg_encounter_updated_at
  before update on claims.encounter
  for each row execute function claims.set_updated_at();

-- Diagnosis (submission)
create table if not exists claims.diagnosis (
  id           bigserial primary key,                          -- [PK]
  claim_id bigint not null                                 -- [FK]
    references claims.claim(id) on delete cascade,
  diag_type    text not null,                                  -- [XSD (1..1)]
  code         text not null,                                  -- [XSD (1..1)]
  created_at   timestamptz not null default now(),             -- [AUDIT]
  updated_at   timestamptz not null default now()              -- [AUDIT]
);
create index if not exists idx_diagnosis_claim on claims.diagnosis(claim_id); -- [IDX]
create index if not exists idx_diagnosis_code on claims.diagnosis(code);
create index if not exists idx_diagnosis_claim_code on claims.diagnosis(claim_id, code);
create unique index if not exists uq_diagnosis_claim_type_code
  on claims.diagnosis (claim_id, diag_type, code);


create trigger trg_diagnosis_updated_at
  before update on claims.diagnosis
  for each row execute function claims.set_updated_at();

-- Activity (submission)
create table if not exists claims.activity (
  id                      bigserial primary key,                                -- [PK]
  claim_id                bigint not null                                       -- [FK]
    references claims.claim(id) on delete cascade,
  activity_id             text not null,                                        -- [XSD (1..1)]
  start_at                timestamptz not null,                                 -- [XSD (1..1)]
  type                    text not null,                                        -- [XSD (1..1)]
  code                    text not null,                                        -- [XSD (1..1)]
  quantity                numeric(14,2) not null check (quantity >= 0),         -- [XSD (1..1)] [CHK]
  net                     numeric(14,2) not null check (net >= 0),              -- [XSD (1..1)] [CHK]
  clinician               text not null,                                        -- [XSD (1..1)]
  prior_authorization_id  text,                                                 -- [XSD (0..1)]
  created_at              timestamptz not null default now(),                   -- [AUDIT]
  updated_at              timestamptz not null default now(),                   -- [AUDIT]
  constraint uq_activity_bk unique (claim_id, activity_id)                      -- [UQ]
);
create index if not exists idx_activity_claim     on claims.activity(claim_id);      -- [IDX]
create index if not exists idx_activity_clinician on claims.activity(clinician);     -- [IDX]
create index if not exists idx_activity_code      on claims.activity(code);          -- [IDX]
create index if not exists idx_activity_type      on claims.activity(type);          -- [IDX]
create index if not exists idx_activity_start     on claims.activity(start_at);      -- [IDX]
create trigger trg_activity_updated_at
  before update on claims.activity
  for each row execute function claims.set_updated_at();

-- Observation (on submission activity)
create table if not exists claims.observation (
  id           bigserial primary key,                                  -- [PK]
  activity_id  bigint not null                                         -- [FK]
    references claims.activity(id) on delete cascade,
  obs_type     text not null,                                          -- [XSD (1..1)]
  obs_code     text not null,                                          -- [XSD (1..1)]
  value_text   text,                                                   -- [XSD (0..1)]
  value_type   text,                                                   -- [XSD (0..1)]
  file_bytes   bytea,													-- to store file bytes if obs_type is file
  created_at   timestamptz not null default now(),                     -- [AUDIT]
  updated_at   timestamptz not null default now()                      -- [AUDIT]
);
-- Unique de-dup index on semantic content (md5(value_text))
--create unique index if not exists uq_observation_dedup
--  on claims.observation (activity_id, obs_type, obs_code, (pg_catalog.md5(coalesce(value_text,'')))); -- [UQ]
create index if not exists idx_obs_activity on claims.observation(activity_id); -- [IDX]
create index if not exists idx_obs_nonfile on claims.observation(activity_id) where file_bytes is null;

create trigger trg_observation_updated_at
  before update on claims.observation
  for each row execute function claims.set_updated_at();

-- Optional Contract (submission)
create table if not exists claims.claim_contract (
  id               bigserial primary key,                                -- [PK]
  claim_id         bigint not null                                       -- [FK]
    references claims.claim(id) on delete cascade,
  package_name     text,                                                 -- [XSD (0..1)]
  created_at       timestamptz not null default now(),                   -- [AUDIT]
  updated_at       timestamptz not null default now()                    -- [AUDIT]
);
create trigger trg_claim_contract_updated_at
  before update on claims.claim_contract
  for each row execute function claims.set_updated_at();

-- Resubmission (1:1 with RESUBMISSION event) — FK added later
create table if not exists claims.claim_resubmission (
  id                 bigserial primary key,                                -- [PK]
  claim_event_id     bigint not null unique,                               -- [UQ] [FK LATER]
  resubmission_type  text not null,                                        -- [XSD (1..1)]
  comment            text not null,                                        -- [XSD (1..1)]
  attachment         bytea,                                                 -- [XSD (0..1)] (metadata or ref; binary via claim_attachment)
  created_at         timestamptz not null default now(),                   -- [AUDIT]
  updated_at         timestamptz not null default now()                    -- [AUDIT]
);
create trigger trg_claim_resubmission_updated_at
  before update on claims.claim_resubmission
  for each row execute function claims.set_updated_at();

-- ============================================================
-- 8) REMITTANCE.ADVICE graph
-- ============================================================

-- One remittance row per file (grouping)
create table if not exists claims.remittance (
  id                 bigserial primary key,                                -- [PK]
  ingestion_file_id  bigint not null                                       -- [FK]
    references claims.ingestion_file(id) on delete restrict,
  created_at         timestamptz not null default now(),                   -- [AUDIT]
  updated_at         timestamptz not null default now()                    -- [AUDIT]
);
create index if not exists idx_remittance_file on claims.remittance(ingestion_file_id); -- [IDX]
create trigger trg_remittance_updated_at
  before update on claims.remittance
  for each row execute function claims.set_updated_at();

-- Remittance Claim (per-claim adjudication)
create table if not exists claims.remittance_claim (
  id                 bigserial primary key,                                -- [PK]
  remittance_id      bigint not null                                       -- [FK]
    references claims.remittance(id) on delete cascade,
  claim_key_id       bigint not null                                       -- [FK] why reference claim_key(id) and not claim(id)?
    references claims.claim_key(id) on delete restrict,
  id_payer           text not null,                                        -- [XSD (1..1)]
  provider_id        text,                                                 -- [XSD (0..1)]
  denial_code        text,                                                 -- [XSD (0..1)]
  payment_reference  text not null,                                        -- [XSD (1..1)]
  date_settlement    timestamptz,                                          -- [XSD (0..1)]
  facility_id        text,                                                 -- [XSD (0..1)] stored here
  created_at         timestamptz not null default now(),                   -- [AUDIT]
  updated_at         timestamptz not null default now(),                   -- [AUDIT]
  constraint uq_remittance_claim unique (remittance_id, claim_key_id)      -- [UQ]
);
create index if not exists idx_remit_claim_key      on claims.remittance_claim(claim_key_id);    -- [IDX]
create index if not exists idx_remit_claim_provider on claims.remittance_claim(provider_id);     -- [IDX]
create index if not exists idx_remit_claim_denial   on claims.remittance_claim(denial_code);     -- [IDX]
create index if not exists idx_remit_claim_settle   on claims.remittance_claim(date_settlement); -- [IDX]
create trigger trg_remittance_claim_updated_at
  before update on claims.remittance_claim
  for each row execute function claims.set_updated_at();

-- Remittance Activity (per activity within that claim)
create table if not exists claims.remittance_activity (
  id                      bigserial primary key,                                -- [PK]
  remittance_claim_id     bigint not null                                       -- [FK]
    references claims.remittance_claim(id) on delete cascade,
  activity_id             text not null,                                        -- [XSD (1..1)]
  start_at                timestamptz not null,                                 -- [XSD (1..1)]
  type                    text not null,                                        -- [XSD (1..1)]
  code                    text not null,                                        -- [XSD (1..1)]
  quantity                numeric(14,2) not null check (quantity >= 0),         -- [XSD (1..1)] [CHK]
  net                     numeric(14,2) not null check (net >= 0),              -- [XSD (1..1)] [CHK]
  list_price              numeric(14,2) check (list_price is null or list_price >= 0), -- [XSD (0..1)] [CHK]
  clinician               text not null,                                        -- [XSD (1..1)]
  prior_authorization_id  text,                                                 -- [XSD (0..1)]
  gross                   numeric(14,2) check (gross is null or gross >= 0),    -- [XSD (0..1)] [CHK]
  patient_share           numeric(14,2) check (patient_share is null or patient_share >= 0), -- [XSD (0..1)] [CHK]
  payment_amount          numeric(14,2) not null check (payment_amount >= 0),   -- [XSD (1..1)] [CHK]
  denial_code             text,                                                 -- [XSD (0..1)]
  created_at              timestamptz not null default now(),                   -- [AUDIT]
  updated_at              timestamptz not null default now(),                   -- [AUDIT]
  constraint uq_remittance_activity unique (remittance_claim_id, activity_id)   -- [UQ]
);
create index if not exists idx_remit_act_claim     on claims.remittance_activity(remittance_claim_id); -- [IDX]
create index if not exists idx_remit_act_clinician on claims.remittance_activity(clinician);           -- [IDX]
create index if not exists idx_remit_act_code      on claims.remittance_activity(code);                -- [IDX]
create index if not exists idx_remit_act_type      on claims.remittance_activity(type);                -- [IDX]
create index if not exists idx_remit_act_start     on claims.remittance_activity(start_at);            -- [IDX]
create trigger trg_remittance_activity_updated_at
  before update on claims.remittance_activity
  for each row execute function claims.set_updated_at();

-- ============================================================
-- 9) EVENTS / SNAPSHOTS / TIMELINE
-- ============================================================

-- Event stream over claims
create table if not exists claims.claim_event (
  id                 bigserial primary key,                                -- [PK]
  claim_key_id       bigint not null                                       -- [FK]
    references claims.claim_key(id) on delete restrict,
  ingestion_file_id  bigint                                                -- [FK] provenance to exact file
    references claims.ingestion_file(id) on delete set null,
  event_time         timestamptz not null,                                 -- [EVT]
  type               claims.claim_event_type not null,                     -- [EVT]
  submission_id      bigint,                                               -- [FK LATER]
  remittance_id      bigint,                                               -- [FK LATER]
  created_at         timestamptz not null default now()                    -- [AUDIT]
);
-- Exactly one SUBMISSION event per claim (ignores repeats)
create unique index if not exists uq_claim_event_one_submission
  on claims.claim_event (claim_key_id)
  where type = 1;                                                          -- [UQ]
-- Dedupe guard (per type + time)
create unique index if not exists uq_claim_event_dedup
  on claims.claim_event (claim_key_id, type, event_time);                  -- [UQ]
create index if not exists idx_event_claim_key on claims.claim_event(claim_key_id); -- [IDX]
create index if not exists idx_event_time      on claims.claim_event(event_time);   -- [IDX]

-- Activity snapshots at event time
create table if not exists claims.claim_event_activity (
  id                             bigserial primary key,                                -- [PK]
  claim_event_id                 bigint not null                                       -- [FK]
    references claims.claim_event(id) on delete cascade,
  activity_id_ref                bigint                                                -- [FK]
    references claims.activity(id) on delete set null,
  remittance_activity_id_ref     bigint                                                -- [FK]
    references claims.remittance_activity(id) on delete set null,
  activity_id_at_event           text not null,                                        -- [EVT]
  start_at_event                 timestamptz not null,                                 -- [EVT]
  type_at_event                  text not null,                                        -- [EVT]
  code_at_event                  text not null,                                        -- [EVT]
  quantity_at_event              numeric(14,2) not null,                               -- [EVT]
  net_at_event                   numeric(14,2) not null,                               -- [EVT]
  clinician_at_event             text not null,                                        -- [EVT]
  prior_authorization_id_at_event text,                                                -- [EVT]
  -- Remittance-only snapshot fields
  list_price_at_event            numeric(14,2),
  gross_at_event                 numeric(14,2),
  patient_share_at_event         numeric(14,2),
  payment_amount_at_event        numeric(14,2),
  denial_code_at_event           text,
  created_at                     timestamptz not null default now()                    -- [AUDIT]
);
create unique index if not exists uq_cea_event_activity
  on claims.claim_event_activity (claim_event_id, activity_id_at_event);              -- [UQ]
create index if not exists idx_cea_event on claims.claim_event_activity(claim_event_id); -- [IDX]

-- Observations tied to an event snapshot
create table if not exists claims.event_observation (
  id                         bigserial primary key,                                  -- [PK]
  claim_event_activity_id    bigint not null                                         -- [FK]
    references claims.claim_event_activity(id) on delete cascade,
  obs_type                   text not null,                                          -- [EVT]
  obs_code                   text not null,                                          -- [EVT]
  value_text                 text,                                                   -- [EVT]
  value_type                 text,                                                   -- [EVT]
  file_bytes				bytea,       -- of type is FILE, then store B64 decoded
  created_at                 timestamptz not null default now()                      -- [AUDIT]
);
create index if not exists idx_event_obs_cea on claims.event_observation(claim_event_activity_id); -- [IDX]

-- Derived status timeline
create table if not exists claims.claim_status_timeline (
  id             bigserial primary key,                                -- [PK]
  claim_key_id   bigint not null                                       -- [FK]
    references claims.claim_key(id) on delete cascade,
  status         smallint not null,                                    -- [EVT] 1=SUBMITTED,2=RESUBMITTED,3=PAID,4=PARTIALLY_PAID,5=REJECTED,6=UNKNOWN
  status_time    timestamptz not null,                                 -- [EVT] -- this should reflect either of transactiondate from submission or remittance
  claim_event_id bigint                                                -- [FK]
    references claims.claim_event(id) on delete set null,
  created_at     timestamptz not null default now()                    -- [AUDIT]
);
create index if not exists idx_cst_claim_key_time on claims.claim_status_timeline(claim_key_id, status_time); -- [IDX]

-- Cross-object FKs added now that targets exist
alter table claims.claim_event
  add constraint fk_claim_event_submission
  foreign key (submission_id) references claims.submission(id) on delete set null;

alter table claims.claim_event
  add constraint fk_claim_event_remittance
  foreign key (remittance_id) references claims.remittance(id) on delete set null;

alter table claims.claim_resubmission
  add constraint fk_resubmission_event
  foreign key (claim_event_id) references claims.claim_event(id) on delete cascade;

-- ============================================================
-- 10) ATTACHMENTS (decoded binary; metadata is optional)
-- ============================================================
create table if not exists claims.claim_attachment (
  id             bigserial primary key,                                -- [PK]
  claim_key_id   bigint not null                                       -- [FK]
    references claims.claim_key(id) on delete cascade,
  claim_event_id bigint not null                                       -- [FK]
    references claims.claim_event(id) on delete cascade,
  file_name      text,                                                 -- [XSD (0..1)]
  mime_type      text,                                                 -- [XSD (0..1)]
  data_base64    bytea not null,                                       -- [BIN] decoded binary payload (name retained)
  data_length    int,                                                  -- [OPT]
  created_at     timestamptz not null default now()                    -- [AUDIT]
);
create unique index if not exists uq_claim_attachment_key_event_file
  on claims.claim_attachment (claim_key_id, claim_event_id, coalesce(file_name,'')); -- [UQ]
comment on table claims.claim_attachment is
  'Binary attachments for claims (decoded); unique per (claim, event, filename)';
comment on column claims.claim_attachment.data_base64 is
  'DECODED binary data (not base64 text).';

-- ============================================================
-- 11) INGESTION MONITORING & VERIFICATION (operational layer)
-- ============================================================

-- Orchestrator run summary (per poll)
create table if not exists claims.ingestion_run (
  id                 bigserial primary key,                                -- [PK] [MON]
  started_at         timestamptz not null default now(),                   -- [MON]
  ended_at           timestamptz,                                          -- [MON]
  profile            text not null,                                        -- [MON]
  fetcher_name       text not null,                                        -- [MON]
  acker_name         text,                                                 -- [MON]
  poll_reason        text,                                                 -- [MON]
  files_discovered   int not null default 0,                                -- [MON]
  files_pulled       int not null default 0,                                -- [MON]
  files_processed_ok int not null default 0,                                -- [MON]
  files_failed       int not null default 0,                                -- [MON]
  files_already      int not null default 0,                                -- [MON]
  acks_sent          int not null default 0                                 -- [MON]
);

-- Per-file audit + counters
create table if not exists claims.ingestion_file_audit (
  id                          bigserial primary key,                        -- [PK] [MON]
  ingestion_run_id            bigint not null                               -- [FK]
    references claims.ingestion_run(id) on delete cascade,
  ingestion_file_id           bigint not null                               -- [FK]
    references claims.ingestion_file(id) on delete cascade,
  status                      smallint not null,                            -- [MON] 0=ALREADY,1=OK,2=FAIL
  reason                      text,                                         -- [MON]
  error_class                 text,                                         -- [MON]
  error_message               text,                                         -- [MON]
  validation_ok               boolean not null default false,               -- [MON]
  header_sender_id            text not null,                                -- [MON]
  header_receiver_id          text not null,                                -- [MON]
  header_transaction_date     timestamptz not null,                         -- [MON]
  header_record_count         int not null,                                 -- [MON]
  header_disposition_flag     text not null,                                -- [MON]
  parsed_claims               int default 0,                                -- [MON]
  parsed_encounters           int default 0,                                -- [MON]
  parsed_diagnoses            int default 0,                                -- [MON]
  parsed_activities           int default 0,                                -- [MON]
  parsed_observations         int default 0,                                -- [MON]
  persisted_claims            int default 0,                                -- [MON]
  persisted_encounters        int default 0,                                -- [MON]
  persisted_diagnoses         int default 0,                                -- [MON]
  persisted_activities        int default 0,                                -- [MON]
  persisted_observations      int default 0,                                -- [MON]
  parsed_remit_claims         int default 0,                                -- [MON]
  parsed_remit_activities     int default 0,                                -- [MON]
  persisted_remit_claims      int default 0,                                -- [MON]
  persisted_remit_activities  int default 0,                                -- [MON]
  projected_events            int default 0,                                -- [MON]
  projected_status_rows       int default 0,                                -- [MON]
  verification_passed         boolean,                                      -- [MON]
  verification_failed_count   int default 0,                                -- [MON]
  ack_attempted               boolean not null default false,               -- [MON]
  ack_sent                    boolean not null default false,               -- [MON]
  created_at                  timestamptz not null default now()            -- [AUDIT]
);
create index if not exists idx_file_audit_run  on claims.ingestion_file_audit(ingestion_run_id);  -- [IDX]
create index if not exists idx_file_audit_file on claims.ingestion_file_audit(ingestion_file_id); -- [IDX]

---- Batch metrics (per stage/table per batch)  -- are we using below table anywhere in our code?
--create table if not exists claims.ingestion_batch_metric (
--  id                    bigserial primary key,                                -- [PK] [MON]
--  ingestion_file_id     bigint not null                                       -- [FK]
    --references claims.ingestion_file(id) on delete cascade,
  ---stage                 text not null,                                        -- [MON] e.g., PARSE|MAP|INSERT_*
  --target_table          text,                                                 -- [MON]
  --batch_no              int not null,                                         -- [MON]
  --started_at            timestamptz not null default now(),                   -- [MON]
  --ended_at              timestamptz,                                          -- [MON]
  --rows_attempted        int not null default 0,                                -- [MON]
  --rows_inserted         int not null default 0,                                -- [MON]
  --conflicts_ignored     int not null default 0,                                -- [MON]
  --retries               int not null default 0,                                -- [MON]
  --status                text not null,                                        -- [MON]
  --error_class           text,                                                 -- [MON]
  --error_message         text                                                  -- [MON]
--);
--create index if not exists idx_batch_metric_file on claims.ingestion_batch_metric(ingestion_file_id, stage, batch_no); -- [IDX]

-- Error log (fine-grained)
create table if not exists claims.ingestion_error (
  id                    bigserial primary key,                                -- [PK] [MON]
  ingestion_file_id     bigint not null                                       -- [FK]
    references claims.ingestion_file(id) on delete cascade,
  stage                 text not null,                                        -- [MON] FETCH|PARSE|VALIDATE|...
  object_type           text,                                                 -- [MON]
  object_key            text,                                                 -- [MON] e.g., Claim.ID
  error_code            text,                                                 -- [MON]
  error_message         text not null,                                        -- [MON]
  stack_excerpt         text,                                                 -- [MON]
  retryable             boolean not null default false,                       -- [MON]
  occurred_at           timestamptz not null default now()                    -- [AUDIT]
);
create index if not exists idx_ing_error_file_stage on claims.ingestion_error(ingestion_file_id, stage, occurred_at desc); -- [IDX]
comment on table claims.ingestion_error is
  'Central error log. For future normalization: if code lookups fail, log "code not found for: {code}, claim id: {claim_id}, file id: {file_id}".';

-- Verification rules & results
create table if not exists claims.verification_rule (
  id            bigserial primary key,                                -- [PK] [MON]
  code          text not null unique,                                  -- [UQ] e.g., COUNT_MATCH
  description   text not null,
  severity      smallint not null,                                     -- 1=INFO 2=WARNING 3=ERROR
  sql_text      text not null,                                         -- parameterized with :ingestion_file_id
  active        boolean not null default true,                         -- [MON]
  created_at    timestamptz not null default now()                     -- [AUDIT]
);

create table if not exists claims.verification_run (
  id                  bigserial primary key,                                -- [PK] [MON]
  ingestion_file_id   bigint not null                                       -- [FK]
    references claims.ingestion_file(id) on delete cascade,
  started_at          timestamptz not null default now(),                   -- [MON]
  ended_at            timestamptz,                                          -- [MON]
  passed              boolean,                                              -- [MON]
  failed_rules        int not null default 0                                 -- [MON]
);
create index if not exists idx_ver_run_file on claims.verification_run(ingestion_file_id); -- [IDX]

create table if not exists claims.verification_result (
  id                   bigserial primary key,                                -- [PK] [MON]
  verification_run_id  bigint not null                                       -- [FK]
    references claims.verification_run(id) on delete cascade,
  rule_id              bigint not null                                       -- [FK]
    references claims.verification_rule(id) on delete restrict,
  ok                   boolean not null,                                     -- [MON]
  rows_affected        bigint,                                               -- [MON]
  sample_json          jsonb,                                                -- [MON]
  message              text,                                                 -- [MON]
  executed_at          timestamptz not null default now()                    -- [AUDIT]
);
create index if not exists idx_ver_result_run on claims.verification_result(verification_run_id, rule_id); -- [IDX]

-- ============================================================
-- 12) KPI View (hourly rollup)
-- ============================================================
create or replace view claims.v_ingestion_kpis as
select
  date_trunc('hour', ifa.created_at) as hour_bucket,
  count(*)                                        as files_total,
  sum(case when status=1 then 1 else 0 end)       as files_ok,
  sum(case when status=2 then 1 else 0 end)       as files_fail,
  sum(case when status=0 then 1 else 0 end)       as files_already,
  sum(parsed_claims)                               as parsed_claims,
  sum(persisted_claims)                            as persisted_claims,
  sum(parsed_activities)                           as parsed_activities,
  sum(persisted_activities)                        as persisted_activities,
  sum(parsed_remit_claims)                         as parsed_remit_claims,
  sum(persisted_remit_claims)                      as persisted_remit_claims,
  sum(parsed_remit_activities)                     as parsed_remit_activities,
  sum(persisted_remit_activities)                  as persisted_remit_activities,
  sum(case when verification_passed then 1 else 0 end) as files_verified
from claims.ingestion_file_audit ifa
group by 1
order by 1 desc;

-- ============================================================
-- 13) Grants
-- ============================================================
grant usage on schema claims to claims_user;
grant select, insert, update on all tables in schema claims to claims_user;
grant usage, select on all sequences in schema claims to claims_user;
alter default privileges in schema claims grant select, insert, update on tables to claims_user;
alter default privileges in schema claims grant usage, select on sequences to claims_user;

-- SUBMISSION: tx_at <- ingestion_file.transaction_date  ---
do $$
begin
  if not exists (select 1 from information_schema.columns
                 where table_schema='claims' and table_name='submission' and column_name='tx_at') then
    execute 'alter table claims.submission add column tx_at timestamptz';
  end if;
end$$;

create or replace function claims.set_submission_tx_at()
returns trigger language plpgsql as $$
begin
  if NEW.tx_at is null then
    select i.transaction_date into NEW.tx_at
    from claims.ingestion_file i
    where i.id = NEW.ingestion_file_id;
  end if;
  return NEW;
end$$;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname='trg_submission_tx_at') then
    execute 'create trigger trg_submission_tx_at
             before insert on claims.submission
             for each row execute function claims.set_submission_tx_at()';
  end if;
end$$;

-- REMITTANCE: tx_at <- ingestion_file.transaction_date
do $$
begin
  if not exists (select 1 from information_schema.columns
                 where table_schema='claims' and table_name='remittance' and column_name='tx_at') then
    execute 'alter table claims.remittance add column tx_at timestamptz';
  end if;
end$$;

create or replace function claims.set_remittance_tx_at()
returns trigger language plpgsql as $$
begin
  if NEW.tx_at is null then
    select i.transaction_date into NEW.tx_at
    from claims.ingestion_file i
    where i.id = NEW.ingestion_file_id;
  end if;
  return NEW;
end$$;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname='trg_remittance_tx_at') then
    execute 'create trigger trg_remittance_tx_at
             before insert on claims.remittance
             for each row execute function claims.set_remittance_tx_at()';
  end if;
end$$;

-- CLAIM: tx_at <- submission.tx_at
do $$
begin
  if not exists (select 1 from information_schema.columns
                 where table_schema='claims' and table_name='claim' and column_name='tx_at') then
    execute 'alter table claims.claim add column tx_at timestamptz';
  end if;
end$$;

create or replace function claims.set_claim_tx_at()
returns trigger language plpgsql as $$
begin
  if NEW.tx_at is null then
    select s.tx_at into NEW.tx_at
    from claims.submission s
    where s.id = NEW.submission_id;
  end if;
  return NEW;
end$$;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname='trg_claim_tx_at') then
    execute 'create trigger trg_claim_tx_at
             before insert on claims.claim
             for each row execute function claims.set_claim_tx_at()';
  end if;
end$$;

-- BACKFILL existing rows then enforce NOT NULL + INDEX
update claims.submission s
set tx_at = i.transaction_date
from claims.ingestion_file i
where s.tx_at is null and s.ingestion_file_id = i.id;

update claims.remittance r
set tx_at = i.transaction_date
from claims.ingestion_file i
where r.tx_at is null and r.ingestion_file_id = i.id;

update claims.claim c
set tx_at = s.tx_at
from claims.submission s
where c.tx_at is null and c.submission_id = s.id;

alter table claims.submission alter column tx_at set not null;
alter table claims.remittance alter column tx_at set not null;
alter table claims.claim      alter column tx_at set not null;

create index if not exists idx_submission_tx_at on claims.submission(tx_at);
create index if not exists idx_remittance_tx_at on claims.remittance(tx_at);
create index if not exists idx_claim_tx_at      on claims.claim(tx_at);

-- EVENTS: ensure and index canonical event clock (already present)
-- (No new column; we rely on claim_event.event_time)
create index if not exists idx_event_time on claims.claim_event(event_time);
ALTER ROLE claims_user PASSWORD 'securepass';



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\db\claims_ref_ddl.sql =====

-- =====================================================================
-- Extensions (safe if repeated)
-- =====================================================================
create extension if not exists pg_trgm;
create extension if not exists pgcrypto;

-- =====================================================================
-- SCHEMA: claims_ref  (Reference data)
-- =====================================================================
create schema if not exists claims_ref;

-- -------------------------
-- Facilities
-- -------------------------
create table if not exists claims_ref.facility (
  id             bigserial primary key,
  facility_code  text not null unique,  -- e.g., DHA-F-0045446
  name           text,
  city           text,
  country        text,
  status         text default 'ACTIVE',
  updated_at     timestamptz default now()
);
comment on table  claims_ref.facility is 'Master list of provider facilities (Encounter.FacilityID)';
comment on column claims_ref.facility.facility_code is 'External FacilityID (DHA/eClaim)';

-- -------------------------
-- Payers
-- -------------------------
create table if not exists claims_ref.payer (
  id          bigserial primary key,
  payer_code  text not null unique,     -- e.g., INS025
  name        text,
  status      text default 'ACTIVE',
  updated_at  timestamptz default now()
);
comment on table  claims_ref.payer is 'Master list of Payers (Claim.PayerID)';
comment on column claims_ref.payer.payer_code is 'External PayerID';

-- -------------------------
-- Providers (org-level)
-- -------------------------
create table if not exists claims_ref.provider (
  id            bigserial primary key,
  provider_code text not null unique,
  name          text,
  status        text default 'ACTIVE',
  updated_at    timestamptz default now()
);
comment on table claims_ref.provider is 'Master list of provider organizations (Claim.ProviderID)';

-- -------------------------
-- Clinicians
-- -------------------------
create table if not exists claims_ref.clinician (
  id              bigserial primary key,
  clinician_code  text not null unique, -- e.g., DHA-P-0228312
  name            text,
  specialty       text,
  status          text default 'ACTIVE',
  updated_at      timestamptz default now()
);
comment on table claims_ref.clinician is 'Master list of clinicians (Activity.Clinician)';

-- -------------------------
-- Activity Codes
-- -------------------------
create table if not exists claims_ref.activity_code (
  id           bigserial primary key,
  code         text not null,
  code_system  text not null default 'LOCAL',   -- CPT/HCPCS/LOCAL/etc.
  description  text,
  status       text default 'ACTIVE',
  updated_at   timestamptz default now(),
  constraint uq_activity_code unique (code, code_system)
);
comment on table claims_ref.activity_code is 'Service/procedure codes used in Activity.Code';

-- -------------------------
-- Diagnosis Codes
-- -------------------------
create table if not exists claims_ref.diagnosis_code (
  id           bigserial primary key,
  code         text not null,
  code_system  text not null default 'ICD-10',
  description  text,
  status       text default 'ACTIVE',
  updated_at   timestamptz default now(),
  constraint uq_diagnosis_code unique (code, code_system)
);
comment on table claims_ref.diagnosis_code is 'Diagnosis codes (Diagnosis.Code)';

-- -------------------------
-- Denial Codes  (surrogate id + unique(code))
-- -------------------------
create table if not exists claims_ref.denial_code (
  id          bigserial primary key,
  code        text not null unique,
  description text,
  payer_code  text,  -- optional scope
  updated_at  timestamptz default now()
);
comment on table claims_ref.denial_code is 'Adjudication denial codes; optionally scoped by payer_code';

-- -------------------------
-- Observation dictionaries (curated lists; optional)
-- -------------------------
create table if not exists claims_ref.observation_type (
  obs_type     text primary key,  -- LOINC/Text/File/Universal Dental/Financial/Grouping/ERX/Result
  description  text
);

insert into claims_ref.observation_type(obs_type, description) values
  ('LOINC','LOINC standardized code'),
  ('Text','Free text observation'),
  ('File','Binary file attachment'),
  ('Universal Dental','Universal Dental coding'),
  ('Financial','Financial observation'),
  ('Grouping','Panel/grouping marker'),
  ('ERX','Electronic prescription'),
  ('Result','Generic lab/clinical result')
on conflict (obs_type) do update set description = excluded.description;

create table if not exists claims_ref.observation_value_type (
  value_type   text primary key,  -- curated unit/value type (optional)
  description  text
);

create table if not exists claims_ref.observation_code (
  id          bigserial primary key,
  code        text not null unique, -- curated short-hand like A1C/BPS/etc.
  description text
);

-- -------------------------
-- Contract Packages
-- -------------------------
create table if not exists claims_ref.contract_package (
  package_name text primary key,
  description  text,
  status       text default 'ACTIVE',
  updated_at   timestamptz default now()
);

-- -------------------------
-- Type dictionaries (seed)
-- -------------------------
create table if not exists claims_ref.activity_type (
  type_code   text primary key,
  description text
);

insert into claims_ref.activity_type(type_code, description) values
  ('3','Diagnostic/Lab'),('4','Radiology'),('5','Pharmacy'),('6','Consumables'),
  ('8','Consultation'),('9','Inpatient'),('10','Other')
on conflict (type_code) do update set description = excluded.description;

create table if not exists claims_ref.encounter_type (
  type_code   text primary key,
  description text
);

insert into claims_ref.encounter_type(type_code, description) values
  ('1','OPD'),('2','ER'),('3','IPD'),('4','Day Case'),('5','Home Care'),
  ('6','Telemedicine'),('7','OT'),('8','Physio'),('9','Dental'),('10','Wellness'),
  ('12','Maternity'),('13','Mental Health'),('15','Rehab'),('41','Ambulance'),('42','Nursing')
on conflict (type_code) do update set description = excluded.description;

create table if not exists claims_ref.resubmission_type (
  type_code   text primary key,
  description text
);

insert into claims_ref.resubmission_type(type_code, description) values
  ('correction','Correction'),
  ('internal complaint','Internal complaint'),
  ('legacy','Legacy'),
  ('reconciliation','Reconciliation')
on conflict (type_code) do update set description = excluded.description;

-- =====================================================================
-- AUDIT: newly discovered codes during ingest
-- =====================================================================
create schema if not exists claims;

create table if not exists claims.code_discovery_audit (
  id                bigserial primary key,
  discovered_at     timestamptz not null default now(),
  source_table      text not null,         -- e.g., 'claims_ref.activity_code'
  code              text not null,
  code_system       text,                  -- when applicable
  discovered_by     text not null default 'SYSTEM',
  ingestion_file_id bigint,
  claim_external_id text,
  details           jsonb not null default '{}'::jsonb
);
create index if not exists idx_code_discovery_at   on claims.code_discovery_audit(discovered_at);
create index if not exists idx_code_discovery_code on claims.code_discovery_audit(code);

-- =====================================================================
-- FACT tables: add nullable FK columns (backward compatible)
-- =====================================================================

-- CLAIM: payer_ref_id, provider_ref_id
alter table if exists claims.claim
  add column if not exists payer_ref_id    bigint,
  add column if not exists provider_ref_id bigint;

-- ENCOUNTER: facility_ref_id
alter table if exists claims.encounter
  add column if not exists facility_ref_id bigint;

-- ACTIVITY: clinician_ref_id, activity_code_ref_id
alter table if exists claims.activity
  add column if not exists clinician_ref_id     bigint,
  add column if not exists activity_code_ref_id bigint;

-- DIAGNOSIS: diagnosis_code_ref_id
alter table if exists claims.diagnosis
  add column if not exists diagnosis_code_ref_id bigint;

-- REMITTANCE_CLAIM: denial_code_ref_id
alter table if exists claims.remittance_claim
  add column if not exists denial_code_ref_id bigint,
  add column if not exists payer_ref_id bigint,
  add column if not exists provider_ref_id bigint;

-- =====================================================================
-- FK constraints (wrapped in DO blocks because PostgreSQL lacks IF NOT EXISTS on ADD CONSTRAINT)
-- =====================================================================

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_claim_payer_ref') then
    alter table claims.claim
      add constraint fk_claim_payer_ref
      foreign key (payer_ref_id) references claims_ref.payer(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_claim_provider_ref') then
    alter table claims.claim
      add constraint fk_claim_provider_ref
      foreign key (provider_ref_id) references claims_ref.provider(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_encounter_facility_ref') then
    alter table claims.encounter
      add constraint fk_encounter_facility_ref
      foreign key (facility_ref_id) references claims_ref.facility(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_activity_clinician_ref') then
    alter table claims.activity
      add constraint fk_activity_clinician_ref
      foreign key (clinician_ref_id) references claims_ref.clinician(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_activity_code_ref') then
    alter table claims.activity
      add constraint fk_activity_code_ref
      foreign key (activity_code_ref_id) references claims_ref.activity_code(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_diag_code_ref') then
    alter table claims.diagnosis
      add constraint fk_diag_code_ref
      foreign key (diagnosis_code_ref_id) references claims_ref.diagnosis_code(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname = 'fk_remit_denial_ref') then
    alter table claims.remittance_claim
      add constraint fk_remit_denial_ref
      foreign key (denial_code_ref_id) references claims_ref.denial_code(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname='fk_remit_payer_ref') then
    alter table claims.remittance_claim
      add constraint fk_remit_payer_ref
      foreign key (payer_ref_id) references claims_ref.payer(id);
  end if;
end$$;

do $$
begin
  if not exists (select 1 from pg_constraint where conname='fk_remit_provider_ref') then
    alter table claims.remittance_claim
      add constraint fk_remit_provider_ref
      foreign key (provider_ref_id) references claims_ref.provider(id);
  end if;
end$$;


-- =====================================================================
-- Indexes to speed lookups
-- =====================================================================
create index if not exists idx_ref_facility_code     on claims_ref.facility(facility_code);
create index if not exists idx_ref_payer_code        on claims_ref.payer(payer_code);
create index if not exists idx_ref_provider_code     on claims_ref.provider(provider_code);
create index if not exists idx_ref_clinician_code    on claims_ref.clinician(clinician_code);
create index if not exists idx_ref_activity_code     on claims_ref.activity_code(code);
create index if not exists idx_ref_diag_code         on claims_ref.diagnosis_code(code);
create index if not exists idx_ref_denial_payer      on claims_ref.denial_code(payer_code);
create index if not exists idx_remit_claim_payer_ref    on claims.remittance_claim(payer_ref_id);
create index if not exists idx_remit_claim_provider_ref on claims.remittance_claim(provider_ref_id);

-- Optional fuzzy search (trgm) on names/descriptions
create index if not exists idx_ref_facility_name_trgm  on claims_ref.facility      using gin (name gin_trgm_ops);
create index if not exists idx_ref_payer_name_trgm     on claims_ref.payer         using gin (name gin_trgm_ops);
create index if not exists idx_ref_provider_name_trgm  on claims_ref.provider      using gin (name gin_trgm_ops);
create index if not exists idx_ref_clinician_name_trgm on claims_ref.clinician     using gin (name gin_trgm_ops);
create index if not exists idx_ref_activity_desc_trgm  on claims_ref.activity_code using gin (description gin_trgm_ops);
create index if not exists idx_ref_diag_desc_trgm      on claims_ref.diagnosis_code using gin (description gin_trgm_ops);
create index if not exists idx_ref_denial_desc_trgm    on claims_ref.denial_code    using gin (description gin_trgm_ops);

-- =====================================================================
-- Grants to app role
-- =====================================================================
grant select, insert, update on all tables in schema claims_ref to claims_user;
grant usage, select on all sequences in schema claims_ref to claims_user;



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\db\dhpo_config.sql =====

-- SCHEMA: claims.facility_dhpo_config
-- Purpose: One row per facility + global toggle fields (Option B)
CREATE TABLE IF NOT EXISTS claims.facility_dhpo_config (
                                                           id                 BIGSERIAL PRIMARY KEY,
                                                           facility_code      CITEXT        NOT NULL,
                                                           facility_name      TEXT          NOT NULL,

    -- DHPO endpoints
                                                           endpoint_url       TEXT          NOT NULL DEFAULT 'https://dhpo.eclaimlink.ae/ValidateTransactions.asmx',
                                                           endpoint_url_for_erx TEXT        NOT NULL DEFAULT 'https://dhpo.eclaimlink.ae/eRxValidateTransactions.asmx',

    -- App-managed encryption for credentials
                                                           dhpo_username_enc  BYTEA         NOT NULL,
                                                           dhpo_password_enc  BYTEA         NOT NULL,
                                                           enc_meta_json      JSONB         NOT NULL,  -- {kek_version:int, alg:"AES/GCM", iv:base64, tagBits:int}

                                                           active             BOOLEAN       NOT NULL DEFAULT TRUE,
                                                           created_at         TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
    updated_at         TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
    UNIQUE(facility_code)
    );



COMMENT ON TABLE  claims.facility_dhpo_config IS 'Per-facility DHPO endpoints + encrypted creds (AME).';
COMMENT ON COLUMN claims.facility_dhpo_config.enc_meta_json IS 'Enc metadata: {"kek_version":int,"alg":"AES/GCM","iv":"b64","tagBits":int}';



-- operational role used by our app
grant select, insert, update on claims.facility_dhpo_config to claims_user;

-- do NOT grant raw access to decrypt helper (we’ll use controlled access below)
-- global toggles (we already use this table)
create table if not exists claims.integration_toggle(
                                                        code text primary key,
                                                        enabled boolean not null default false,
                                                        updated_at timestamptz not null default now()
    );

insert into claims.integration_toggle(code, enabled) values
                                                         ('dhpo.search.enabled', true),
                                                         ('dhpo.setDownloaded.enabled', true)
    on conflict (code) do nothing;

grant select, insert, update on claims.integration_toggle to claims_user;

------------------------------------
resolution rule in code 
--effective_search_enabled = coalesce(facility.search_enabled, global.search.enabled)
--effective_setdownload_enabled = coalesce(facility.setdownload_enabled, global.setDownloaded.enabled)
--effective_retry_max_attempts = coalesce(facility.retry_max_attempts, 2)

-- AME schema (encrypted-at-rest, app decrypts on read)
alter table claims.facility_dhpo_config
    add column if not exists login_ct  bytea,   -- AES-GCM ciphertext (base64 in app if you prefer)
    add column if not exists pwd_ct    bytea,
    add column if not exists enc_meta  jsonb default '{}'::jsonb;  -- algo, keyId, iv sizes, version

-- optional: remove plain columns once migrated
-- alter table claims.facility_dhpo_config drop column login_plain;
-- alter table claims.facility_dhpo_config drop column pwd_plain;



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\docs\ingestion\ERROR_CODES.md =====

Code: DUP_SUBMISSION_NO_RESUB
Stage: VALIDATE
Object: CLAIM
When: A claim appears again in Claim.Submission without <Resubmission>.
Action: Skip claim; file continues. No ACK for file if any hard failure occurs.
Ops Resolution: Verify if resend was accidental; request remitter to include <Resubmission> if intended.
Logged Fields: ingestion_file_id, claim_id (object_key), message.

Code: PARSE_DATE_INVALID
Stage: PARSE
Object: CLAIM or ACTIVITY
When: Date value not parseable (DHPO/ISO variants supported).
Action: Log error with claim/activity id; skip offending node; continue file if safe.



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\docs\ingestion\INGESTION_FLOW.md =====

# Claims App — **Complete Ingestion Flow (SOAP ? DB)**
Updated: 2025-09-07 02:53 UTC+05:30

> **Scope**: End-to-end behavior from **SOAP fetch** to **optional ACK**, including backpressure, parsing/validation, persistence, event projection, verification gating, audit/metrics, scaling, failure posture, and operational runbook.  
> **Roots supported**: **Claim.Submission** and **Remittance.Advice** (StAX streaming).  
> **Profiles**: `ingestion` (worker), `soap` | `localfs` (choose exactly one fetcher/acker), `api` (read-only server), `adminjobs` (nightly ops).

---

## 0) TL;DR
**Fetcher (SOAP)** ? *stage to temp* ? *fsync* ? *atomic rename to* `ready/` ? **Queue (bounded)** ? **Orchestrator (scheduled drain)** ? **Parse (StAX)** ? **Validate** ? **Map** ? **Persist** (batched, idempotent by DB uniques) ? **Events/Timeline** ? **Verify** (counts, orphans, uniques) ? **(optional) ACK** ? **Audit & Metrics**.

---

## 1) Runtime Topology & Profiles
- **Single codebase, two processes** in typical deployments:
  - **Ingestion Worker** (`ingestion` + one of `soap` or `localfs`): runs fetcher, orchestrator, pipeline, verify, audit, and (optional) ACK.
  - **API Server** (`api`): JWT/RBAC-guarded read-only endpoints (no fetch/scheduler/ack).
  - **Admin Jobs** (`adminjobs`) optional: nightly verification & CSV exports.
- **Only one fetcher/acker active** at a time by profiles: `localfs` ? `NoopAcker`; `soap` ? `SoapAcker`.
- **Least privilege**: RW DB creds for ingestion; RO for API/adminjobs. No runtime uses DDL/admin roles.

---

## 2) SOAP Fetcher — What Exactly Happens
1. **List “ready” files** at the upstream (DHPO) endpoint. *(Configurable polling cadence; see TODO)*
2. For each file:
   - **Stream download to a temp path**, not directly into `ready/`.  
   - `fsync` the temp file to ensure durability.
   - **Atomic rename** temp ? `ready/` (visibility boundary: downstream only sees fully written files).
   - Emit `fileId` (remote ID or filename) to the **bounded ingress queue**.
3. **Backpressure-aware**: if queue is full, fetcher **pauses** pulling; it **resumes** when the orchestrator drains items.

**Robustness choices**:
- **Streaming I/O** avoids large heap usage.  
- **fsync + atomic rename** eliminates half-written/partial files from being processed.  
- **Pause/Resume** integrates fetch cadence with downstream capacity (DB, CPU).

> **TODO (later)**: Set SOAP list cadence to **every 30 minutes** with jitter (e.g., `*/30` ± up to 2 minutes) to avoid thundering herd.

---

## 3) Bounded Ingress Queue (Pressure Valve)
- Small **BlockingQueue** (e.g., 16) that caps memory and smooths bursts.
- `offer(fileId)` returns **false** ? fetcher immediately **pauses** (no more pulls).
- After processing, orchestrator **resume()**s fetcher when capacity is available.
- **Metrics**: queue depth, pause/resume counts, time-in-queue.

**Tuning knobs**:
- Queue capacity, parser worker count, DB batch size, per-file vs per-chunk transactions.

---

## 4) Orchestrator Drain (Steady Trickle)
- Lightweight `@Scheduled(fixedDelayString)` drain with **initialDelay=0**.
- Each tick: **poll** a handful of fileIds from the queue and submit one ingestion task per file to the **parser executor**.
- After each file completes (success/fail), **resume** the fetcher if it was paused.

---

## 5) Pipeline for a Single File
### 5.1 Parse (StAX) ? DTOs
- StAX streaming parser reads **Header** first:
  - `SenderID, ReceiverID, TransactionDate, RecordCount, DispositionFlag`.
  - Normalize **TransactionDate** to UTC (maintain original offset if needed for audit).
- **Only two roots** supported:
  - **Submission**: Claim ? Encounter ? Diagnosis; Activity ? Observation; Resubmission?; Contract?  
  - **Remittance**: Claim (ID, IDPayer, …, DateSettlement?); optional Encounter/Facility; Activity with PaymentAmount/DenialCode.
- **RecordCount enforcement**: count parsed `Claim` elements and match header’s RecordCount; mismatch = file-level validation error.

### 5.2 Validate
- **XSD-required fields** enforced (header + required claim, activity, etc.).
- **Business checks** (examples):
  - Money fields scale to 2; reject negatives unless spec allows.
  - DateTime parsing strict; reject impossible values.
  - Oversized strings trimmed; log truncation.
- **Error isolation**: invalid objects are logged and skipped; **good claims continue** (one bad claim doesn’t sink the file).

### 5.3 Map ? Entities
- DTOs ? JPA/JDBC entities via mappers.
- Sensitive fields (e.g., Emirates ID) optionally **hashed/masked** by toggle before persist.

### 5.4 Persist (Insert-Only, Batched, Idempotent)
- Insert **ingestion_file** with header + **raw XML bytes** (SSOT), keyed by **unique `file_id`**.
- Insert the rest of the graph depending on root:
  - **Submission**: submission, claim, encounter, diagnosis, activity, observation, resubmission (and optional claim_attachment/contract).
  - **Remittance**: remittance, remittance_claim, remittance_activity.
- **Idempotency by DB uniques** (exactly-once effect):
  - `ingestion_file.file_id`
  - `(claim_id, activity_id)` (per claim)
  - **Observation de-dup index** `(activity_id, obs_type, obs_code, md5(value_text))`
  - `(remittance_id, claim_key_id)` and `(remittance_claim_id, activity_id)`
  - **Event uniqueness**: one SUBMISSION per claim; `(claim_key_id, type, event_time)` unique
- **Conflict policy**: duplicates are **ignored** (safe replay).
- **Transactions**:
  - Default: *per-file* transaction.
  - For very large files: switch to *per-chunk* commits targeting **<5s** per commit to reduce lock pressure.
- **Batch size**: start around **1000** rows; adjust based on DB p95 latency.

### 5.5 Events & Claim Status Timeline
- **Events**: `SUBMISSION (1)`, `RESUBMISSION (2)`, `REMITTANCE (3)` per claim key.
  - `event_time = Header.TransactionDate`; provenance: FK to `ingestion_file`.
  - **Snapshots**: activities ? `claim_event_activity`; observations ? `event_observation`.
- **Status timeline** (derived rules):
  - **PAID**: sum(payment) == claim.net
  - **PARTIALLY_PAID**: 0 < sum(payment) < claim.net
  - **REJECTED**: denial & sum(payment) == 0
  - **SUBMITTED/RESUBMITTED/UNKNOWN** otherwise
  - Last timeline row = current status.

### 5.6 Verify (Gates ACK)
- Post-file **verification** runs immediately after persist:
  - **Counts** match expected (claims, activities, etc.).
  - **Orphans** = 0 across chains.
  - **Uniques** hold (no dupes slipped through).
- Result: **PASS/FAIL** stored in audit; used to gate ACK.

### 5.7 ACK (Optional, Toggle-Controlled)
- If `ack.enabled=true` **and** verify passed:
  - Perform **best-effort** ACK upstream with the original `fileId`.
  - ACK failures are logged; **no data rollback**.
- Default: **ACK OFF** (enable after a burn-in period with green verifies).

---

## 6) Audit & Observability
- **Per-file audit**: header echo, parsed vs persisted counts, verify status, ACK attempted/sent, error summaries.
- **Batch metrics** per stage (PARSE, VALIDATE, MAP, INSERT_*, PROJECT_EVENTS, VERIFY, ACK): rows attempted/inserted, conflicts ignored, retries, timing.
- **Error log** (fine-grained): stage, object key (e.g., Claim.ID), message, retryable flag, stack excerpt.
- **KPI view / exports** (nightly via cron or `adminjobs`): files ok/fail/already, parsed/persisted counts, duplicates, orphans, last-24h errors, events coverage.

**SLIs**: file success rate, verify pass rate, queue depth p95, claims/sec/worker, DB p95 insert latency, conflict rate, ACK success rate.  
**Alerts**: verify failures >0 recent, queue >80% for >X mins, ACK errors >Y%, DB p95 > target for Z mins.

---

## 7) Scaling Strategy (Tuning Order)
1) If queue often **empty**: increase **fetcher concurrency** (SOAP) and/or **poll cadence**.  
2) Increase **parser workers** (= CPU cores).  
3) Adjust **batch size** (smaller if DB latency/locks rise).  
4) Switch to **per-chunk transactions** (<5s).  
5) Consider **horizontal split**: additional ingestion worker only if upstream can partition workload.

**DB**: indexes healthy, autovacuum/analyze tuned, WAL/IO provisioned, connection pool steady-state sized.

---

## 8) Failure Posture
- **Validation failures**: claim/file logged as FAIL; good claims continue; **no ACK**.  
- **Transient DB/network**: retried; idempotency guarantees safe replays; failed ACKs don’t rollback.  
- **Queue saturation**: fetcher pauses; resumes when capacity returns.  
- **Corrupt/partial downloads**: prevented by atomic rename; corrupt content detected at parse ? logged/skipped.  
- **Disk full**: fetcher pauses on I/O errors; alert; no premature ACK.

---

## 9) Security & Secrets
- **RW vs RO** DB users (least privilege).  
- Secrets via **App-Managed Encryption** or secret manager.  
- **Hash/mask** toggle for sensitive claim fields.  
- **JWT/RBAC** on API & admin endpoints; admin actions audited.

---

## 10) Improvements (Proposed)
1. SOAP cadence **every 30 min** with jitter.  
2. File **checksum** (remote ETag/SHA-256 vs local) stored in audit.  
3. Optional **content-hash file_id** (dedupe same content with different names).  
4. **Attachment policy** (size caps; optional object storage).  
5. **Stage-to-disk janitor** for orphaned tmp files.  
6. Health endpoints include **backlog depth** and **last verify**.  
7. **Circuit breaker + backoff** for SOAP list/download/ack.  
8. **Ops endpoints**: pause/resume/drain-now/requeue.  
9. **DR**: WORM archive of all pulled XML; replay safe via idempotency.  
10. **Partitioning/Archival** per ADR thresholds.

---

## 11) PlantUML Sequence (paste into your renderer)
```plantuml
@startuml
autonumber
actor Upstream as U
participant "SOAP Fetcher" as F
participant "Ingress Queue" as Q
participant "Orchestrator (Scheduled Drain)" as O
participant "Pipeline" as P
participant "PostgreSQL (claims)" as DB
participant "Acker (optional)" as A

== Pull & Stage ==
U -> F: List ready files (polling cadence; add jitter)
loop each file
  F -> F: stream download -> tmp/
  F -> F: fsync(tmp)
  F -> F: atomic rename tmp -> ready/
  F -> Q: offer(fileId)
  Q -> F: (full?) yes => pause() else continue
end

== Drain ==
O -> Q: poll up to N
Q --> O: fileId(s)
loop for each fileId
  O -> P: process(fileId) (executor worker)
  P -> DB: insert ingestion_file (unique file_id) + raw XML
  P -> DB: insert graph (submission or remittance), batched
  P -> DB: project events + snapshots + status timeline
  P -> DB: verify per-file (counts, orphans=0, uniques hold)
  alt Verify PASSED & ACK enabled
    P -> A: ack(fileId) (best effort)
  else
    P -> A: (skip ack)
  end
  P -> DB: write per-file audit + batch metrics + errors
  O -> F: resume() if queue below watermark
end
@enduml
```



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\docs\ingestion\SSOT_MAP.md =====

| XSD Path               | DTO Field                  | Table.Column                           | Notes        |
| ---------------------- | -------------------------- | -------------------------------------- | ------------ |
| Header/SenderID        | HeaderDto.senderId         | ingestion\_file.sender\_id             | required     |
| Claim/ID               | ClaimSubmissionClaimDto.id | claim\_key.claim\_id                   | unique key   |
| Claim/Encounter/Start  | EncounterDto.start         | encounter.start\_at                    | utc          |
| Activity/PaymentAmount | ActivityDto.paymentAmount  | remittance\_activity.payment\_amount   | nullable     |
| Resubmission/Type      | ResubmissionDto.type       | claim\_resubmission.resubmission\_type | when present |



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\docs\ingestion\TESTPLAN.md =====

# Claims App — Ingestion & Remittance **TEST PLAN**
Version: 1.0 • Date: 2025-09-07 02:16 UTC+05:30 • Owner: Claims Engineering (Ingestion) • SUT: Java 21 + Spring Boot 3.x + PostgreSQL 15+

> Covers: Fetcher ? Parser (StAX) ? DTO ? Validate ? Mapper ? Persist ? Events/Timeline ? Verify ? Audit ? (optional) ACK  
> Roots: **Claim.Submission**, **Remittance.Advice**. Profiles: `ingestion` (`localfs`|`soap`), `api`, `adminjobs`.

---

## 0. References (living docs)
- DDL & schema: `chatgpt_ddl.txt`
- Verification SQL: `claims_verify.sql`
- Strategy & Master Plan: `claims_ingestion_MASTER_plan.pdf`
- API & Deployment Blueprint: `claims_ingestion_api_blueprint.pdf`
- XSD Index for parser/mappers: `XSD Index — ClaimSubmission & RemittanceAdvice.txt`
- Decision Records (ADRs): `decision_records.pdf`
- Metrics & Admin Jobs Plan: `metrics_reports_and_api_plan.pdf`

> Keep these synced with code. If docs change, update tests accordingly.

---

## 1. Scope
**In-scope**
- Ingestion worker (all stages), idempotency, partial failure isolation
- XML parse/validate for both roots (Submission, Remittance)
- Persistence (JDBC/JPA) with uniqueness keys enforcing exactly-once semantics
- Events + Claim Status Timeline projection
- Per-file verification gating for ACK
- Nightly verification exports (cron or `adminjobs` profile)
- Security roles for DB access (RW/RO) and Admin API JWT guards
- Config toggles & profiles behavior

**Out-of-scope (v1)**
- Business UI/Portals, Analytics UI
- External BI dashboards beyond CSV exports
- Full multi-tenant RLS policies (planned later)
- Data warehouse export/archival pipelines

---

## 2. Test Environments & Config
### 2.1 Environments
- **DEV (Local):** Single node app + single Postgres. Profiles: `ingestion,localfs` and `api` separately.
- **SIT (Server/VM):** Two processes (Ingestion Worker, API Server). Optional: `adminjobs` profile for nightly tasks.
- **(Optional) UAT:** Mirrors SIT. SOAP credentials & DHPO endpoint configured.

### 2.2 DB Roles & Users
- `claims_app_rw` (ingestion writes) mapped to `ingestor_user`
- `claims_app_ro` (read-only API/adminjobs) mapped to `report_user`
- `claims_admin` (DDL/migrations) mapped to `migrate_user`

**Checks**
- Grants: USAGE/SELECT/INSERT/UPDATE for RW; SELECT for RO; sequences usage for RW.
- No app running with `claims_admin` in any env.

### 2.3 Config Toggles (must be testable)
- `claims.ack.enabled` (default **false**)
- `claims.ingestion.concurrency.parserWorkers`
- `claims.ingestion.batch.size`
- `claims.ingestion.tx.perFile` vs `claims.ingestion.tx.perChunk`
- `claims.security.hashSensitive` (hash/obfuscate sensitive)
- **Fetcher profiles:** `localfs` vs `soap` (only one active at a time)
- **Stage-to-disk** mode (if present): `true` vs `false` behavior

---

## 3. Test Data Strategy
Prepare canonical XML sets for **both roots**:
- **MIN**: Smallest valid file (1 claim, 0 encounters, 0 observations)
- **TYPICAL**: 25–100 claims with realistic variety
- **MAX**: Large file to hit batching (= 5k–50k claims depending on environment)
- **MIXED**: Good + bad claims in the same file (error isolation)
- **EDGE**: Corrupt date, missing required fields, duplicate business keys, huge Observation values, unknown Observation types, base64 attachment corrupt, uncommon timezones
- **CROSS-FILE**: Duplicate `file_id`, duplicate `Claim/ID` in different files, same activities repeated via re-ingest

For Remittance:
- Claims with **positive payments** (fully paid, partially paid), **denials with zero payment**, and **missing DateSettlement**.

Artifacts:
- Expected DTO counts (per file), expected totals for persistence, and expected final statuses per claim.

---

## 4. Pre-Checks (Preconditions)
1. **DDL bootstrap** applied cleanly (all tables, indexes, triggers, views).
2. **Extensions** present: `pg_trgm`, `citext`, `pgcrypto`.
3. **Roles & grants** created and validated.
4. **LocalFS input directories** exist for `ready/` watcher (DEV).
5. **SOAP credentials** (SIT/UAT) available & masked in logs.
6. **Verification SQL** accessible for manual execution.
7. **Profiles** set per process (no dual fetchers/ackers active simultaneously).

---

## 5. Test Cases
Each test includes: **ID, Pre, Steps, Expected, Notes**.

### 5.1 Header & Record Count (Both Roots)
- **TC-HDR-001:** Valid header parses & persists to `ingestion_file` (sender/receiver/txnDate/recordCount/disposition).
- **TC-HDR-002:** RecordCount equals parsed `Claim` count — mismatch triggers validation error, file marked FAIL, no ACK.
- **TC-HDR-003:** TransactionDate timezone normalization to UTC; event_time uses header date.

### 5.2 Submission — Required Fields & Structure
- **TC-SUB-REQ-001:** Claim with all required fields persists (`payer_id`, `provider_id`, `emirates_id_number`, `gross`, `patient_share`, `net`).
- **TC-SUB-REQ-002:** Missing any required field ? claim-level validation error; other claims in file still persist.
- **TC-SUB-ENC-001:** Encounter requireds when present (`facility_id`, `type`, `patient_id`, `start`).
- **TC-SUB-DX-001:** Diagnosis requireds when present (`type`, `code`).
- **TC-SUB-ACT-001:** Activity requireds (ID, Start, Type, Code, Quantity, Net, Clinician).
- **TC-SUB-OBS-001:** Observation dedupe: identical `(activity_id, type, code, md5(value))` is ignored by unique index.
- **TC-SUB-RES-001:** Resubmission present ? create RESUBMISSION event + `claim_resubmission` row; attachment base64 decoded to `claim_attachment` (corrupt ? logged & skipped only).

### 5.3 Remittance — Requireds & Payments
- **TC-REM-REQ-001:** Claim requireds (`ID`, `IDPayer`, `PaymentReference`) persist; optional fields tolerated.
- **TC-REM-ACT-001:** Activity requireds including `PaymentAmount` persist; duplicates by `(remittance_claim_id, activity_id)` are ignored.
- **TC-REM-FAC-001:** Optional `Encounter/FacilityID` stored on `remittance_claim.facility_id`.

### 5.4 Idempotency & Uniqueness
- **TC-UNIQ-001:** Re-ingest same `file_id` ? ingestion_file unique prevents duplicates; file marked ALREADY.
- **TC-UNIQ-002:** Duplicate `(submission_id, claim_id)`/`(claim_id, activity_id)` ignored (no second row) — conflicts counted.
- **TC-UNIQ-003:** Observation unique index prevents duplicate Observation rows.
- **TC-UNIQ-004:** Remittance pairs `(remittance_id, claim_key_id)` and `(remittance_claim_id, activity_id)` enforce idempotency.
- **TC-UNIQ-005:** Event uniqueness `(claim_key_id, type, event_time)` and SUBMISSION one-per-claim enforced.

### 5.5 Events & Status Timeline
- **TC-EVT-001:** SUBMISSION event written with `event_time` from header.
- **TC-EVT-002:** REMITTANCE event written per remittance claim.
- **TC-STAT-001:** Status derived as:
  - **PAID** when sum(payment) == claim.net
  - **PARTIALLY_PAID** when 0 < sum(payment) < claim.net
  - **REJECTED** when denial & sum(payment) == 0
  - **UNKNOWN** otherwise
- **TC-STAT-002:** Timeline rows ordered by time; last status matches expectations.

### 5.6 Error Isolation (Mixed Files)
- **TC-ISO-001:** One bad claim does **not** fail the whole file; good claims persist.
- **TC-ISO-002:** Validation errors logged to `ingestion_error` with stage/object/context; counts shown in file audit.

### 5.7 Verify & ACK Gating
- **TC-VER-001:** Post-file verify passes (counts, orphans=0, uniques hold) ? if `ack.enabled=true` then ACK attempted once.
- **TC-VER-002:** Verify fails ? no ACK; file flagged; next poll can retry depending on error type.
- **TC-VER-003:** Nightly verify job produces CSVs (kpis, orphans, duplicates, errors_24h, events_coverage) with correct permissions and retention.

### 5.8 Scheduler & Backpressure
- **TC-SCH-001:** `@Scheduled` poller ticks from start (initialDelay=0) and can be manually kicked.
- **TC-SCH-002:** Bounded queue backpressure pauses fetcher when 75% full, resumes <50% (as implemented).
- **TC-SCH-003:** Parser workers and batch size tunables affect throughput without errors.

### 5.9 Profiles & Acker
- **TC-PROF-001:** `localfs` profile uses LocalFsFetcher & NoopAcker.
- **TC-PROF-002:** `soap` profile uses SOAP fetcher & acker; ensure **only one fetcher/acker** active.
- **TC-ACK-001:** ACK attempts only on success & when enabled; best-effort; failures logged and retried per policy.

### 5.10 Security & Roles
- **TC-SEC-001:** Ingestion uses RW user only; API uses RO only; admin downloads authorized for CLAIMS_ADMIN.
- **TC-SEC-002:** Sensitive fields (Emirates ID) hashed/masked when toggle on; not exposed in API responses (if any).

### 5.11 Stage-to-Disk vs Direct
- **TC-STAGE-001:** With stageToDisk=true, batches are persisted to temp storage before DB; crash does not lose staged data.
- **TC-STAGE-002:** With stageToDisk=false, direct path works and meets integrity guarantees.

### 5.12 Performance & Soak
- **TC-PERF-001:** Throughput baseline: 80–250 claims/sec/worker on typical payloads; tune workers/batch sizes.
- **TC-PERF-002:** DB latency/locks acceptable (< target p95); adjust batch to <= 5s commit time per chunk.
- **TC-SOAK-001:** 6–12h soak run without memory leaks or backlog runaway.
- **TC-CHAOS-001:** Inject transient DB/network failures ? retries engage; no data corruption; idempotency holds.

---

## 6. Test Execution Matrices
Provide a table for each test run with **Input File**, **Profile**, **Batch/Workers**, **Result** (OK/FAIL/ALREADY), **Counts** (claims/acts/obs/events), **Verify status**, **ACK status**.

> Use the per-file shape query to summarize outputs and the verification SQL to assert integrity.

---

## 7. Acceptance Criteria Mapping
- LocalFS run persists both Submission & Remittance graphs ?
- Events & status timeline projected ?
- Profiles enforce only one fetcher/acker ?
- Uniques/idempotency green; verification SQL passes ?
- ACK OFF by default, toggle works ?

---

## 8. Entry/Exit Criteria
**Entry**: DDL present, roles configured, environment reachable, baseline test data ready.  
**Exit**: All P0/P1 cases pass; soak stable; verification job artifacts correct; no orphan/dup reports; ACK gated correctly.

---

## 9. Artifacts & Evidence
- Logs (structured), CSV exports, DB snapshots of counts & sample rows
- `v_ingestion_kpis` dashboard screenshots for target window
- Test data XMLs and expected-output manifests checked into `/testdata`

---

## 10. Ownership & Scheduling
- Test Lead: Ingestion QA Owner
- Contributors: Parser dev, Persist dev, DB owner, Ops
- Schedule: DEV ? SIT ? (optional) UAT ? Prod readiness review



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\json\add_facility_json.json =====

{
  "facilityCode": "HOSP1",
  "facilityName": "City Hospital",
  "endpointUrl": "https://dhpo.eclaimlink.ae/ValidateTransactions.asmx",
  "endpointUrlForErx": "https://dhpo.eclaimlink.ae/eRxValidateTransactions.asmx",
  "login": "dhpo_user_hosp1",
  "password": "S3cureP@ss!"
}



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\MANIFEST.md =====

# XML Test Sets (Spec-aligned)
Submission targetNamespace: urn:dhpo:claim:submission:v1
Remittance targetNamespace: urn:dhpo:remittance:advice:v1

Submission files:
- sub_ok_minimal.xml
- sub_ok_multi_claims.xml
- sub_missing_required.xml
- sub_duplicate_claims.xml
- sub_duplicate_activities.xml
- sub_new_code_discovery.xml
- sub_large_1k_claims.xml
- sub_mixed_good_bad.xml
- sub_resubmission.xml

Remittance files:
- rem_ok_match.xml
- rem_partial_pay.xml
- rem_reject.xml
- rem_unknown_claim.xml
- rem_duplicate_activity.xml
- rem_large_2k_acts.xml
- rem_match_resubmission.xml



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\README_AME.md =====

# Claims AME Post-Install & Pre-Startup Automation

This repo includes a Makefile that sets up **App-Managed Encryption (AME)** for DHPO credentials and seeds facilities automatically.
If you only want the automation: run **`make up`** and you’re done.
If you want to learn what’s happening, read on (novice-friendly).

---

## What is AME (10 seconds)
- We keep **one key** (keystore or key file) next to the app.
- The app uses it to **encrypt** facility login/password into the DB, and **decrypts** on the fly.
- You never touch SQL crypto. You use a simple **admin API** to add/rotate facilities.

---

## Quickstart

### 1) Create facilities.json (or let `make seed` create a sample)
```json
[
  {
    "facilityCode": "HOSP1",
    "facilityName": "City Hospital",
    "active": true,
    "endpointUrl": "https://qa.eclaimlink.ae/dhpo/ValidateTransactions.asmx",
    "soap12": false,
    "callerLicense": "LIC123",
    "ePartner": "EPART001",
    "login": "dhpo_user_hosp1",
    "password": "S3cureP@ss!"
  }
]

export ADMIN_TOKEN='<SUPER_ADMIN_BEARER_TOKEN>'
make up



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\xsd\ClaimSubmission.xsd =====

<xs:schema xmlns:tns="http://www.eclaimlink.ae/DHD/ValidationSchema" elementFormDefault="qualified" version="2.0" id="ClaimSubmission" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:import schemaLocation="CommonTypes.xsd" namespace="http://www.eclaimlink.ae/DHD/ValidationSchema" />
    <xs:element name="Claim.Submission">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Header">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element minOccurs="1" maxOccurs="1" name="SenderID" type="tns:HeaderSenderID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="ReceiverID" type="tns:HeaderReceiverID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="TransactionDate" type="tns:HeaderTransactionDate" />
                            <xs:element minOccurs="1" maxOccurs="1" name="RecordCount" type="tns:HeaderRecordCount" />
                            <xs:element minOccurs="1" maxOccurs="1" name="DispositionFlag" type="tns:HeaderDispositionFlag" />
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element minOccurs="1" maxOccurs="unbounded" name="Claim">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element minOccurs="1" maxOccurs="1" name="ID" type="tns:ClaimID" />
                            <xs:element minOccurs="0" maxOccurs="1" name="IDPayer" type="tns:ClaimIDPayer" />
                            <xs:element minOccurs="0" maxOccurs="1" name="MemberID" type="tns:ClaimMemberID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="PayerID" type="tns:ClaimPayerID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="ProviderID" type="tns:ClaimProviderID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="EmiratesIDNumber" type="tns:ClaimEmiratesIDNumber" />
                            <xs:element minOccurs="1" maxOccurs="1" name="Gross" type="tns:ClaimGross" />
                            <xs:element minOccurs="1" maxOccurs="1" name="PatientShare" type="tns:ClaimPatientShare" />
                            <xs:element minOccurs="1" maxOccurs="1" name="Net" type="tns:ClaimNet" />
                            <xs:element minOccurs="0" maxOccurs="1" name="Encounter">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="1" maxOccurs="1" name="FacilityID" type="tns:EncounterFacilityID" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:EncounterType" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="PatientID" type="tns:EncounterPatientID" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Start" type="tns:EncounterStart" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="End" type="tns:EncounterEnd" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="StartType" type="tns:EncounterStartType" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="EndType" type="tns:EncounterEndType" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="TransferSource" type="tns:EncounterTransferSource" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="TransferDestination" type="tns:EncounterTransferDestination" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element minOccurs="1" maxOccurs="unbounded" name="Diagnosis">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:DiagnosisType" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Code" type="tns:DiagnosisCode" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element minOccurs="1" maxOccurs="unbounded" name="Activity">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="1" maxOccurs="1" name="ID" type="tns:ActivityID"  />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Start" type="tns:ActivityStart" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:ActivityType" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Code" type="tns:ActivityCode" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Quantity" type="tns:ActivityQuantity" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Net" type="tns:ActivityNet" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Clinician" type="tns:ActivityClinician" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="PriorAuthorizationID" type="tns:ActivityPriorAuthorizationID" />
                                        <xs:element minOccurs="0" maxOccurs="unbounded" name="Observation">
                                            <xs:complexType>
                                                <xs:sequence>
                                                    <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:ObservationType" />
                                                    <xs:element minOccurs="1" maxOccurs="1" name="Code" type="tns:ObservationCode" />
                                                    <xs:element minOccurs="0" maxOccurs="1" name="Value" type="tns:ObservationValue" />
                                                    <xs:element minOccurs="0" maxOccurs="1" name="ValueType" type="tns:ObservationValueType" />
                                                </xs:sequence>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element minOccurs="0" maxOccurs="1" name="Resubmission">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:ResubmissionType" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Comment" type="tns:ResubmissionComment" />
                                        <xs:element minOccurs="0" maxOccurs="1"  name="Attachment" type="tns:ResubmissionAttachments" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element minOccurs="0" maxOccurs="1"  name="Contract">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="0" maxOccurs="1"  name="PackageName" type="tns:ContractPackageName" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\xsd\CommonTypes.xsd =====

<xs:schema xmlns:xsd="undefined" elementFormDefault="qualified" id="CommonTypes" targetNamespace="http://www.eclaimlink.ae/DHD/ValidationSchema" version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <!-- Header Common Types -->
    <xs:simpleType name="HeaderSenderID">
        <xs:annotation>
            <xs:documentation>
                -   eClaimLink Provider, Payer or TPA ID.
                -   For transaction pairs the receiver of the first transaction must be the sender of the second transaction.
                -   Example if a TPA receives a ClaimSubmission from a provider, then that TPA (not the insurer) must send the RemittanceAdvice to the provider
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="HeaderReceiverID">
        <xs:annotation>
            <xs:documentation>
                -   DHPO eClaimLink ID of the Provider, Insurer or TPA receiving information.
                -   For transaction pairs the receiver of the first transaction must be the sender of the second transaction
                -   Example if a TPA receives a ClaimSubmission from a provider, then that TPA (not the insurer) must send the RemittanceAdvice to the provider.
                - ID of the facility receiving the MemberRegister Default "DHA"
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="HeaderTPAID">
        <xs:annotation>
            <xs:documentation>
                -   DHPO eClaimLink ID of the TPA
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="HeaderPayerID">
        <xs:annotation>
            <xs:documentation>
                -   DHPO eClaimLink ID of the Insurer or Self-Paid
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="HeaderIntermediaryID">
        <xs:annotation>
            <xs:documentation>
                -   DHPO eClaimLink ID of the Intermediary
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="HeaderTransactionDate">
        <xs:annotation>
            <xs:documentation>
                -   System generated date and time specifying when the transaction was generated.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="HeaderRecordCount">
        <xs:annotation>
            <xs:documentation>
                -   The number of records contained in the XML file at the highest level.
                -   Example The number of Claims in the ClaimSubmission file.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:nonNegativeInteger" />
    </xs:simpleType>
    <xs:simpleType name="HeaderDispositionFlag">
        <xs:annotation>
            <xs:documentation>
                -   Flag to determine if the transaction file is either a test or production file.
                -   TEST files will be validated by the DHPO, but will not be stored or shared with the receiver.
                -   PRODUCTION files will be validated, stored at the DHPO and shared with the receiver.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="TEST" />
            <xs:enumeration value="PRODUCTION" />
        </xs:restriction>
    </xs:simpleType>
    <!-- General CommonTypes -->
    <xs:simpleType name="TimeForm">
        <xs:annotation>
            <xs:documentation>
                -   Time data type enforcing the format: "HH:MM".
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="(20|21|22|23|[0-1]?\d):[0-5]?\d" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DateForm">
        <xs:annotation>
            <xs:documentation>
                -   Date data type enforcing the format: "dd/mm/yyyy".
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:pattern value="\d{2}/\d{2}/\d{4}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DateTimeForm">
        <xs:annotation>
            <xs:documentation>
                -   Date + Time data type enforcing the format: "dd/mm/yyyy HH:MM".
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:pattern value="\d{2}/\d{2}/\d{4} (20|21|22|23|[0-1]?\d):[0-5]?\d" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterID">
        <xs:annotation>
            <xs:documentation>
                -	A unique number assigned by the healthcare provider to identify an Encounter.
                -	Note: It will help the provider and insurer locate the Encounter.
                -	This number will also facilitate posting of payment information and identification of the billed Encounter.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterFacilityID">
        <xs:annotation>
            <xs:documentation>
                -	This is eClaimLink ID  of the facility responsible for the Encounter.
                -	Some of the fields: PatientNationality, EncounterFacilityID, ClaimPayerID and EncounterDiagnosisPrincipal have a large number of sometimes changing attributes.
                -	The latest version of these attributes can be downloaded from https://eclaimlink.ae/CodingSets.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterType">
        <xs:annotation>
            <xs:documentation>
                -	Type of the encounter should be one of the following:
                -   1 = No Bed + No emergency room
                -   2 = No Bed + Emergency room
                -   3 = Inpatient Bed + No emergency room
                -   4 = Inpatient Bed + Emergency room
                -   5 = Daycase Bed + No emergency room
                -   6 = Daycase Bed + Emergency room
                -   7 = Nationals Screening
                -   8 = New Visa Screening
                -   9 = Renewal Visa Screening
                -   10 = PRE-OP TEST PROCEDURES
                -   12 = Home
                -   13 = Assisted Living Facility
                -   15 = Mobile Unit
                -   41 = Ambulance - Land
                -   42 = Ambulance - Air or Water
                -	Note: There are different ways to classify Encounters as inpatients, daycases, emergencies and outpatients. They vary according to whether the Encounter went past midnight, lasted for more than 24 hours, involved a hospital bed and whether they involved an emergency room. To benchmark with different countries, one needs to know, whether the patient was in the emergency room, and whether the patient occupied a hospital bed.
                -	Inpatient bed: A licensed bed approved by the competent authority which is assigned to a patient who is arriving to a health care facility for an emergent, urgent or elective/planned Encounter. Beds assigned temporarily for "holding" purposes in a no bed situation may be designated and included in hospital occupancy rate calculation (e.g. emergency room, recovery room). Only beds included in the licensed inpatient bed complement will be used for purposes of hospital occupancy rate calculation. Beds may have an associated accommodation value such as private (i.e. single bed/room) or shared (i.e. multiple beds/room).
                -	Beds included in the inpatient bed complement:
                -   Beds in general wards or units set up and staffed for inpatient services
                -   Beds in special care units set up and staffed for inpatient services such as intensive care, coronary care, neonatal intensive care, paediatric intensive care, medical and surgical step-down, burn units
                -	Beds excluded from the inpatient bed complement:
                -   Beds/cots for healthy newborns
                -   Beds in Day Care units, such as surgical, medical, paediatric day care, interventional radiology
                -   Beds in Dialysis units
                -   Beds in Labour Suites (e.g. birth day beds, birthing chairs)
                -   Beds in Operating Theatre
                -   Temporary beds such as stretchers
                -   Chairs, Cots or Beds used to accommodate sitters, parents, guardians accompanying patients or sick children and healthy baby accompanying a hospitalized breast feeding mother
                -   Beds closed during renovation of patient care areas when approved by the competent authority
                -	Daycase bed: Daycase beds, also known as observation beds, are beds used in Day Care units such as surgical, medical, paediatric day care interventional radiology. They are not included in the inpatient bed complement.
                -	Restrictions: Only values allowed are:
                -   1 = No Bed + No emergency room
                -   2 = No Bed + Emergency room
                -   3 = Inpatient Bed + No emergency room
                -   4 = Inpatient Bed + Emergency room
                -   5 = Daycase Bed + No emergency room
                -   6 = Daycase Bed + Emergency room
                -   7 = Nationals Screening
                -   8 = New Visa Screening
                -   9 = Renewal Visa Screening
                -   10 = PRE-OP TEST PROCEDURES
                -   12 = Home
                -   13 = Assisted Living Facility
                -   15 = Mobile Unit
                -   41 = Ambulance - Land
                -   42 = Ambulance - Air or Water.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
            <xs:enumeration value="8" />
            <xs:enumeration value="9" />
            <xs:enumeration value="10" />
            <xs:enumeration value="12" />
            <xs:enumeration value="13" />
            <xs:enumeration value="15" />
            <xs:enumeration value="41" />
            <xs:enumeration value="42" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterPatientID">
        <xs:annotation>
            <xs:documentation>
                -	The unique number a healthcare provider assigns to a patient.
                -	This is often known as the medical record number.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterStart">
        <xs:annotation>
            <xs:documentation>
                -	EncounterStart is the date and time at which the patient comes under the care of a responsible clinician.
                -   For Elective patients this will typically be the date and time of the visit registration/admission on arrival of the patient at the healthcare facility.
                -   For Emergency patients this will typically be the date and time of the registration and admission on arrival of the patient at the healthcare facility.
                -   For Transfer patients between facilities (i.e. inter-hospital transfers), this will typically be the date and time of the visit registration and admission on arrival of the patient at the receiving healthcare facility.
                -   For Live birth this will typically be the date and time of the registration and admission of the newborn at the healthcare facility. The Encounter start will also be the date and time of birth.
                -   For Stillbirth this will typically be the date and time of the registration of the stillborn at the healthcare facility.  The Encounter start will also be the date and time of stillbirth.
                -   For Death on arrival this will typically be the date and time of the visit registration on arrival of the patient at the healthcare facility for pronouncement.
                -	Restrictions: Needs to be after 01/06/2012 and before the present.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q6="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q6:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="EncounterEnd">
        <xs:annotation>
            <xs:documentation>
                -	In general this is the time the patient ceases to be under the direct care of a responsible clinician
                -   For inpatients and day patients this would be the discharge date and time.
                -   For emergency patients this would be the time that the patient was released from the ER
                -	Note: EncounterEnd is not required for outpatients, even though the field logic applies analogously to other outpatients.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q7="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q7:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="EncounterStartType">
        <xs:annotation>
            <xs:documentation>
                -	EncounterStartType is
                -   1 = Elective, i.e., an Encounter is scheduled in advance
                -   2 = Emergency
                -   3 = Transfer, i.e., primarily inter-hospital transfers, not between wards within a hospital
                -   4 = Live birth
                -   5 = Still birth
                -   6 = Dead On Arrival
                -   7 = Continuing Encounter
                -	Example 1: An urgent referral from an outpatient clinic to the cardiology ward, i.e., not scheduled, would be considered as EncounterStartType 2 = Emergency, and EncounterType would be 3 = Inpatient bed + No emergency room
                -	Example 2: A patient is referred to a consultant, by her general practitioner, and an appointment is scheduled for two weeks later. This outpatient appointment has EncounterStartType 1 = Elective.
                -	Restrictions: Only values allowed are
                -   1 = Elective
                -   2 = Emergency
                -   3 = Transfer
                -   4 = Live birth
                -   5 = Still birth
                -   6 = Dead On Arrival
                -   7 = Continuing Encounter.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="positive-integer-or-empty">
        <xs:annotation>
            <xs:documentation>
                -	The number-or-normal values can be either a positive integer or an empty string. This is used for the content of the ensemble element.
            </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="xs:positiveInteger">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="1" />
                    <xs:enumeration value="2" />
                    <xs:enumeration value="3" />
                    <xs:enumeration value="4" />
                    <xs:enumeration value="5" />
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    <xs:simpleType name="EncounterEndType">
        <xs:annotation>
            <xs:documentation>
                -	How the patient was discharged.
                -   1 = Discharged with approval
                -   2 = Discharged against advice
                -   3 = Discharged absent without leave
                -   4 = Discharge transfer to acute care
                -   5 = Deceased
                -   6 = Not discharged
                -   7 = Discharge transfer to non-acute care(Transfer to long term care).
                -   8 = Administrative discharge

            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
            <xs:enumeration value="8" />


        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterSpeciality">
        <xs:annotation>
            <xs:documentation>
                -	The predominant speciality of the primary caregiver for the Encounter.
                -	Note: As there are at present no detailed standardized speciality definitions, providers should use their own, pre-existing naming conventions.
                -	Example: Urology
                -	Example: Cardiology.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="EncounterLocation">
        <xs:annotation>
            <xs:documentation>
                -	The name used by the provider to describe the location where the Encounter took place. If the patient visited an outpatient clinic, this would be the name used by the provider for the particular clinic. In some cases, where the patient was in multiple inpatient locations while in the healthcare facility, the discharge location should be used.  If the patient was in multiple clinics on the same day, each visit would typically be a separate Encounter, and the clinic location should be reported for each Encounter.
                -	Example: ENT Clinic
                -	Example: Cardiology Ward 3.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterTransferSource">
        <xs:annotation>
            <xs:documentation>
                -	EncounterTransferSource is the healthcare facility from where a hospital transfer originated (EncounterStartType = 3 Transfer)
                -   The originating healthcare facility is described by eClaimLink ID.
                -   If the patient has insurance coverage, enter eClaimLink insurance ID.
                -   If the patient is neither insured by a DHA insurance nor paying SelfPay.
                -	Restrictions: The latest version of these attributes can be downloaded from http://www.eclaimlink.ae/CodingSets.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="100" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EncounterTransferDestination">
        <xs:annotation>
            <xs:documentation>
                -	EncounterTransferDestination is the healthcare facility to which a hospital transfer is made at the end of an Encounter (EncounterEndType = 4 Transfer)
                -   This is eClaimLink's unique facility ID.
                -   If the patient has insurance coverage, enter eClaimLink?s insurance ID number
                -	Restrictions: The latest version of these attributes can be downloaded from http://www.eclaimlink.ae/CodingSets.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="100" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityID">
        <xs:annotation>
            <xs:documentation>
                -	Unique identifier of activity within a claim.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityStart">
        <xs:annotation>
            <xs:documentation>
                -	The date and time at which Activity started.
                -	For PriorAuthorizations, this refers to the date on which the Activity is scheduled/prescribed.
                -	Note: If the date, but not the time is not recorded, the time should be assumed to be 00:00
                -	Restrictions: Needs to be after 01/06/2012 and before the present.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q8="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q8:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ActivityType">
        <xs:annotation>
            <xs:documentation>
                -	ActivityType classifies the type of activity. 3 = CPT; 4 = HCPCS; 5 = Drug; 6 = Dental; 8 = Service Code;9 = DRG; 10 = Scientific Code
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="8" />
            <xs:enumeration value="9" />
            <xs:enumeration value="10" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityCode">
        <xs:annotation>
            <xs:documentation>
                -	ActivityCode is the code, specified by ActivityType, for the Activity performed.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityQuantity">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the number of units (quantity) for a specific Activity.
                -	For PriorAuthorizations this refers to the authorized number of units (quantity).
                -	Example:
                -   A patient is admitted to the hospital for en elective surgery and was assigned a hospital bed in a private room.
                -   The patient stayed at the hospital for 3 days at the private room.
                -   The ActivityQuantity for the private room Activity is 3.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityNet">
        <xs:annotation>
            <xs:documentation>
                -	The net charges billed by the provider to the Payer for this Activity.
                -	For PriorRequests this is the estimated amount requested, not the amount billed.
                -	For PriorAuthorization, if there is a Denial/Adjustment, then Activity.Net reflects the available limit.
                -	Note: For non-paying, non-insured patients, where a pro-forma invoice is created, this should be the gross amount that would have been charged.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ActivityList">
        <xs:annotation>
            <xs:documentation>
                -	ActivityList describes the list price before any adjustments of discounts.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityClinician">
        <xs:annotation>
            <xs:documentation>
                -	In general the Clinician is the person providing the treatment or care for the patient.
                -	Exceptions
                -   The Clinician is the ordering physician for labs, x-rays, prescriptions, other tests.
                -   The Clinician is the attending consultant physician at the time of discharge of the patient from the hospital if the Activity is an inpatient Service Code .
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityPriorAuthorizationID">
        <xs:annotation>
            <xs:documentation>
                -	The Prior Authorization ID.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityGross">
        <xs:annotation>
            <xs:documentation>
                -	The total AED amount of the charges included on the Activity.
                -	RemittanceActivityGross includes any patient financial responsibility for the Activity, such as co-pays and deductibles, as well as charges made to other insurers for the Encounter(s) covered by the Activity.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ActivityPatientShare">
        <xs:annotation>
            <xs:documentation>
                -	Any fee the provider have effectively collected from the patient.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ActivityPaymentAmount">
        <xs:annotation>
            <xs:documentation>
                -	Amount Approved to be paid by the payer for the activity.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ActivityDenialCode">
        <xs:annotation>
            <xs:documentation>
                -	The denial code if the claim is denied by the payer.
                -	The list of denial codes can be found at http://www.eclaimlink.ae/CodingSets.aspx .
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ObservationType">
        <xs:annotation>
            <xs:documentation>
                -	The type of the observation:
                -   LOINC
                -   Text
                -   File
                -   Universal Dental
                -   Financial
                -   Grouping
                -   ERX
                -   Result
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="LOINC" />
            <xs:enumeration value="Text" />
            <xs:enumeration value="File" />
            <xs:enumeration value="Universal Dental" />
            <xs:enumeration value="Financial" />
            <xs:enumeration value="Grouping" />
            <xs:enumeration value="ERX" />
            <xs:enumeration value="Result" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ObservationCode">
        <xs:annotation>
            <xs:documentation>
                -	The code describing the Observation value.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ObservationValue">
        <xs:annotation>
            <xs:documentation>
                -	The observed value of the Activity.
                -	Restriction: Must be expressed in SI Units.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="ObservationValueType">
        <xs:annotation>
            <xs:documentation>
                -	Unit of measure for the Observation.Value.
                -	Value Type should be based on the EDSC Observation Details Released on the eClaimLink Website documentation section https://www.eclaimlink.ae/dhd_documentation.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DiagnosisType">
        <xs:annotation>
            <xs:documentation>
                -	The type of diagnosis being recorded.
                -	Principal: Identifies the principal diagnosis code (full ICD-10-CM) for the condition established after examination. It will identify the nature of a disease or illness.
                -   Inpatients: Condition established, after study, to be chiefly responsible for occasioning the admission of the patient to the hospital for care.
                -   Ambulatory patients: The condition or problem that explains the clinician's assessment of the presenting symptoms/problems and corresponds to the tests or services provided. This assessment may be a suspected diagnosis or a rule-out diagnosis and is based on the patient's presenting history and physical and the physician's review of symptoms. This may also be a symptom where the underlying cause has yet to be determined.
                -   Note: A number of insurers code diagnoses related to specific Claims. Where this is done, the insurer should use this diagnosis to populate EncounterDiagnosisPrincipal.
                -   Note: This field is key to understanding (what is wrong with the patient). It contributes to understanding the health of the population.
                -	Secondary:
                -   Inpatients: All conditions that co-exist at the time of admission, or develop subsequently, which affect the treatment received and/or the length of stay. Diagnoses that refer to an earlier episode that have no bearing on the current hospital stay are to be excluded. Conditions should be coded that affect patient care in terms of requiring: Clinical evaluation, therapeutic treatment, diagnostic procedures, extended length of hospital stay, increased nursing care and/or monitoring.
                -   Ambulatory patients | All co-existing conditions, including chronic conditions that exist at the time of the Encounter or visit and require or affect patient management.
                -   External causes of injury, poisoning or adverse affect are coded as supplementary codes to the diagnosis codes of the actual condition such as Motor Vehicle Accident that caused a fracture of the tibia.
                -   Note: For quality purposes, it is important to be able to track Hospital-acquired infections.
                -	Admitting:
                -   The diagnosis that the physician identifies at the time of admission.
                -   Note:This diagnosis might differ from EncounterDiagnosisPrincipal.
                -	The classification is based on the International Classification for Disease version 10 clinical modification, US version, as outlined in the Medical Coding Guidelines published by the Dubai's Medical Coding Committee DMCC. The coding guidelines can be downloaded from http://www.eclaimlink.ae/dhd_documentation.aspx.
                -	Restrictions:
                -   The basis of a comprehensive ICD10-CM list
                -   The latest version of these attributes can be downloaded from http://www.eclaimlink.ae/CodingSets.aspx.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Principal" />
            <xs:enumeration value="Secondary" />
            <xs:enumeration value="Admitting" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DiagnosisCode">
        <xs:annotation>
            <xs:documentation>
                -	The ICD10-CM value for the diagnosis.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <!-- New fields for DRG BELOW-->
    <xs:simpleType name="DxInfoCode">
        <xs:annotation>
            <xs:documentation>
                The code value related to the DxInfoType.
                For POA type, values are:
                - "Y"= Yes. Definition: present at the time of inpatient admission.
                - "N"= No.  Definition: not present at the time of inpatient ad
                - "U"= Unknown. Definition: documentation is insufficient to determine if condition is present on admission.
                - "W"= Clinically Undetermined. Definition: provider is unable tp clinically determine whether condition was present on admission or not.
                - "1"= Unreported/Not used. Definition: exempt from POA reporting.
                - "OP"= Outpatient claim. Definition: this is an outpatient claim which does not require DRGsin Dubai (for the time being).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Y" />
            <xs:enumeration value="N" />
            <xs:enumeration value="U" />
            <xs:enumeration value="W" />
            <xs:enumeration value="1" />
            <xs:enumeration value="OP" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DxInfoType">
        <xs:annotation>
            <xs:documentation>
                -	The type of additional information for the diagnosis. | Used for POA: Present On Admission (POA) indicator it refers to the associated diagnosis code and is defined as: Present at the time the order for inpatient admission occurs.
                Conditions that develop during an outpatient encounter, including emergency department, observation, or outpatient surgery, are considered as present on admission. The POA Indicator is applied to the principal diagnosis as well as all secondary diagnoses and the external cause of injury codes that are reported.
                If a condition would not be coded and reported based on UHDDS definitions and current official coding guidelines, then the POA indicator would not be reported.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="POA" />
        </xs:restriction>
    </xs:simpleType>
    <!-- New fields for DRG ABOVE-->
    <xs:simpleType name="ResubmissionType">
        <xs:annotation>
            <xs:documentation>
                -	Values :correction, internal complaint, legacy, Reconciliation.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="correction" />
            <xs:enumeration value="internal complaint" />
            <xs:enumeration value="legacy" />
            <xs:enumeration value="reconciliation" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ResubmissionComment">
        <xs:annotation>
            <xs:documentation>
                -	Comments entered by the provider during the resubmission transaction.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="2000" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ResubmissionAttachments">
        <xs:annotation>
            <xs:documentation>
                -	Attachment provided during the resubmission transaction if necessary.
                -	Restriction: must be a base64Binary encoded
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:base64Binary" />
    </xs:simpleType>
    <!-- Person Register and Member Register Common Types -->
    <xs:simpleType name="MemberID">
        <xs:annotation>
            <xs:documentation>
                - Auto-generated ID by the DHPO for each member in align with Member Register project
                - This ID will be unique per: Person/Payer/TPA/Policy.
                - This ID should be printed on the member's health insurance card and used during the claim submission process.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonMemberType">
        <xs:annotation>
            <xs:documentation>
                The member category. Select one from the below:
                1 = UAE National
                2 = GCC National
                3 = Diplomat - Passport
                4 = Expat who's residency is issued in Dubai
                5 = Expat who's residency is issued in Emirates other than Dubai
                6 = Newborn
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="MemberRelation">
        <xs:annotation>
            <xs:documentation>
                - The information about the family relationships under the same PayerID (Insurance company).
                - This value must be (Principal) if the member does not have any relation with another insured member under the same PayerID.
                - This value will have the relation with the insured family member if one exists.
                - The field must have one of the values below:
                - Principal
                - Spouse
                - Child
                - Parent
                - Other
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Principal" />
            <xs:enumeration value="Spouse" />
            <xs:enumeration value="Parent" />
            <xs:enumeration value="Child" />
            <xs:enumeration value="Other" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="MemberRelationTo">
        <xs:annotation>
            <xs:documentation>
                - The information about the ReferenceID of the principal member of the family. Member ID should be used if reported member is the principal beneficiary.
                Reference ID can be one of the following:
                - File Number for Dubai and non-Dubai expats (MemberType = 4,5)
                - Passport# for others (MemberType = 1, 2, 3)
                - Birth Certificate ID for Newborns (MemberType = 6)
                - If the reported member has no other related family members under the same PayerID, (MemberRelation = Principal) then the MemberRelationTo value should be the same as MemberID.
                - If the reported member has a related family members under the same PayerID, (MemberRelation = Spouse, Parent, Child or Other) then the MemberRelationTo value should be the insured memberID of the family member.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonFullName">
        <xs:annotation>
            <xs:documentation>
                - The patient's Full name, as spelled in the Passport.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="100" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonFirstName">
        <xs:annotation>
            <xs:documentation>
                - The patient's first name, as spelled in the Passport.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonSecondName">
        <xs:annotation>
            <xs:documentation>
                - The patients second name as spelled in the Passport.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonFamilyName">
        <xs:annotation>
            <xs:documentation>
                - The patients family/last/surname name as spelled in the Passport.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonMaritalStatus">
        <xs:annotation>
            <xs:documentation>
                - The current martial status of the person.
                - use one of the following values:
                1 = unmarried
                2 = married
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonNationalityID">
        <xs:annotation>
            <xs:documentation>
                - The 3-digit code of the person's current nationality as defined by the passport. For Example: 101 = United Arab Emirates, 131 = Algeria.
                - Restrictions: Only values from the reference list of nationalities are allowed.
                - The latest List of Nationalities (GDRFA Nationalities List) can be downloaded from the eClaimLink website under the DHD \ Codes &amp; Lists section.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer" />
    </xs:simpleType>
    <xs:simpleType name="PersonContactNumber">
        <xs:annotation>
            <xs:documentation>
                - This is the primary mobile contact number of the insured member.
                - use the standard format (Country code) (Area Code) ( Number)
                - If the insured member is a minor, the number should be that of a parent/guardian.
                - If the insured member does not have or does not disclose a mobile number, then the mobile number should be that of their emergency contact.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[0-9]{3}-[0-9]{1,2}-[0-9]{6,8}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonBirthDate">
        <xs:annotation>
            <xs:documentation>
                -	Is the date on which a person was born or is officially deemed to have been born.
                -	In cases, where despite best efforts PerspnBirthDate is not known, but the age is known; then the birth date should be assumed to be on the 1st of January of the current year, minus the age of the person.
                -   Example: A patient arrives on January 8th 2008 and Claims he is 64 years old, but does not know his date of birth. The PatientBirthDate should be assumed to be 01/01/1944.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="PersonGender">
        <xs:annotation>
            <xs:documentation>
                -	The patient's gender
                -	Restrictions: Only values allowed are
                -   1 = male
                -   0 = female
                -   9 = unknown
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="0" />
            <xs:enumeration value="9" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonPassportNumber">
        <xs:annotation>
            <xs:documentation>
                - The passport number of the passport that has the UAE visa, or if not available, the National ID (for example GCC Nationals).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="20" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonEmail">
        <xs:annotation>
            <xs:documentation>
                - The personal email address of the insured member.
                - it is highly recommended to provide this field as per the DHA.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[^@]+@[^\.]+\..+" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonNationality">
        <xs:annotation>
            <xs:documentation>
                - The current nationality of the person, as defined by the passport.
                - Restrictions: Only values from the reference list of nationalities are allowed.
                - The latest List of Nationalities can be downloaded from https://eclaimlink.ae/CodingSets.aspx by the registered users
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonCity">
        <xs:annotation>
            <xs:documentation>
                -	The person's actual city of residence Based on Dubai Statistics Center (DSC) list
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonEmirate">
        <xs:annotation>
            <xs:documentation>
                - The Emirate from which the member's visa/residency is issued from.
                - Use the corresponding code from the following list :
                4 = Dubai
                2 = Abu Dhabi
                6 = Ajman
                9 = Fujairah
                7 = Ras Al Khaimah
                1 = Sharjah
                5 = Umm Al Quwain
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
            <xs:enumeration value="9" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonLocation">
        <xs:annotation>
            <xs:documentation>
                -   The person's actual location at city of residence Based on Dubai Statistics Center (DSC) list.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="PersonResidentialLocation">
        <xs:annotation>
            <xs:documentation>
                - The person's actual place of residence. For example: 356 = UMM SUQEIM FIRST, 346 = BUISNESS BAY.
                - Use the corresponding Location code from the predefined location list (DSC Locations) published on eClaimLink DHD.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer" />
    </xs:simpleType>
    <xs:simpleType name="PersonWorkLocation">
        <xs:annotation>
            <xs:documentation>
                - The person's actual place of work based on the Location list (DSC Locations) published on eClaimLink. For example: 356 = UMM SUQEIM FIRST, 346 = BUISNESS BAY.
                - If the place of work varies, use the location of the head office of the sponsor.
                - Use the corresponding Location code from the predefined location list (DSC Locations) published on eClaimLink DHD.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer" />
    </xs:simpleType>
    <xs:simpleType name="PersonSalary">
        <xs:annotation>
            <xs:documentation>
                - The salary bracket of the insured member.
                - the field must have one of the four values below:
                1 = salary less than 4,000 AED per month
                2 = salary between 4,001 and 12,000 AED per month
                3 = salary greater than 12,000 AED per month
                4 = No salary. This will be used for dependants or children that do not acquire a salary.
                5 = no salary. Commission only
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonCommission">
        <xs:annotation>
            <xs:documentation>
                - The field should reflect if the member is acquiring income based on a commission based plan.
                - the field must have one of the values below:
                1 = Yes, some (or all) of the member's income is based on a commission plan.
                2 = No, the member's income is not based on a commission plan.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="MemberEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                - The unique number the government assigns to a citizen.
                - When an EmiratesIDNumber is not available:
                - 000-0000-0000000-0 National without card
                - 111-1111-1111111-1 Expatriate resident without a card
                - 333-3333-3333333-3 NewBorn without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                - The unique number the government assigns to a citizen.
                - When an EmiratesIDNumber is not available :
                - 000-0000-0000000-0 National without card
                - 111-1111-1111111-1 Expatriate resident without a card
                - 222-2222-2222222-2 Non national, non-expat resident without a card
                - 999-9999-9999999-9 Unknown status, without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonUIDNumber">
        <xs:annotation>
            <xs:documentation>
                Unified Identity Number issued at the time of entry by the Ministry of Interior (MOI).
                The number is available on the Visa or residency document of the member under U.I.D Number.
                Insurance companies or TPA's will be able to validate or acquire this number from the General Directorate of Residency and Foreigners Affairs (GDRFA) previously known as Department of Naturalisation and Residency (DNRD), through the web services provided by eClaimLink. (Web serivce documentaion is available on the eClaimLink &gt; DHD &gt; Documentaion section).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="15" />
            <xs:pattern value="^[a-zA-Z0-9]*$" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonGDRFAFileNumber">
        <xs:annotation>
            <xs:documentation>
                - Unified Identity Number issued at the time of entry by the Ministry of Interior (MOI).
                - The number is available on the Visa or residency document of the member under FileNumber.
                - Insurance companies or TPA's will be able to validate or acquire this number from the General Directorate of Residency and Foreigners Affairs (GDRFA) previously known as Department of Naturalisation and Residency (DNRD), through the web services provided by eClaimLink.
                - (Web serivce documentaion is available on the eClaimLink &gt; DHD &gt; Documentaion section).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="20" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonBirthCertificateID">
        <xs:annotation>
            <xs:documentation>
                Unified Identity Number issued for new borns at the time of birth by Government Hopsitals in UAE or any hospital abroad.
                The number is available on the birth certificate
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="MemberRelationEnum">
        <xs:annotation>
            <xs:documentation>
                - The information about the family relationships under the same PayerID (Insurance company).
                - This value must be (1 = Principal) if the member does not have any relation with another insured member under the same PayerID.
                - This value will have the relation with the insured family member if one exists.
                - The field must have one of the values below:
                1 = Principal
                2 = Spouse
                3 = Child
                4 = Parent
                5 = Other
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PersonPayerID">
        <xs:annotation>
            <xs:documentation>
                -   The patient's insurance DHA payer ID.
                -   For self paid schemes this should be the eClaimLink Self Paid scheme ID assigned by the DHA.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractProductOrigin">
        <xs:annotation>
            <xs:documentation>
                - The origin of the product sold to the member. The value must be one of the following:
                2 = Abu Dhabi
                4 = Dubai
                5 = Other
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="2" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractTopUpPolicy">
        <xs:annotation>
            <xs:documentation>
                - The origin of the product sold to the member. The value must be one of the following:
                1 = TopUpPolicy
                2 = Main Policy
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractPackageName">
        <xs:annotation>
            <xs:documentation>
                -   This is the name of the insurance package taken from a list of all eClaimLink authorized benefit packages.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="100" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractPolicySequence">
        <xs:annotation>
            <xs:documentation>
                - A reference number issued for each unique PolicyID for a given Member, insured with a given Payer or Payer\TPA Plan.
                - It will be used as in input value in the GenerateMemberID process. Possible values: ‘01’, ‘02’, ‘03’,….’09’
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="3" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractProductCode">
        <xs:annotation>
            <xs:documentation>
                - This is the ID of the insurance product as in the insurer's marketing literature.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractTPAFee">
        <xs:annotation>
            <xs:documentation>
                The TPA's commission. Value depends on TPAFeeType.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitIPCopay">
        <xs:annotation>
            <xs:documentation>
                Members Inpatient Co-pay as per policy
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitOPCopay">
        <xs:annotation>
            <xs:documentation>
                Members Outpatient Co-pay as per policy
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitOPConsultationCopay">
        <xs:annotation>
            <xs:documentation>
                -   Copay/Deductible for outpatient consultation.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitPharmacyCopay">
        <xs:annotation>
            <xs:documentation>
                Pharmacy Co-pay as per policy
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitDentalCopay">
        <xs:annotation>
            <xs:documentation>
                Dental Co-Pay as per policy where applicable. If benefit is not part of the policy sender must mention N/A

            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitOpticalCopay">
        <xs:annotation>
            <xs:documentation>
                Optical Co-Pay as per policy where applicable. If benefit is not part of the policy sender must mention N/A
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="BenefitMaternityCopay">
        <xs:annotation>
            <xs:documentation>
                Maternity Co-Pay as per policy where applicable.If benefit is not part of the policy sender must mention N/A.
                If there are different copays for normal delivery and Cesarean section, the field allows entry to reflect this. E.g normal delivery 10% upto AED 500, Cesarean 15% upto AED 1000

            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="300" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractProductID">
        <xs:annotation>
            <xs:documentation>
                - Code granted by the eClaimLink to the registered product.
                - if there is no productID, use this ID: PayerID-0000-00 until you receive further instructions from DHA on Product Registration.
                - if ProductOrigin is 1 (Abu Dhabi), then use the Abu Dhabi Product ID.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractIntermediaryFee">
        <xs:annotation>
            <xs:documentation>
                The commission paid to the intermediary involved with placing this policy.
                Should be a percentage value of the premium. Must be a value between 0 - 100 (up to 2 decimal points are accepted.)
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ContractTPAFeeType">
        <xs:annotation>
            <xs:documentation>
                Select one of the following:
                1 = Fixed Fee per member
                2 = Percentage of claims
                3 = Fixed fee per Claim
                4 = Percentage of member premium
                5 = Capitation (IP and OP)
                6 = Capitation (IP only)
                7 = Capitation (OP only)
                8 = No TPA
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
            <xs:enumeration value="8" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractPolicyID">
        <xs:annotation>
            <xs:documentation>
                - The ID of the insurance policy as registered in the insurer's system.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractStartDate">
        <xs:annotation>
            <xs:documentation>
                -   This is the date the member first became insured.
                -   Restrictions:
                -   The ContractStartDate can not be a future date
                -   The ContractStartDate can not be less than 01/01/1900.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ContractEnrollmentDate">
        <xs:annotation>
            <xs:documentation>
                - The day (at 00.00 hours local time), month and year (dd/mm/yyyy) from which the Policy became effective for the Insured Member.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ContractDeletionDate">
        <xs:annotation>
            <xs:documentation>
                - Enter ExpiryDate of the policy unless the member has been removed prior to the expiry of the policy, in which case, enter the day at 00:00hrs local time, month and year (dd/mm/yyyy) on which the insured member's coverage ceases as the result of his/her deletion at the request of the PolicyHolder.
                - if there is no deletion date, this field needs to be filled with the expiry date of the policy.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ContractRenewalDate">
        <xs:annotation>
            <xs:documentation>
                -   This is the date the insurance was last renewed.
                -   If it is a first time insurance, the date should be the same as used for ContractStartDate.
                -   Restrictions:
                -   The ContractRenewalDate can not be a future date
                -   The ContractRenewalDate can not be less than 01/01/1900.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q2="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q2:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ContractExpiryDate">
        <xs:annotation>
            <xs:documentation>
                -   This is the date the insurance will expire if it is not renewed.
                -   Restrictions:
                -   The ContractExpiryDate can not be less than 01/01/1900.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q3="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q3:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ContractGrossPremium">
        <xs:annotation>
            <xs:documentation>
                This is the amount in AED of the annualized premium payable for this insured member.
                - if ProductOrigin is 1 (Abu Dhabi), then use 0000 as a default value.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ContractNetPremium">
        <xs:annotation>
            <xs:documentation>
                This is the amount in AED of the premium payable for this insured member if charged on a pro-rata basis related to period of coverage. If not charged on a pro-rata basis, then enter same figure as for GrossPremium.
                - if ProductOrigin is 1 (Abu Dhabi), then use 0000 as a default value.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ContractPolicyHolder">
        <xs:annotation>
            <xs:documentation>
                -   The indication of the policy holder Type.
                -   Restrictions:
                -   1 = Government
                -   2 = Government related services
                -   3 = Other
                -   4 = Private companies Less than 1000 employees
                -   5 = Private companies more than or equal to 1000 employees.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractCompanyID">
        <xs:annotation>
            <xs:documentation>
                -   This is the trade license number of the member's company.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="100" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ContractCompanyName">
        <xs:annotation>
            <xs:documentation>
                -   This is the trade name of the member's company.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="EstablishmentEntityType">
        <xs:annotation>
            <xs:documentation>
                - This is the type of the sponsoring entity: use the corresponding Number when you fill in the field.
                1 = Resident
                2 = UAE Citizen
                3 = Establishment
                4 = Investor Visa
                5 = GCC Citizen
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EstablishmentEntityID">
        <xs:annotation>
            <xs:documentation>
                - This is the official ID of the sponsoring entity:
                1. if the sponsor is a Resident, then use the File Number of the resident
                2. if the sponsor is a Citizen, then use the UID of the Citizen
                3. if the sponsor is an Establishment, then use the Establishment Code
                4. if the sponsor is on an Investor Visa, then use their File Number (for MemberType = 4,5), else the UID.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EstablishmentContactNumber">
        <xs:annotation>
            <xs:documentation>
                - This is the primary contact number of the policy holder.
                - use the standard format (Country code) (Area Code) ( Number)
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="15" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EstablishmentEmail">
        <xs:annotation>
            <xs:documentation>
                - The email address of the policy holder. If the policy holder is an establishment, this should be the email ID of an individual or a department responsible for health insurance related matters.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[^@]+@[^\.]+\..+" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TopUpPolicy">
        <xs:annotation>
            <xs:documentation>
                - Any policy which provides benefits over and above the benefits provided under the main Dubai compliant policy.
                - 1 = Top-Up Policy
                - 2 = Main Policy
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="MemberPhotoAttachment">
        <xs:annotation>
            <xs:documentation>
                -	Restriction: must be a base64Binary encoded
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:base64Binary" />
    </xs:simpleType>
    <!-- Claim Common types -->
    <xs:simpleType name="ClaimIDInvoice">
        <xs:annotation>
            <xs:documentation>
                -   The concatenation of all external provider invoice reference numbers sorted alphabetically and separated by '@'.
                -   Rationale: In some insurer-provider relationships, the provider does not record the insurer's Claims number (ClaimIDPayer) and the insurer does not record the provider's Claim number either (ClaimID).
                -   Financial transactions are instead communicated using the provider's invoice number.
                -   The only way to reconcile payments at the level of a Claim is to define a reference number ClaimIDInvoice by concatenating each of the provider external reference numbers on the invoices relating to the Claim.
                -   This creates a unique key for the Claim, which can be created independently by the provider as well as the insurer.
                -   It can thus be used to uniquely identify a Claim.
                -   Example 1: A provider submits a Claim to an insurer. The Claim has three invoices H00-1-op-017, H00-1-med-023, H00-2-sur-017. ClaimIDInvoice is "H00-1-med-023@H00-1-op-017@H00-2-sur-017"
                -   Example 2: A patient goes to a hospital, receives an invoice for his treatment, and pays out pocket. The invoice number is H23-07-09-11-0124. ClaimIDInvoice is "H23-07-09-11-0124"
                -   Example 3: A provider submits a Claim to an insurer. The Claim has only one invoice H001-1-op-984. ClaimIDInvoice is "H001-1-op-984"
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimID">
        <xs:annotation>
            <xs:documentation>
                -   The unique number assigned by the health provider to identify the Claim.
                -   This is also known as the provider's Claims reference number.
                -   It will be unique for each Claim.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimIDPayer">
        <xs:annotation>
            <xs:documentation>
                -   The unique number assigned by an insurer to identify the Claim.
                -   It helps the provider and payer to locate the Claim.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimMemberID">
        <xs:annotation>
            <xs:documentation>
                -   The patient's insurance member number, if the patient is claiming insurance.
                -   Otherwise, this field should be left empty.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimPayerID">
        <xs:annotation>
            <xs:documentation>
                -   The patient's insurance member number, if the patient is claiming insurance.
                -   For self paid schemes this should be the eClaimLink Self Paid scheme ID assigned by the DHA.
                -   Otherwise, this field should be left empty.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimProviderID">
        <xs:annotation>
            <xs:documentation>
                -   eClaimLink ID of the provider claiming from the Payer.
                -   This can be a facility or a clinician.
                -   ClaimProviderID is sometimes also known as the billing provider.
                -   In general, the facility that hosted the Encounter is also the one that claims from the payer. In these cases, ClaimProviderID is the same as EncounterFacilityID.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                -   The unique number the government assigns to a citizen. When an EmiratesIDNumber is not available :
                -   000-0000-0000000-0 National without card
                -   111-1111-1111111-1 Expatriate resident without a card
                -   222-2222-2222222-2 Non national, non-expat resident without a card
                -   999-9999-9999999-9 Unknown status, without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimGross">
        <xs:annotation>
            <xs:documentation>
                -	Is the total AED amount of the charges included on the Claim.
                -	ClaimGross includes any patient financial responsibility for the Claim, such as co-pays and deductibles, as well as charges made to other insurers for the Encounter(s) covered by the Claim.
                -	The prices on which ClaimGross are based should reflect the general agreement between the payer and provider for the Claim items for insured member.
                -   Example 1: A patient visits a clinic for a hip operation. The published list price is AED 8000. However, the insurer has negotiated with the provider a general discount of 10% on the published list price. ClaimGross is AED 7200.
                -   Example 2: A patient visits a clinic for a routine physical exam which costs AED 2000.The patient pays a co-pay of AED 250. ClaimGross is AED 2000.
                -   Example 3: A patient visits a clinic for a physical exam (AED 500) and an expensive diagnostic test (AED 1500) in one Encounter. The patient pays a co-pay of AED 250 and claims the diagnostic test from a supplementary insurance, because the primary insurance does not cover this diagnostic test. ClaimGross is AED 2000.
                -	Note: If the claimed amount is not in AED, then value should be converted to AED on the date of ClaimDateSubmission
                -	Restrictions: Non-negative and greater than or equal to ClaimPatientShare + ClaimNet.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ClaimPatientShare">
        <xs:annotation>
            <xs:documentation>
                -	The amount a patient owes a provider according to the terms of their insurance plan/product.
                -	If the patient has no insurance coverage for the visit, they are considered self-pay and liable for the entire amount, per their signed consent for treatment.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ClaimNet">
        <xs:annotation>
            <xs:documentation>
                -	The net charges included on the Claim. This is the amount the provider is expected to be paid.
                -   Example A: patient is admitted to the hospital for elective surgery.
                -   The surgery is billed on one Claim, and ClaimGross is AED 5000.
                -   The patient pays a co-pay of AED 400 (ClaimPatientShare is 400).
                -   The hospital charges the payer for the remaining AED 4600. ClaimNet is 4600.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ClaimDenialCode">
        <xs:annotation>
            <xs:documentation>
                -	The denial code if the claim is denied by the payer.
                -	The list of denail codes can be found at http://eclaimlink.ae/CodingSets.aspx for registered users.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimPaymentReference">
        <xs:annotation>
            <xs:documentation>
                -	The unique identifier for the payment transaction, which is often the Cheque number.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="25" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimPaymentAmount">
        <xs:annotation>
            <xs:documentation>
                -	The amount paid by the payer towards the provider's Claim.
                -	Example: A payer received a Claim with a net amount of AED 4600 (ClaimNet AED is 4600).
                -   The payer decides to make deductions of AED 600, and pays the remaining amount.
                -   ClaimPaymentAmount is 4000.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="ClaimDateSubmitted">
        <xs:annotation>
            <xs:documentation>
                -	The date a Claim was submitted by the billing healthcare provider.
                -	Restrictions:
                -   ClaimDateSubmitted cannot be a future date
                -   ClaimDateSubmitted needs to be after EncounterStart.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ClaimDateReceived">
        <xs:annotation>
            <xs:documentation>
                -	The date a Claim is received by the insurer
                -	Restrictions:
                -   ClaimDateReceived cannot be a future date
                -   ClaimDateReceived needs to be on or after ClaimDateSubmitted.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q2="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q2:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ClaimDateSettlement">
        <xs:annotation>
            <xs:documentation>
                -	The date the payer settles the Claim. In general this will be the date that payment is made.
                -	If Payment is made in several steps, the latest date should be used.
                -	If the value of the Claim agreed by the Payer is 0, then settlement does not entail payment.
                -	Restrictions: ClaimDateSettled needs to be after ClaimDateReceived.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q3="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q3:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="RAComments">
        <xs:annotation>
            <xs:documentation>
                -	The comments given to add more details on the Remittance Advice.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="2000" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimDateSettlementReceived">
        <xs:annotation>
            <xs:documentation>
                -	The date the payer receives payment of the Claim.
                -	If settlement is made in several steps, the latest date of receipt should be used.
                -	If the settlement value is 0, then this is the date of notification of settlement
                -	If the provider has designated an intermediary.
                -	Example: another provider or organization to receive payment, it is the date that designated organization receives payment.
                -	Restrictions: Needs to be between ClaimDateSettled and the present.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q4="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q4:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ClaimDateLastTransaction">
        <xs:annotation>
            <xs:documentation>
                -	The latest date at which the ClaimStatus changed.
                -	Example 1:
                -   A provider submits a Claim on June 12 2012.
                -   The Payer receives the Claim on June 14 2007.
                -   Since that time the Claim has been in process with the Payer.
                -   For the Provider ClaimDateLastTransaction is 12/06/2012, whereas for the Payer ClaimDateLastTransaction is 14/06/2012.
                -	Example 2:
                -   A Payer receives a Claim on June 12 2012.
                -   On June 19 the Payer asks the Provider for necessary supporting detail about the Claim.
                -   The Provider has not replied since.
                -   ClaimDateLastTransaction is 19/03/2007 for both the Payer and the Provider.
                -	Restrictions: Needs to be at or after ClaimDateReceived and cannot be in the future.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q5="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q5:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ClaimStatus">
        <xs:annotation>
            <xs:documentation>
                -	ClaimStatus describes the processing status of the Claim, from the time the provider submits the Claim to the time until the provider considers it settled.
                -	ClaimStatus is empty, until the Provider has submitted a Claim
                -	The Provider considers ClaimStatus to be:
                -   In Process with the Payer from the time the Claim has been submitted until the Payer either asks for clarification (ClaimStatus is then Pending), settles the Claim and the settlement is received by the Provider (ClaimStatus is then PayerSettled), or the Payer chooses to actively withhold payment and has communicated this to the provider (ClaimStatus is then Withheld).
                -   Pending with the provider from the time the provider has received a request for clarification from the Payer until the Provider has replied to the Payer. (ClaimStatus is then In Process)
                -   Withheld from the time the Payer has communicated that payment is Withheld, until the Payer settles the Claim (ClaimStatus is then PayerSettled)
                -   PayerSettled from the time the provider receives notice of settlement, either through receipt of a settlement amount or notification that the settlement amount is 0.
                -   ProviderSettled as and when the Provider considers the Claim to be settled.
                -	The Payer considers ClaimStatus to be
                -   In Process with the Payer from the time the Claim has received until the Payer either asks for clarification (ClaimStatus is then Pending), settles the Claim and the settlement is received by the Provider (ClaimStatus is then PayerSettled), or the Payer may choose to actively withhold payment and has communicated this to the provider (ClaimStatus is then Withheld).
                -   Pending with the provider from the time the Payer has made a request for clarification from the Provider until the Provider has replied to the Payer. (ClaimStatus is then In Process)
                -   Withheld if the Payer has fully processed the Claim to the point that it is ready to be settled, but that the Payer chooses (for a reason unrelated to the specific Claim in question) to withhold payment and has communicated this to the provider. ClaimStatus remains Withheld until the Payer settles the Claim (ClaimStatus is then PayerSettled)
                -   PayerSettled from the time the Payer has settled the Claim.
                -   ProviderSettled as and when the Payer has received notification that the Provider considers the Claim to be settled
                -	Example:
                -   A provider submits a Claim C1 to an insurer in a batch.
                -   The insurer processes the Claim and is ready to settle it.
                -   Some other Claims in the batch are still pending with the provider, however.
                -   The insurer decides to wait for payment of the entire batch, until all Claims have been processed.
                -   The Claim C1 would have ClaimStatus Withheld.
                -	If for any reason the Payer or the Provider is unable to differentiate between
                -   In Process and Pending, ClaimStatus should be (InProcess or Pending)
                -   In Process and Withheld, ClaimStatus should be (InProcess or Withheld)
                -   Pending and Withheld, ClaimStatus should be (Pending or Withheld)
                -   In Process, Pending and Withheld, ClaimStatus should be (Pending, In Process or Withheld)
                -	Restrictions: If ClaimDateSubmitted is empty, ClaimStatus needs to be empty; only values allowed are
                -   1 = In Process with Payer
                -   2 = Pending at Provider
                -   3 = Withheld by Payer
                -   4 = PayerSettled
                -   5 = ProviderSettled
                -   6 = In Process or Pending
                -   7 = In Process or Withheld
                -   8 = Pending or Withheld
                -   9 = Pending, In Process or Withheld.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:enumeration value="1" />
            <xs:enumeration value="2" />
            <xs:enumeration value="3" />
            <xs:enumeration value="4" />
            <xs:enumeration value="5" />
            <xs:enumeration value="6" />
            <xs:enumeration value="7" />
            <xs:enumeration value="8" />
            <xs:enumeration value="9" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ClaimOccupationRelated">
        <xs:annotation>
            <xs:documentation>
                -	The information if the encounter is related to the occupation.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="yes" />
            <xs:enumeration value="no" />
        </xs:restriction>
    </xs:simpleType>
    <!-- Authorization Common Types -->
    <xs:simpleType name="AuthorizationEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                -	The unique number the government assigns to a citizen. When an EmiratesIDNumber is not available :
                -   000-0000-0000000-0 National without card
                -   111-1111-1111111-1 Expatriate resident without a card
                -   222-2222-2222222-2 Non national, non-expat resident without a card
                -   999-9999-9999999-9 Unknown status, without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationType">
        <xs:annotation>
            <xs:documentation>
                -	Specifies Type using Values: Eligibility, Authorization, Cancellation, Extension, Status Inquiry.
                -	Based on this Type certain optional elements in the transaction may become mandatory
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Eligibility" />
            <xs:enumeration value="Authorization" />
            <xs:enumeration value="Cancellation" />
            <xs:enumeration value="Extension" />
            <xs:enumeration value="Status Inquiry" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationResult">
        <xs:annotation>
            <xs:documentation>
                -	The answer of the inquiry: Yes or No .
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Yes" />
            <xs:enumeration value="No" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationID">
        <xs:annotation>
            <xs:documentation>
                -	The unique number assigned by the health provider to identify the Authorization.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationIDPayer">
        <xs:annotation>
            <xs:documentation>
                -	The unique number assigned by an insurer to identify the Authorization.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationMemberID">
        <xs:annotation>
            <xs:documentation>
                -	The patient's insurance member number, if the patient is claiming insurance.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationPayerID">
        <xs:annotation>
            <xs:documentation>
                -	If the patient is claiming insurance cover, this is eClaimLink's insurance license number.
                -   For self paid schemes this should be the eClaimLink Self Paid scheme ID assigned by the DHA.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationDenialCode">
        <xs:annotation>
            <xs:documentation>
                -	The denial code if the claim is denied by the payer. The list of denial codes can be found at http://www.eclaimlink.ae/CodingSets.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationDateOrdered">
        <xs:annotation>
            <xs:documentation>
                -	The date on which the prescription/order is ordered/prescribed.
                -	This is required to check:
                -   Validity of a prescription/order
                -   Or onset of condition to exclude pre-existing conditions as per policy coverage.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="AuthorizationLimit">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the Authorization Limit
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="AuthorizationStart">
        <xs:annotation>
            <xs:documentation>
                -	The date and time at which Activity started.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="AuthorizationEnd">
        <xs:annotation>
            <xs:documentation>
                -	The date and time at which Activity ended.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="AuthorizationComments">
        <xs:annotation>
            <xs:documentation>
                -	The comments given to add more details on the Authorization.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="0" />
            <xs:maxLength value="2000" />
        </xs:restriction>
    </xs:simpleType>
    <!-- ePrescription Common Types -->
    <xs:simpleType name="PrescriptionID">
        <xs:annotation>
            <xs:documentation>
                -	The unique number assigned by the health provider to identify the e-Prescription (eRx).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrescriptionType">
        <xs:annotation>
            <xs:documentation>
                -	Specifies the e-Prescription (eRx) transaction type using Values: eRxRequest, eRxCancellation.
                -	Based on this Type certain optional elements in the transaction may become mandatory.
                -	Fields mandated based on type can be found in the Validation Rules table.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="eRxRequest" />
            <xs:enumeration value="eRxCancellation" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrescriptionPayerID">
        <xs:annotation>
            <xs:documentation>
                -	If the patient is claiming insurance cover, this is eClaimLink's insurance license number.
                -   For self paid schemes this should be the eClaimLink Self Paid scheme ID assigned by the DHA.
                -	If the patient is paying directly for the services provided, this should be (CashPatient).
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrescriptionClinician">
        <xs:annotation>
            <xs:documentation>
                -	In general the Clinician is the person providing the e-Prescription, treatment or care for the patient.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrescriptionMemberID">
        <xs:annotation>
            <xs:documentation>
                -	In the case of an insurance patient: The patient's insurance member number.
                -	In the case of a cash patient: Any unique identifier of the patient (Emirates ID, Passport #, Immigration #)
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrescriptionEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                -	The unique number the government assigns to a citizen.
                -	When an EmiratesIDNumber is not available:
                -   000-0000-0000000-0 National without card
                -   111-1111-1111111-1 Expatriate resident without a card
                -   222-2222-2222222-2 Non national, non-expat resident without a card
                -   999-9999-9999999-9 Unknown status, without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PatientBirthDate">
        <xs:annotation>
            <xs:documentation>
                -	Is the date on which a person was born or is officially deemed to have been born.
                -	In cases, where despite best efforts PerspnBirthDate is not known, but the age is known; then the birth date should be assumed to be on the 1st of January of the current year, minus the age of the person.
                -   Example: A patient arrives on January 8th 2008 and Claims he is 64 years old, but does not know his date of birth. The PatientBirthDate should be assumed to be 01/01/1944.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="PatientWeight">
        <xs:annotation>
            <xs:documentation>
                -	The patient's weight in kilograms (Kg)
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="PatientEmail">
        <xs:annotation>
            <xs:documentation>
                -	The personal email address of the patient.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[^@]+@[^\.]+\..+" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityDuration">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the duration in days for the prescribed activity.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityRefills">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the number of refills for a given activity.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float">
            <xs:minInclusive value="0" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ActivityRoutOfAdmin">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the rout of admin for a given activity.
                -	list of rout of admin values can be found on the eClaimLink code lists page http://www.eclaimlink.ae/CodingSets.aspx
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="ActivityInstructions">
        <xs:annotation>
            <xs:documentation>
                -	Identifies the instructions for a given activity as provided by the prescribing clinician.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string" />
    </xs:simpleType>
    <xs:simpleType name="UnitPerFrequency">
        <xs:annotation>
            <xs:documentation>
                -	Granular unit of the frequency.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="FrequencyValue">
        <xs:annotation>
            <xs:documentation>
                -	Number of repetitions for a given frequency.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:float" />
    </xs:simpleType>
    <xs:simpleType name="FrequencyType">
        <xs:annotation>
            <xs:documentation>
                -	Frequency time unit.
                -	Possible values:
                -	Hour
                -	Day
                -	Week
                -	Once
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Hour" />
            <xs:enumeration value="Day" />
            <xs:enumeration value="Week" />
            <xs:enumeration value="Once" />
        </xs:restriction>
    </xs:simpleType>
    <!-- eReferral Common Types -->
    <xs:simpleType name="ReferralType">
        <xs:annotation>
            <xs:documentation>
                -	Type of the Referral Transaction.
                - 	Value must be one of the following:
                -	Referral = for a new electronic referral transaction
                -	Cancellation = for cancelling an electronic referral transaction
                -	Discharge = for discharging a patient
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Referral" />
            <xs:enumeration value="Cancellation" />
            <xs:enumeration value="Discharge" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="eReferralID">
        <xs:annotation>
            <xs:documentation>
                -   The unique number assigned by the health provider to identify the eReferral.
                -   This is also known as the provider's eReferral reference number.
                -   It will be unique for each Referral on the provider level.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PreviousReferralReferenceID">
        <xs:annotation>
            <xs:documentation>
                -   The unique number assigned by the eReferralHub to the previous eReferral linked within this eReferral.
                -   This is also known as the provider's eReferral reference number.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="50" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralPayerID">
        <xs:annotation>
            <xs:documentation>
                - The patient's insurance member number, if the patient is claiming insurance.
                - Otherwise, this field should be left empty.
                - Space cannot be used within this field.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralStart">
        <xs:annotation>
            <xs:documentation>
                - The date and time at which eReferral started.
                - Restrictions: Needs to be after 01/06/2012 and before the present.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q8="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q8:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ReferralEnd">
        <xs:annotation>
            <xs:documentation>
                - The date and time at which eReferral endedended.
                - Restrictions: Needs to be after 01/06/2012 and before the present.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q8="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q8:DateTimeForm" />
    </xs:simpleType>
    <xs:simpleType name="ReferralClinician">
        <xs:annotation>
            <xs:documentation>
                -	In general the Clinician is the person providing the referral for the patient.
                -	Space cannot be used within this field.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralSpecialty">
        <xs:annotation>
            <xs:documentation>
                -	Specialty of the Clinician that is providing the referral for the patient.
                -	List of Specialities can be found at http://www.eclaimlink.ae website.
                - 	Space cannot be used within this field.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[\S]*" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralMemberID">
        <xs:annotation>
            <xs:documentation>
                -   The patient's insurance member number.
                -	In case the patient does not have an insurance member number, then the field should contain the value "SelfPay"
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:maxLength value="30" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralEmiratesIDNumber">
        <xs:annotation>
            <xs:documentation>
                -   The unique number the government assigns to a citizen.
                -   When an EmiratesIDNumber is not available :
                -   000-0000-0000000-0 National without card
                -   111-1111-1111111-1 Expatriate resident without a card
                -   222-2222-2222222-2 Non national, non-expat resident without a card
                -   999-9999-9999999-9 Unknown status, without a card.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1" />
            <xs:pattern value="[0-9]{3}-[0-9]{4}-[0-9]{7}-[0-9]{1}" />
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ReferralMemberDateOfBirth">
        <xs:annotation>
            <xs:documentation>
                -	Is the date on which a person was born or is officially deemed to have been born.
                -	In cases, where despite best efforts PerspnBirthDate is not known, but the age is known; then the birth date should be assumed to be on the 1st of January of the current year, minus the age of the person.
                -   Example: A patient arrives on January 8th 2008 and Claims he is 64 years old, but does not know his date of birth. The PatientBirthDate should be assumed to be 01/01/1944.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction xmlns:q1="http://www.eclaimlink.ae/DHD/ValidationSchema" base="q1:DateForm" />
    </xs:simpleType>
    <xs:simpleType name="ReferralMemberEmail">
        <xs:annotation>
            <xs:documentation>
                -	The personal email address of the insured member.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[^@]+@[^\.]+\..+" />
        </xs:restriction>
    </xs:simpleType>
</xs:schema>



// ===== File: C:\Users\kvikr\Downloads\claims-backend-full\src\main\resources\xsd\RemittanceAdvice.xsd =====

<xs:schema xmlns:tns="http://www.eclaimlink.ae/DHD/ValidationSchema" elementFormDefault="qualified" version="2.0" id="RemittanceAdvice" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:import schemaLocation="CommonTypes.xsd" namespace="http://www.eclaimlink.ae/DHD/ValidationSchema" />
    <xs:element name="Remittance.Advice">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="1" maxOccurs="1" name="Header">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element minOccurs="1" maxOccurs="1" name="SenderID" type="tns:HeaderSenderID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="ReceiverID" type="tns:HeaderReceiverID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="TransactionDate" type="tns:HeaderTransactionDate" />
                            <xs:element minOccurs="1" maxOccurs="1" name="RecordCount" type="tns:HeaderRecordCount" />
                            <xs:element minOccurs="1" maxOccurs="1" name="DispositionFlag" type="tns:HeaderDispositionFlag" />
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element minOccurs="1" maxOccurs="unbounded" name="Claim">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element minOccurs="1" maxOccurs="1" name="ID" type="tns:ClaimID" />
                            <xs:element minOccurs="1" maxOccurs="1" name="IDPayer" type="tns:ClaimIDPayer" />
                            <xs:element minOccurs="0" maxOccurs="1" name="ProviderID" type="tns:ClaimProviderID" />
                            <xs:element minOccurs="0" maxOccurs="1" name="DenialCode" type="tns:ClaimDenialCode" />
                            <xs:element minOccurs="1" maxOccurs="1" name="PaymentReference" type="tns:ClaimPaymentReference" />
                            <xs:element minOccurs="0" maxOccurs="1" name="DateSettlement" type="tns:ClaimDateSettlement" />
                            <xs:element minOccurs="0" maxOccurs="1" name="Encounter">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="0" maxOccurs="1" name="FacilityID" type="tns:EncounterFacilityID" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element minOccurs="1" maxOccurs="unbounded" name="Activity">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element minOccurs="1" maxOccurs="1" name="ID" type="tns:ActivityID" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Start" type="tns:ActivityStart" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Type" type="tns:ActivityType" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Code" type="tns:ActivityCode" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Quantity" type="tns:ActivityQuantity" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Net" type="tns:ActivityNet" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="List" type="tns:ActivityList" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="Clinician" type="tns:ActivityClinician" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="PriorAuthorizationID" type="tns:ActivityPriorAuthorizationID" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="Gross" type="tns:ActivityGross" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="PatientShare" type="tns:ActivityPatientShare" />
                                        <xs:element minOccurs="1" maxOccurs="1" name="PaymentAmount" type="tns:ActivityPaymentAmount" />
                                        <xs:element minOccurs="0" maxOccurs="1" name="DenialCode" type="tns:ActivityDenialCode" />
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>


